{
    "docs": [
        {
            "location": "/",
            "text": "LdapTools\n\n\nA feature-rich LDAP library for PHP 5.6+.\n\n\n\n\nOverview\n\n\nLdapTools is designed to be customizable for use with pretty much any directory service, but contains default attribute converters and schemas \nfor Active Directory and OpenLDAP. \n\n\n\n\nA fluent and easy to understand syntax for \ngenerating LDAP queries\n.\n\n\nEasily \ncreate\n/\nmodify\n/\ndelete\n/\nrestore\n common LDAP objects (Users, Groups, Contacts, Computers, OUs).\n\n\nRetrieve LDAP objects as either a simple array or an object with automagic setters/getters.\n\n\nA \nlogging mechanism\n for all LDAP operations\n\n\nAn \nevent system\n for further customization, extensibility, and integration.\n\n\nParse and create \nLDIF files\n.\n\n\nView and modify \nActive Directory permissions\n.\n\n\n\n\nInstallation\n\n\nThe recommended way to install LdapTools is using \nComposer\n:\n\n\ncomposer require ldaptools/ldaptools\n\n\n\n\nGetting Started\n\n\nThe easiest way to get started is by creating a YAML config file. See the \nexample config\n file for basic usage.\n\n\nOnce you have a configuration file defined, you can get up and running by doing the following:\n\n\nuse LdapTools\\Configuration;\nuse LdapTools\\LdapManager;\n\n$config = (new Configuration())->load('/path/to/ldap/config.yml');\n$ldap = new LdapManager($config);\n\n\n\n\nSearching LDAP\n\n\nWith the \nLdapManager\n up and going you can now easily build LDAP queries without having to remember all the special \nsyntax for LDAP filters. All values are also automatically escaped. Check the \ntutorial\n for all\navailable methods and the \ncookbook\n for more query examples.\n\n\n// Get an instance of the query...\n$query = $ldap->buildLdapQuery();\n\n// Returns a LdapObjectCollection of all users whose first name \n// starts with 'Foo' and last name is 'Bar' or 'Smith'.\n// The result set will also be ordered by state name (ascending).\n$users = $query->fromUsers()\n    ->where($query->filter()->startsWith('firstName', 'Foo'))\n    ->orWhere(['lastName' => 'Bar'])\n    ->orWhere(['lastName' => 'Smith'])\n    ->orderBy('state')\n    ->getLdapQuery()\n    ->getResult();\n\necho \"Found \".$users->count().\" user(s).\";\nforeach ($users as $user) {\n    echo \"User: \".$user->getUsername();\n}\n\n// Get all OUs and Containers at the base of the domain, ordered by name.\n$results = $ldap->buildLdapQuery()\n    ->from(LdapObjectType::OU)\n    ->from(LdapObjectType::CONTAINER)\n    ->orderBy('name')\n    ->setScopeOneLevel()\n    ->getLdapQuery()\n    ->getResult();\n\n// Get a single LDAP object and select some specific attributes...\n$user = $ldap->buildLdapQuery()\n    ->select(['upn', 'guid', 'sid', 'passwordLastSet'])\n    ->fromUsers()\n    ->where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Get a single attribute value from a LDAP object...\n$guid = $ldap->buildLdapQuery()\n    ->select('guid')\n    ->fromUsers()\n    ->where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleScalarResult();\n\n// It also supports the concepts of repositories...\n$userRepository = $ldap->getRepository('user');\n\n// Find all users whose last name equals Smith.\n$users = $userRepository->findByLastName('Smith');\n\n// Get the first user whose username equals 'jsmith'. Returns a `LdapObject`.\n$user = $userRepository->findOneByUsername('jsmith');\necho \"First name \".$user->getFirstName().\" and last name \".$user->getLastName();\n\n\n\n\nSee \nthe docs\n for more information on building LDAP queries.\n\n\nModifying LDAP Objects\n\n\nModifying LDAP is as easy as searching for the LDAP object as described above, then making changes directly to the object\nand saving it back to LDAP using the \nLdapManager\n.\n\n\n$user = $ldap->buildLdapQuery()\n    ->select(['title', 'mobilePhone', 'disabled'])\n    ->fromUsers()\n    ->where(['username' => 'jsmith'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Make some modifications to the user account.\n// All these changes are tracked so it knows how to modify the object.\n$user->setTitle('CEO');\n\nif ($user->hasMobilePhone()) {\n    $user->resetMobilePhone();\n}\n\n// Set a field by a property instead...\nif ($user->disabled) {\n    $user->disabled = false;\n}\n\n// Add a value to an attribute...\n$user->addOtherIpPhones('#001-5555');\n// Add a few values at one time...\n$user->addOtherIpPhones('#001-4444', '#001-3333', '#001-2222');\n\n// Now actually save the changes back to LDAP...\ntry {\n    $ldap->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error updating user! \".$e->getMessage();\n}\n\n\n\n\nSee \nthe docs\n for more information on modifying LDAP objects.\n\n\nDeleting LDAP Objects\n\n\nDeleting LDAP objects is a simple matter of searching for the object you want to remove, then passing it to the delete\nmethod on the \nLdapManager\n:\n\n\n// Decide they no longer work here and should be deleted?\n$user = $userRepository->findOneByUsername('jsmith');\n\ntry {\n    $ldap->delete($user);\n} catch (\\Exception $e) {\n    echo \"Error deleting user! \".$e->getMessage();\n}\n\n\n\n\nCreating LDAP Objects\n\n\nCreating LDAP objects is easily performed by just passing what you want the attributes to be and what container/OU the\nobject should end up in:\n\n\n$ldapObject = $ldap->createLdapObject();\n\n// Creating a user account (enabled by default)\n$ldapObject->createUser()\n    ->in('cn=Users,dc=example,dc=local')\n    ->with(['username' => 'jsmith', 'password' => '12345'])\n    ->execute();\n\n// Create a typical AD global security group...\n$ldapObject->createGroup()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Generic Security Group'])\n    ->execute();\n\n// Creates a contact user...\n$ldapObject->createContact()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Some Guy', 'emailAddress' => 'SomeGuy@SomeDomain.com'])\n    ->execute();\n\n// Creates a computer object...\n$ldapObject->createComputer()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'MYWOKRSTATION'])\n    ->execute();\n\n// Creates an OU object...\n$ldapObject->createOU()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Employees'])\n    ->execute();\n\n\n\n\nSee \nthe docs\n for more information on creating LDAP objects.\n\n\nDocumentation\n\n\n\n\nMain Configuration Reference\n\n\nSchema Configuration\n\n\nUsing the LdapManager\n\n\nBuilding LDAP Queries\n\n\nCreating LDAP Objects\n\n\nModifying LDAP Objects\n\n\nLDIF files\n\n\nActive Directory permissions\n\n\nDefault Schema Attributes\n\n\nThe Event System\n\n\n\n\nTODO\n\n\nThings that still need to be implemented:\n\n\n\n\nAutomatic generation of the schema based off of information in LDAP.\n\n\nMore work needed on the OpenLDAP schema.",
            "title": "Home"
        },
        {
            "location": "/#ldaptools",
            "text": "A feature-rich LDAP library for PHP 5.6+.",
            "title": "LdapTools"
        },
        {
            "location": "/#overview",
            "text": "LdapTools is designed to be customizable for use with pretty much any directory service, but contains default attribute converters and schemas \nfor Active Directory and OpenLDAP.    A fluent and easy to understand syntax for  generating LDAP queries .  Easily  create / modify / delete / restore  common LDAP objects (Users, Groups, Contacts, Computers, OUs).  Retrieve LDAP objects as either a simple array or an object with automagic setters/getters.  A  logging mechanism  for all LDAP operations  An  event system  for further customization, extensibility, and integration.  Parse and create  LDIF files .  View and modify  Active Directory permissions .",
            "title": "Overview"
        },
        {
            "location": "/#installation",
            "text": "The recommended way to install LdapTools is using  Composer :  composer require ldaptools/ldaptools",
            "title": "Installation"
        },
        {
            "location": "/#getting-started",
            "text": "The easiest way to get started is by creating a YAML config file. See the  example config  file for basic usage.  Once you have a configuration file defined, you can get up and running by doing the following:  use LdapTools\\Configuration;\nuse LdapTools\\LdapManager;\n\n$config = (new Configuration())->load('/path/to/ldap/config.yml');\n$ldap = new LdapManager($config);",
            "title": "Getting Started"
        },
        {
            "location": "/#searching-ldap",
            "text": "With the  LdapManager  up and going you can now easily build LDAP queries without having to remember all the special \nsyntax for LDAP filters. All values are also automatically escaped. Check the  tutorial  for all\navailable methods and the  cookbook  for more query examples.  // Get an instance of the query...\n$query = $ldap->buildLdapQuery();\n\n// Returns a LdapObjectCollection of all users whose first name \n// starts with 'Foo' and last name is 'Bar' or 'Smith'.\n// The result set will also be ordered by state name (ascending).\n$users = $query->fromUsers()\n    ->where($query->filter()->startsWith('firstName', 'Foo'))\n    ->orWhere(['lastName' => 'Bar'])\n    ->orWhere(['lastName' => 'Smith'])\n    ->orderBy('state')\n    ->getLdapQuery()\n    ->getResult();\n\necho \"Found \".$users->count().\" user(s).\";\nforeach ($users as $user) {\n    echo \"User: \".$user->getUsername();\n}\n\n// Get all OUs and Containers at the base of the domain, ordered by name.\n$results = $ldap->buildLdapQuery()\n    ->from(LdapObjectType::OU)\n    ->from(LdapObjectType::CONTAINER)\n    ->orderBy('name')\n    ->setScopeOneLevel()\n    ->getLdapQuery()\n    ->getResult();\n\n// Get a single LDAP object and select some specific attributes...\n$user = $ldap->buildLdapQuery()\n    ->select(['upn', 'guid', 'sid', 'passwordLastSet'])\n    ->fromUsers()\n    ->where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Get a single attribute value from a LDAP object...\n$guid = $ldap->buildLdapQuery()\n    ->select('guid')\n    ->fromUsers()\n    ->where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleScalarResult();\n\n// It also supports the concepts of repositories...\n$userRepository = $ldap->getRepository('user');\n\n// Find all users whose last name equals Smith.\n$users = $userRepository->findByLastName('Smith');\n\n// Get the first user whose username equals 'jsmith'. Returns a `LdapObject`.\n$user = $userRepository->findOneByUsername('jsmith');\necho \"First name \".$user->getFirstName().\" and last name \".$user->getLastName();  See  the docs  for more information on building LDAP queries.",
            "title": "Searching LDAP"
        },
        {
            "location": "/#modifying-ldap-objects",
            "text": "Modifying LDAP is as easy as searching for the LDAP object as described above, then making changes directly to the object\nand saving it back to LDAP using the  LdapManager .  $user = $ldap->buildLdapQuery()\n    ->select(['title', 'mobilePhone', 'disabled'])\n    ->fromUsers()\n    ->where(['username' => 'jsmith'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Make some modifications to the user account.\n// All these changes are tracked so it knows how to modify the object.\n$user->setTitle('CEO');\n\nif ($user->hasMobilePhone()) {\n    $user->resetMobilePhone();\n}\n\n// Set a field by a property instead...\nif ($user->disabled) {\n    $user->disabled = false;\n}\n\n// Add a value to an attribute...\n$user->addOtherIpPhones('#001-5555');\n// Add a few values at one time...\n$user->addOtherIpPhones('#001-4444', '#001-3333', '#001-2222');\n\n// Now actually save the changes back to LDAP...\ntry {\n    $ldap->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error updating user! \".$e->getMessage();\n}  See  the docs  for more information on modifying LDAP objects.",
            "title": "Modifying LDAP Objects"
        },
        {
            "location": "/#deleting-ldap-objects",
            "text": "Deleting LDAP objects is a simple matter of searching for the object you want to remove, then passing it to the delete\nmethod on the  LdapManager :  // Decide they no longer work here and should be deleted?\n$user = $userRepository->findOneByUsername('jsmith');\n\ntry {\n    $ldap->delete($user);\n} catch (\\Exception $e) {\n    echo \"Error deleting user! \".$e->getMessage();\n}",
            "title": "Deleting LDAP Objects"
        },
        {
            "location": "/#creating-ldap-objects",
            "text": "Creating LDAP objects is easily performed by just passing what you want the attributes to be and what container/OU the\nobject should end up in:  $ldapObject = $ldap->createLdapObject();\n\n// Creating a user account (enabled by default)\n$ldapObject->createUser()\n    ->in('cn=Users,dc=example,dc=local')\n    ->with(['username' => 'jsmith', 'password' => '12345'])\n    ->execute();\n\n// Create a typical AD global security group...\n$ldapObject->createGroup()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Generic Security Group'])\n    ->execute();\n\n// Creates a contact user...\n$ldapObject->createContact()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Some Guy', 'emailAddress' => 'SomeGuy@SomeDomain.com'])\n    ->execute();\n\n// Creates a computer object...\n$ldapObject->createComputer()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'MYWOKRSTATION'])\n    ->execute();\n\n// Creates an OU object...\n$ldapObject->createOU()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Employees'])\n    ->execute();  See  the docs  for more information on creating LDAP objects.",
            "title": "Creating LDAP Objects"
        },
        {
            "location": "/#documentation",
            "text": "Main Configuration Reference  Schema Configuration  Using the LdapManager  Building LDAP Queries  Creating LDAP Objects  Modifying LDAP Objects  LDIF files  Active Directory permissions  Default Schema Attributes  The Event System",
            "title": "Documentation"
        },
        {
            "location": "/#todo",
            "text": "Things that still need to be implemented:   Automatic generation of the schema based off of information in LDAP.  More work needed on the OpenLDAP schema.",
            "title": "TODO"
        },
        {
            "location": "/cookbook/Authenticating-a-User/",
            "text": "Authenticating a User\n\n\n\n\nOften times you may want to simply test a username/password against LDAP to see if it is valid. This can be done with a\nshorthand method directly on the \nLdapManager\n class:\n\n\n\n// With your LdapManager class already instantiated...\nif ($ldapManager->authenticate($username, $password)) {\n    echo \"Success! The password for $username is correct.\";\n}\n\n\n\n\nThis method creates an authentication operation object and executes it against the current connection. You could also\ndo the following:\n\n\nuse LdapTools\\Operation\\AuthenticationOperation;\n\n$operation = (new AuthenticationOperation())->setUsername($username)->setPassword($password);\n\n// With your LdapManager class already instantiated...\n$response = $ldapManager->getConnection()->execute($operation);\n\nif (!$response->isAuthenticated()) {\n    echo \"Error validating password for '\".$operation->getUsername().\"': \".$response->getErrorMessage();\n}\n\n\n\n\nValid Username Formats\n\n\nThe \nauthenticate()\n method username argument can be the same value types as the username you defined in your config. For\nActive Directory, this means you can authenticate a user using either a UPN, a text SID, a text GUID, a\ndistinguished name, or just a normal username. With OpenLDAP the username must be a full DN. However, you can adjust the\n\nbind_format\n option for the domain configuration to modify this behavior.\n\n\nAuthentication Error Messages\n\n\nThere are many times where you may want to provide a more meaningful response as to why authentication for a user has\nfailed. This information is possible to get by passing additional optional variables to the \nauthenticate()\n method.\n\n\n\n// With your LdapManager class already instantiated...\nif (!$ldapManager->authenticate($username, $password, $message, $code)) {\n     echo \"Error ($code): $message\";\n}\n\n\n\n\nWhen using Active Directory, the above can give you very helpful information as to why the user cannot log in. Such as a\ndisabled account, a locked account, or an account whose password needs to change before they can login again. The most\ncommon error codes you may see in AD:\n\n\n\n\n\n\n\n\nError Number\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1317\n\n\nACCOUNT_INVALID\n\n\nAccount does not exist.\n\n\n\n\n\n\n1326\n\n\nACCOUNT_CREDENTIALS_INVALID\n\n\nAccount password is invalid.\n\n\n\n\n\n\n1327\n\n\nACCOUNT_RESTRICTIONS\n\n\nAccount Restrictions prevent this user from signing in.\n\n\n\n\n\n\n1328\n\n\nACCOUNT_RESTRICTIONS_TIME\n\n\nTime Restriction - The account cannot login at this time.\n\n\n\n\n\n\n1329\n\n\nACCOUNT_RESTRICTIONS_DEVICE\n\n\nDevice Restriction - The account is not allowed to log on to this computer.\n\n\n\n\n\n\n1330\n\n\nACCOUNT_PASSWORD_EXPIRED\n\n\nThe password for the account has expired.\n\n\n\n\n\n\n1331\n\n\nACCOUNT_DISABLED\n\n\nThe account is currently disabled.\n\n\n\n\n\n\n1384\n\n\nACCOUNT_CONTEXT_IDS\n\n\nThe account is a member of too many groups and cannot be logged on.\n\n\n\n\n\n\n1793\n\n\nACCOUNT_EXPIRED\n\n\nThe account has expired.\n\n\n\n\n\n\n1907\n\n\nACCOUNT_PASSWORD_MUST_CHANGE\n\n\nThe accounts password must change before it can login.\n\n\n\n\n\n\n1909\n\n\nACCOUNT_LOCKED\n\n\nThe account is currently locked out.\n\n\n\n\n\n\n\n\nAll constants are located in \n\\LdapTools\\Connection\\ADResponseCodes\n. You should use those constants to compare against \nthe received error number to take a specific action for an event.",
            "title": "Authenticating a User"
        },
        {
            "location": "/cookbook/Authenticating-a-User/#authenticating-a-user",
            "text": "Often times you may want to simply test a username/password against LDAP to see if it is valid. This can be done with a\nshorthand method directly on the  LdapManager  class:  \n// With your LdapManager class already instantiated...\nif ($ldapManager->authenticate($username, $password)) {\n    echo \"Success! The password for $username is correct.\";\n}  This method creates an authentication operation object and executes it against the current connection. You could also\ndo the following:  use LdapTools\\Operation\\AuthenticationOperation;\n\n$operation = (new AuthenticationOperation())->setUsername($username)->setPassword($password);\n\n// With your LdapManager class already instantiated...\n$response = $ldapManager->getConnection()->execute($operation);\n\nif (!$response->isAuthenticated()) {\n    echo \"Error validating password for '\".$operation->getUsername().\"': \".$response->getErrorMessage();\n}",
            "title": "Authenticating a User"
        },
        {
            "location": "/cookbook/Authenticating-a-User/#valid-username-formats",
            "text": "The  authenticate()  method username argument can be the same value types as the username you defined in your config. For\nActive Directory, this means you can authenticate a user using either a UPN, a text SID, a text GUID, a\ndistinguished name, or just a normal username. With OpenLDAP the username must be a full DN. However, you can adjust the bind_format  option for the domain configuration to modify this behavior.",
            "title": "Valid Username Formats"
        },
        {
            "location": "/cookbook/Authenticating-a-User/#authentication-error-messages",
            "text": "There are many times where you may want to provide a more meaningful response as to why authentication for a user has\nfailed. This information is possible to get by passing additional optional variables to the  authenticate()  method.  \n// With your LdapManager class already instantiated...\nif (!$ldapManager->authenticate($username, $password, $message, $code)) {\n     echo \"Error ($code): $message\";\n}  When using Active Directory, the above can give you very helpful information as to why the user cannot log in. Such as a\ndisabled account, a locked account, or an account whose password needs to change before they can login again. The most\ncommon error codes you may see in AD:     Error Number  Constant  Description      1317  ACCOUNT_INVALID  Account does not exist.    1326  ACCOUNT_CREDENTIALS_INVALID  Account password is invalid.    1327  ACCOUNT_RESTRICTIONS  Account Restrictions prevent this user from signing in.    1328  ACCOUNT_RESTRICTIONS_TIME  Time Restriction - The account cannot login at this time.    1329  ACCOUNT_RESTRICTIONS_DEVICE  Device Restriction - The account is not allowed to log on to this computer.    1330  ACCOUNT_PASSWORD_EXPIRED  The password for the account has expired.    1331  ACCOUNT_DISABLED  The account is currently disabled.    1384  ACCOUNT_CONTEXT_IDS  The account is a member of too many groups and cannot be logged on.    1793  ACCOUNT_EXPIRED  The account has expired.    1907  ACCOUNT_PASSWORD_MUST_CHANGE  The accounts password must change before it can login.    1909  ACCOUNT_LOCKED  The account is currently locked out.     All constants are located in  \\LdapTools\\Connection\\ADResponseCodes . You should use those constants to compare against \nthe received error number to take a specific action for an event.",
            "title": "Authentication Error Messages"
        },
        {
            "location": "/cookbook/Common-LDAP-Queries/",
            "text": "Common LDAP Queries\n\n\n\n\nThese LDAP queries all assume you are using an LdapManager instance (represented by \n$ldap\n) built from a configuration\ndescribed \nin the docs\n. This leverages the \nLdapQueryBuilder\n class which makes many\nof these queries very easy.\n\n\nAll Users, OUs, Groups, or Computers\n\n\n# All users\n$users = $ldap->buildLdapQuery()->fromUsers()->getLdapQuery()->getResult();\n\n# All groups\n$groups = $ldap->buildLdapQuery()->fromGroups()->getLdapQuery()->getResult();\n\n# All OUs\n$ous = $ldap->buildLdapQuery()->fromOUs()->getLdapQuery()->getResult();\n\n# All computers\n$computers = $ldap->buildLdapQuery()->fromComputers()->getLdapQuery()->getResult();\n\n# All contacts\n$contacts = $ldap->buildLdapQuery()->fromContacts()->getLdapQuery()->getResult();\n\n# All deleted objects (AD only)\n$deleted = $ldap->buildLdapQuery()->fromDeleted()->getLdapQuery()->getResult();\n\n\n\n\nUsers Created After a Certain Date\n\n\n$query = $ldap->buildLdapQuery();\n\n// The 'gte' filter creates a 'greater-than-or-equal-to' comparison\n$users = $query->fromUsers()\n    ->where($query->filter()->gte('created', new \\DateTime('2004-06-20')))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nGroups That Start With a Certain String\n\n\n$query = $ldap->buildLdapQuery();\n\n$groups = $query->fromGroups()\n    ->where($query->filter()->startsWith('name', 'Admin'))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nUser Accounts With a Description Containing a Certain String\n\n\n$query = $ldap->buildLdapQuery();\n\n$users = $query->fromUsers()\n    ->where($query->filter()->contains('description', 'service'))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\n\n\nActive Directory Specific Queries\n\n\nThe following are queries that are specific to Active Directory, as they use specific attributes or methods that are\nonly supported there.\n\n\nAll Groups a User Belongs to Recursively\n\n\n$query = $ldap->buildLdapQuery();\n\n// The $username can be a typical AD username, DN, GUID, or SID.\n$groups = $query->fromGroups()\n    ->where($query->filter()->hasMemberRecursively($username))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nAll Users that Belong to a Group Recursively\n\n\n$query = $ldap->buildLdapQuery();\n\n// The $group can be a typical AD group name, DN, GUID, or SID.\n$users = $query->fromUsers()\n    ->where($query->filter()->isRecursivelyMemberOf($group))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nAll Disabled User Accounts\n\n\n$users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['disabled' => true])\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nAll Locked User Accounts\n\n\n$users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['locked' => true])\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nAll Active User Accounts with Exchange Mailboxes\n\n\n$query = $ldap->buildLdapQuery();\n\n$users = $query->fromUsers()\n    ->where(['enabled' => true])\n    ->andWhere($query->filter()->mailEnabled())\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nAll Active User Accounts With Passwords That Must Change on Next Login\n\n\n$users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['enabled' => true, 'passwordMustChange' => true])\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nAll Security Enabled Groups With No Members\n\n\n$query = $ldap->buildLdapQuery();\n\n$groups = $query->fromGroups()\n    ->where(['typeSecurity' => true])\n    ->andWhere($query->filter()->notPresent('members'))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nUser Accounts With Passwords That Do Not Expire\n\n\n$users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['passwordNeverExpires' => true])\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nUser Accounts That Have Bad Password Attempts\n\n\n$query = $ldap->buildLdapQuery();\n\n$users = $query->fromUsers()\n    ->where($query->filter()->gte('badPasswordCount', 1))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nUser Accounts With Hidden Mailboxes Sorted By Last Name\n\n\n$users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['exchangeHideFromGAL' => true])\n    ->orderBy('lastName')\n    ->getLdapQuery()\n    ->getResult();",
            "title": "Common LDAP Queries"
        },
        {
            "location": "/cookbook/Common-LDAP-Queries/#common-ldap-queries",
            "text": "These LDAP queries all assume you are using an LdapManager instance (represented by  $ldap ) built from a configuration\ndescribed  in the docs . This leverages the  LdapQueryBuilder  class which makes many\nof these queries very easy.  All Users, OUs, Groups, or Computers  # All users\n$users = $ldap->buildLdapQuery()->fromUsers()->getLdapQuery()->getResult();\n\n# All groups\n$groups = $ldap->buildLdapQuery()->fromGroups()->getLdapQuery()->getResult();\n\n# All OUs\n$ous = $ldap->buildLdapQuery()->fromOUs()->getLdapQuery()->getResult();\n\n# All computers\n$computers = $ldap->buildLdapQuery()->fromComputers()->getLdapQuery()->getResult();\n\n# All contacts\n$contacts = $ldap->buildLdapQuery()->fromContacts()->getLdapQuery()->getResult();\n\n# All deleted objects (AD only)\n$deleted = $ldap->buildLdapQuery()->fromDeleted()->getLdapQuery()->getResult();  Users Created After a Certain Date  $query = $ldap->buildLdapQuery();\n\n// The 'gte' filter creates a 'greater-than-or-equal-to' comparison\n$users = $query->fromUsers()\n    ->where($query->filter()->gte('created', new \\DateTime('2004-06-20')))\n    ->getLdapQuery()\n    ->getResult();  Groups That Start With a Certain String  $query = $ldap->buildLdapQuery();\n\n$groups = $query->fromGroups()\n    ->where($query->filter()->startsWith('name', 'Admin'))\n    ->getLdapQuery()\n    ->getResult();  User Accounts With a Description Containing a Certain String  $query = $ldap->buildLdapQuery();\n\n$users = $query->fromUsers()\n    ->where($query->filter()->contains('description', 'service'))\n    ->getLdapQuery()\n    ->getResult();",
            "title": "Common LDAP Queries"
        },
        {
            "location": "/cookbook/Common-LDAP-Queries/#active-directory-specific-queries",
            "text": "The following are queries that are specific to Active Directory, as they use specific attributes or methods that are\nonly supported there.  All Groups a User Belongs to Recursively  $query = $ldap->buildLdapQuery();\n\n// The $username can be a typical AD username, DN, GUID, or SID.\n$groups = $query->fromGroups()\n    ->where($query->filter()->hasMemberRecursively($username))\n    ->getLdapQuery()\n    ->getResult();  All Users that Belong to a Group Recursively  $query = $ldap->buildLdapQuery();\n\n// The $group can be a typical AD group name, DN, GUID, or SID.\n$users = $query->fromUsers()\n    ->where($query->filter()->isRecursivelyMemberOf($group))\n    ->getLdapQuery()\n    ->getResult();  All Disabled User Accounts  $users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['disabled' => true])\n    ->getLdapQuery()\n    ->getResult();  All Locked User Accounts  $users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['locked' => true])\n    ->getLdapQuery()\n    ->getResult();  All Active User Accounts with Exchange Mailboxes  $query = $ldap->buildLdapQuery();\n\n$users = $query->fromUsers()\n    ->where(['enabled' => true])\n    ->andWhere($query->filter()->mailEnabled())\n    ->getLdapQuery()\n    ->getResult();  All Active User Accounts With Passwords That Must Change on Next Login  $users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['enabled' => true, 'passwordMustChange' => true])\n    ->getLdapQuery()\n    ->getResult();  All Security Enabled Groups With No Members  $query = $ldap->buildLdapQuery();\n\n$groups = $query->fromGroups()\n    ->where(['typeSecurity' => true])\n    ->andWhere($query->filter()->notPresent('members'))\n    ->getLdapQuery()\n    ->getResult();  User Accounts With Passwords That Do Not Expire  $users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['passwordNeverExpires' => true])\n    ->getLdapQuery()\n    ->getResult();  User Accounts That Have Bad Password Attempts  $query = $ldap->buildLdapQuery();\n\n$users = $query->fromUsers()\n    ->where($query->filter()->gte('badPasswordCount', 1))\n    ->getLdapQuery()\n    ->getResult();  User Accounts With Hidden Mailboxes Sorted By Last Name  $users = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['exchangeHideFromGAL' => true])\n    ->orderBy('lastName')\n    ->getLdapQuery()\n    ->getResult();",
            "title": "Active Directory Specific Queries"
        },
        {
            "location": "/cookbook/Creating-a-Custom-Repository/",
            "text": "Creating a Custom Repository\n\n\n\n\nA LDAP Object Repository gives a way to encapsulate and reuse common queries you may run against LDAP. So rather than\nrecoding the same query in several spots, you can code it once in the repository then use the repository method instead.\n\n\nYour custom repository class should extend the \n\\LdapTools\\Object\\LdapObjectRepository\n class. For instance, your class\ncould be something like:\n\n\nnamespace Acme\\Demo;\n\nuse LdapTools\\Object\\LdapObjectRepository;\n\nclass CustomUserRepository extends LdapObjectRepository\n{\n    public function getAllSmiths()\n    {\n        // You can use the buildLdapQuery() method to construct a LdapQueryBuilder instance.\n        return $this->buildLdapQuery()\n            ->where(['lastName' => 'Smith'])\n            ->getLdapQuery()\n            ->execute();\n    }\n}\n\n\n\n\nThen make sure to define your new repository in the the schema config as a directive underneath the \nuser\n object type:\n\n\n# If you just want a custom repository for the default user type, you could use a schema that extends the default...\n#\n# extends_default: ad\nobjects:\n    #...\n    user:\n        #...\n        repository: '\\Acme\\Demo\\CustomUserRepository'\n\n\n\n\nThen once you have your \nLdapManager\n class instantiated you can get your custom repository and use it:\n\n\n // Assuming you defined the custom repository under the 'user' object type.\n $repository = $ldapManager->getRepository('user');\n\n $smiths = $repository->getAllSmiths();",
            "title": "Creating a Custom Repository"
        },
        {
            "location": "/cookbook/Creating-a-Custom-Repository/#creating-a-custom-repository",
            "text": "A LDAP Object Repository gives a way to encapsulate and reuse common queries you may run against LDAP. So rather than\nrecoding the same query in several spots, you can code it once in the repository then use the repository method instead.  Your custom repository class should extend the  \\LdapTools\\Object\\LdapObjectRepository  class. For instance, your class\ncould be something like:  namespace Acme\\Demo;\n\nuse LdapTools\\Object\\LdapObjectRepository;\n\nclass CustomUserRepository extends LdapObjectRepository\n{\n    public function getAllSmiths()\n    {\n        // You can use the buildLdapQuery() method to construct a LdapQueryBuilder instance.\n        return $this->buildLdapQuery()\n            ->where(['lastName' => 'Smith'])\n            ->getLdapQuery()\n            ->execute();\n    }\n}  Then make sure to define your new repository in the the schema config as a directive underneath the  user  object type:  # If you just want a custom repository for the default user type, you could use a schema that extends the default...\n#\n# extends_default: ad\nobjects:\n    #...\n    user:\n        #...\n        repository: '\\Acme\\Demo\\CustomUserRepository'  Then once you have your  LdapManager  class instantiated you can get your custom repository and use it:   // Assuming you defined the custom repository under the 'user' object type.\n $repository = $ldapManager->getRepository('user');\n\n $smiths = $repository->getAllSmiths();",
            "title": "Creating a Custom Repository"
        },
        {
            "location": "/cookbook/Getting-Your-LDAP-SSL-Certificate/",
            "text": "Getting Your LDAP SSL Certificate\n\n\n\n\nSometimes trying to determine your LDAP SSL certificate can be a challenge if you're not completely aware of your environment\nand what servers are actually involved. To accomplish this in an easier way you can determine your LDAP SSL certificate\nin a programmatic way using a utility function in this library.\n\n\n1. Determine Your LDAP Servers\n\n\nIf you already know what LDAP servers are in your environment, then you can skip to the next step. However, if you\naren't sure of the names of your LDAP servers you can easily figure them out using the utility function below:\n\n\nuse LdapTools\\Utilities\\LdapUtilities;\n\n// Simply pass this function your domain name...\n$servers = LdapUtilities::getLdapServersForDomain('example.local');\n\nforeach ($servers as $server) {\n    echo $server.PHP_EOL;\n}\n\n\n\n\nNOTE\n: The above does require that you have DNS properly configured on the box you run PHP from. To determine the\nLDAP servers in the domain it needs to query DNS service records.\n\n\n2. Using a LDAP Server, Get the SSL Certificates\n\n\nUsing one of the servers from above, pass it to another utility function to retrieve the LDAP SSL certificates the server\nis using:\n\n\nuse LdapTools\\Utilities\\LdapUtilities;\n\n// This will retrieve an array containing the 'peer_certificate' and 'peer_certificate_chain'...\n$certificates = LdapUtilities::getLdapSslCertificates('dc1.example.local');\n\n// You can use the above to create a certificate bundle containing all your needed LDAP SSL certificates...\n$bundle = $certificates['peer_certificate'];\nforeach($certificates['peer_certificate_chain'] as $cert) {\n    $bundle .= $cert;\n}\n\n// You can now output the certificate bundle to a separate location...\nfile_put_contents('./ldap-ssl-bundle.crt', $bundle);\n\n\n\n\nNOTE\n: The above grabs the certificates using a StartTLS command and inspecting the SSL stream.\n\n\n3. Reference Your New SSL Cert Bundle in Your LDAP Config\n\n\nTo make use of the new bundles you need to use the \nTLS_CACERT\n directive in your ldap.conf file. You just need to point\nit to the location where you saved your certificate in step 3.\n\n\nTLS_REQCERT hard\nTLS_CACERT /path/to/ldap-ssl-bundle.crt\n\n\n\n\nIf you are using PHP 7.1 you can make use of the new constants to reference the certificate without needing the ldap.conf\nfile. The constants are \nLDAP_OPT_X_TLS_CACERTFILE\n and \nLDAP_OPT_X_TLS_REQUIRE_CERT\n:\n\n\nuse LdapTools\\DomainConfiguration;\n\n// Make sure to set your LDAP options for your Domain Configuration...\n$domain = (new DomainConfiguration('example.local'))\n    ->setBaseDn('dc=example,dc=local')\n    ->setServers(['dc1.example.local', 'dc2.example.local'])\n    ->setUsername('foo')\n    ->setPassword('secret')\n    ->setUseTls(true)\n    ->setLdapOptions([\n        'LDAP_OPT_X_TLS_CACERTFILE' => '/path/to/ldap-ssl-bundle',\n        'LDAP_OPT_X_TLS_REQUIRE_CERT' => LDAP_OPT_X_TLS_HARD,\n    ]);\n\n\n\n\n4. Troubleshooting\n\n\nIf you did all of the above and you still cannot connect when setting \nuse_tls\n to \ntrue\n then there are a few ways to go\nabout figuring out what is going wrong. \n\n\nIt's possible that your environment has an intermediate server that issues certificates along with an enterprises root \nCertificate Authority. In this case not all of the certificates needed for the certificate chain will be created in step 2.\nIn order to troubleshoot this you can view the full certificate chain by opening the resulting certificate file from step 2.\nIf there are 3 steps in the chain, then likely you are missing a certificate. The easiest way to get the missing\nintermediate certificate would probably be to open the certificate bundle on a windows machine in the domain in question\nand extract the intermediate certificate to a separate file (in base64 encoded format!). You can then copy the contents \nof that file into your bundle file from step 2.\n\n\nIt's also possible that OpenSSL has an issue with one of the certificates, perhaps due to a name or something else. To\nget more details on the issue you can set the debug level to 7 prior to trying to connect to LDAP. Simply put this at the\nbeginning of your code:\n\n\n\nldap_set_option(null, LDAP_OPT_DEBUG_LEVEL, 7);\n\n# ...\n\n\n\n\nNow when you connect you should get a more complete description of what exactly is failing.",
            "title": "Getting Your LDAP SSL Certificate"
        },
        {
            "location": "/cookbook/Getting-Your-LDAP-SSL-Certificate/#getting-your-ldap-ssl-certificate",
            "text": "Sometimes trying to determine your LDAP SSL certificate can be a challenge if you're not completely aware of your environment\nand what servers are actually involved. To accomplish this in an easier way you can determine your LDAP SSL certificate\nin a programmatic way using a utility function in this library.  1. Determine Your LDAP Servers  If you already know what LDAP servers are in your environment, then you can skip to the next step. However, if you\naren't sure of the names of your LDAP servers you can easily figure them out using the utility function below:  use LdapTools\\Utilities\\LdapUtilities;\n\n// Simply pass this function your domain name...\n$servers = LdapUtilities::getLdapServersForDomain('example.local');\n\nforeach ($servers as $server) {\n    echo $server.PHP_EOL;\n}  NOTE : The above does require that you have DNS properly configured on the box you run PHP from. To determine the\nLDAP servers in the domain it needs to query DNS service records.  2. Using a LDAP Server, Get the SSL Certificates  Using one of the servers from above, pass it to another utility function to retrieve the LDAP SSL certificates the server\nis using:  use LdapTools\\Utilities\\LdapUtilities;\n\n// This will retrieve an array containing the 'peer_certificate' and 'peer_certificate_chain'...\n$certificates = LdapUtilities::getLdapSslCertificates('dc1.example.local');\n\n// You can use the above to create a certificate bundle containing all your needed LDAP SSL certificates...\n$bundle = $certificates['peer_certificate'];\nforeach($certificates['peer_certificate_chain'] as $cert) {\n    $bundle .= $cert;\n}\n\n// You can now output the certificate bundle to a separate location...\nfile_put_contents('./ldap-ssl-bundle.crt', $bundle);  NOTE : The above grabs the certificates using a StartTLS command and inspecting the SSL stream.  3. Reference Your New SSL Cert Bundle in Your LDAP Config  To make use of the new bundles you need to use the  TLS_CACERT  directive in your ldap.conf file. You just need to point\nit to the location where you saved your certificate in step 3.  TLS_REQCERT hard\nTLS_CACERT /path/to/ldap-ssl-bundle.crt  If you are using PHP 7.1 you can make use of the new constants to reference the certificate without needing the ldap.conf\nfile. The constants are  LDAP_OPT_X_TLS_CACERTFILE  and  LDAP_OPT_X_TLS_REQUIRE_CERT :  use LdapTools\\DomainConfiguration;\n\n// Make sure to set your LDAP options for your Domain Configuration...\n$domain = (new DomainConfiguration('example.local'))\n    ->setBaseDn('dc=example,dc=local')\n    ->setServers(['dc1.example.local', 'dc2.example.local'])\n    ->setUsername('foo')\n    ->setPassword('secret')\n    ->setUseTls(true)\n    ->setLdapOptions([\n        'LDAP_OPT_X_TLS_CACERTFILE' => '/path/to/ldap-ssl-bundle',\n        'LDAP_OPT_X_TLS_REQUIRE_CERT' => LDAP_OPT_X_TLS_HARD,\n    ]);  4. Troubleshooting  If you did all of the above and you still cannot connect when setting  use_tls  to  true  then there are a few ways to go\nabout figuring out what is going wrong.   It's possible that your environment has an intermediate server that issues certificates along with an enterprises root \nCertificate Authority. In this case not all of the certificates needed for the certificate chain will be created in step 2.\nIn order to troubleshoot this you can view the full certificate chain by opening the resulting certificate file from step 2.\nIf there are 3 steps in the chain, then likely you are missing a certificate. The easiest way to get the missing\nintermediate certificate would probably be to open the certificate bundle on a windows machine in the domain in question\nand extract the intermediate certificate to a separate file (in base64 encoded format!). You can then copy the contents \nof that file into your bundle file from step 2.  It's also possible that OpenSSL has an issue with one of the certificates, perhaps due to a name or something else. To\nget more details on the issue you can set the debug level to 7 prior to trying to connect to LDAP. Simply put this at the\nbeginning of your code:  \nldap_set_option(null, LDAP_OPT_DEBUG_LEVEL, 7);\n\n# ...  Now when you connect you should get a more complete description of what exactly is failing.",
            "title": "Getting Your LDAP SSL Certificate"
        },
        {
            "location": "/cookbook/Modifying-GPO-Links-on-OUs/",
            "text": "Modifying GPO Links on OUs\n\n\n\n\nWhen working with Active Directory OUs you may want to add, remove, or display GPOs that are linked to them. This can be\naccomplished through the use of the \ngpoLinks\n attribute for the OU type. This attribute can be leveraged on OU creation\nor modification to easily set what GPOs should be linked at that OU level. The attribute value functions as an array of \n\n\\LdapTools\\Utilities\\GPOLink\n objects that full describe the GPO that is linked, and whether or not the GPO is enforced\nand/or enabled. The order of the array of \nGPOLink\n objects returned represents the link order in AD starting from order\n1 onwards.\n\n\nCreating an OU With a Linked GPO\n\n\nFor example, assume you would like to create an OU named \"Employees\" that should have 2 GPOs linked to it named \n\"Employee Policy\" and \"Require Screensaver\":\n\n\nuse LdapTools\\Utilities\\GPOLink;\n\n$ldapObject = $ldap->createLdapObject();\n\ntry {\n    $ldapObject->createOU()\n        ->in('dc=example,dc=local')\n        ->with(['name' => 'Employees', 'gpoLinks' => [\n            new GPOLink('Employee Policy'), \n            new GPOLink('Require Screensaver')\n         ]])\n        ->execute();\n} catch (LdapConnectionException $e) {\n    echo \"Failed to create OU - \".$e->getMessage();\n}\n\n\n\n\nModifying GPOs on an Existing OU\n\n\nAssume you have an existing OU and would like to remove or add a GPO link from it:\n\n\nuse LdapTools\\Object\\LdapObjectType;\nuse LdapTools\\Utilities\\GPOLink;\n\n//...\n\n$repository = $ldap->getRepository(LdapObjectType::OU);\n\n// gpoLinks are not retrieved by default, so make sure to select them.\n$repository->setAttributes(['name', 'gpoLinks']);\n$ou = $repository->findOneByName('My Special OU');\n\n// Check for, and then remove, the name of an existing GPO if it is linked...\nforeach ($ou->getGpoLinks() as $gpoLink) {\n    if ($gpoLink->getGpo()->getName() == 'Require Screensaver') {\n        $ou->removeGpoLinks($gpoLink);\n    }\n}\n\n// Add a new GPO link to the OU that is set to be enforced...\n$link = (new GPOLink('Restricted Access'))->setIsEnforced(true);\n$ou->addGpoLinks($link);\n\n// Now actually save the changes back to LDAP\ntry {\n    $ldap->persist($ou);\n} catch (LdapConnectionException $e) {\n    echo \"Failed to modify OU - \".$e->getMessage();\n}\n\n\n\n\nSearching for OUs with Specific GPO Links\n\n\nYou can also use GPOLink objects in queries to check if a link exists on an OU. You can even get as granular as setting\nwhether the GPOLink is enforced/enabled or not.\n\n\nuse LdapTools\\Utilities\\GPOLink;\n\n$query = $ldap->buildLdapQuery()->fromOU();\n\n// Find OUs with a link for a GPO named \"Some GPO\"...\n$result = $query->select('name')\n    ->where($query->filter()->contains('gpoLinks', new GPOLink('Some GPO')))\n    ->getLdapQuery()\n    ->getResult();\n\nforeach ($result as $ou) {\n    echo \"OU: \".$ou->name;\n}\n\n\n\n\nUsing GPOLink Objects\n\n\nThe \n\\LdapTools\\Utilities\\GPOLink\n class is used to represent a GPO linked to an OU. It has several helper methods for \ngetting all of the details regarding the link.\n\n\nA GPOLink can be constructed use a name, GUID, DN, or LdapObject:\n\n\nuse LdapTools\\Utilities\\GPOLink;\n\n// Create a link for a GPO named \"Server Baseline\"...\n$link1 = new GPOLink('Server Baseline\");\n\n// Create a link for a specific string GUID that represents a GPO...\n$link2 = new GPOLink('968c00d8-f755-4e34-b7e6-586fd60ff5de');\n\n// Query for a GPO then create the link based off the result...\n$gpo = $ldap->buildLdapQuery()->where([\n        'objectClass' => 'groupPolicyContainer',\n        'displayName' => 'Server Exceptions',\n    ])\n    ->getLdapQuery()\n    ->getSingleResult();\n$link3 = new GPOLink($gpo);\n\n// Set the second link to be disabled...\n$link2->setIsEnabled(false);\n\n// Set the first link to be enforced...\n$link1->setIsEnforced(true);\n\n// Query for an OU to apply the GPO links to...\n$ou = $ldap->buildLdapQuery()->fromOU()->where(['name' => 'Servers'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// The order in which you add the links is the order they end up in for processing...\n$ou->set('gpoLinks', $link1, link2, $link3);\n$ldap->persist($ou);\n\n\n\n\nWhen searching for OUs you can inspect their GPO links to determine information about them:\n\n\n// Query for the GPO links for an OU...\n$ou = $ldap->buildLdapQuery()\n    ->fromOU()\n    ->select('gpoLinks')\n    ->where(['name' => 'Servers'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\nforeach ($ou->get('gpoLinks') as $gpoLink) {\n    // The GPO will be the LdapObject representation of the linked GPO... \n    $gpo = $gpoLink->getGpo();\n\n    echo \"GPO Name: \".$gpo->get('name');\n    echo \"GPO GUID: \".$gpo->get('guid');\n    echo \"GPO DN: \".$gpo->get('dn');\n\n    // You can check specifically if the link is being enforced...\n    if ($gpoLink->getIsEnforced()) {\n        echo \"The link \".$gpo->get('name').\" is being enforced.\";\n    }\n\n    // You can check specifically if the link is actually enabled/disabled...\n    if (!$gpoLink->getIsEnabled()) {\n        echo \"The link \".$gpo->get('name').\" is currently disabled.\";\n    }\n}\n\n\n\n\nIn the above example, if during the loop you want to modify any of the GPOLink objects you should set all of the GPO\nlinks back to the OU and then persist it back to LDAP:\n\n\n// Query for the GPO links for an OU...\n$ou = $ldap->buildLdapQuery()\n    ->fromOU()\n    ->select('gpoLinks')\n    ->where(['name' => 'Servers'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Lets enable any disabled links...\nforeach ($ou->get('gpoLinks') as $gpoLink) {\n    if (!$gpoLink->getIsEnabled()) {\n        $gpoLink->setIsEnabled(true);\n    }\n}\n\n// Replace the existing ones with the changes...\n$ou->set('gpoLinks', $ou->get('gpoLinks'));\n$ldap->persist($ou);",
            "title": "Modifying GPO Links on OUs"
        },
        {
            "location": "/cookbook/Modifying-GPO-Links-on-OUs/#modifying-gpo-links-on-ous",
            "text": "When working with Active Directory OUs you may want to add, remove, or display GPOs that are linked to them. This can be\naccomplished through the use of the  gpoLinks  attribute for the OU type. This attribute can be leveraged on OU creation\nor modification to easily set what GPOs should be linked at that OU level. The attribute value functions as an array of  \\LdapTools\\Utilities\\GPOLink  objects that full describe the GPO that is linked, and whether or not the GPO is enforced\nand/or enabled. The order of the array of  GPOLink  objects returned represents the link order in AD starting from order\n1 onwards.",
            "title": "Modifying GPO Links on OUs"
        },
        {
            "location": "/cookbook/Modifying-GPO-Links-on-OUs/#creating-an-ou-with-a-linked-gpo",
            "text": "For example, assume you would like to create an OU named \"Employees\" that should have 2 GPOs linked to it named \n\"Employee Policy\" and \"Require Screensaver\":  use LdapTools\\Utilities\\GPOLink;\n\n$ldapObject = $ldap->createLdapObject();\n\ntry {\n    $ldapObject->createOU()\n        ->in('dc=example,dc=local')\n        ->with(['name' => 'Employees', 'gpoLinks' => [\n            new GPOLink('Employee Policy'), \n            new GPOLink('Require Screensaver')\n         ]])\n        ->execute();\n} catch (LdapConnectionException $e) {\n    echo \"Failed to create OU - \".$e->getMessage();\n}",
            "title": "Creating an OU With a Linked GPO"
        },
        {
            "location": "/cookbook/Modifying-GPO-Links-on-OUs/#modifying-gpos-on-an-existing-ou",
            "text": "Assume you have an existing OU and would like to remove or add a GPO link from it:  use LdapTools\\Object\\LdapObjectType;\nuse LdapTools\\Utilities\\GPOLink;\n\n//...\n\n$repository = $ldap->getRepository(LdapObjectType::OU);\n\n// gpoLinks are not retrieved by default, so make sure to select them.\n$repository->setAttributes(['name', 'gpoLinks']);\n$ou = $repository->findOneByName('My Special OU');\n\n// Check for, and then remove, the name of an existing GPO if it is linked...\nforeach ($ou->getGpoLinks() as $gpoLink) {\n    if ($gpoLink->getGpo()->getName() == 'Require Screensaver') {\n        $ou->removeGpoLinks($gpoLink);\n    }\n}\n\n// Add a new GPO link to the OU that is set to be enforced...\n$link = (new GPOLink('Restricted Access'))->setIsEnforced(true);\n$ou->addGpoLinks($link);\n\n// Now actually save the changes back to LDAP\ntry {\n    $ldap->persist($ou);\n} catch (LdapConnectionException $e) {\n    echo \"Failed to modify OU - \".$e->getMessage();\n}",
            "title": "Modifying GPOs on an Existing OU"
        },
        {
            "location": "/cookbook/Modifying-GPO-Links-on-OUs/#searching-for-ous-with-specific-gpo-links",
            "text": "You can also use GPOLink objects in queries to check if a link exists on an OU. You can even get as granular as setting\nwhether the GPOLink is enforced/enabled or not.  use LdapTools\\Utilities\\GPOLink;\n\n$query = $ldap->buildLdapQuery()->fromOU();\n\n// Find OUs with a link for a GPO named \"Some GPO\"...\n$result = $query->select('name')\n    ->where($query->filter()->contains('gpoLinks', new GPOLink('Some GPO')))\n    ->getLdapQuery()\n    ->getResult();\n\nforeach ($result as $ou) {\n    echo \"OU: \".$ou->name;\n}",
            "title": "Searching for OUs with Specific GPO Links"
        },
        {
            "location": "/cookbook/Modifying-GPO-Links-on-OUs/#using-gpolink-objects",
            "text": "The  \\LdapTools\\Utilities\\GPOLink  class is used to represent a GPO linked to an OU. It has several helper methods for \ngetting all of the details regarding the link.  A GPOLink can be constructed use a name, GUID, DN, or LdapObject:  use LdapTools\\Utilities\\GPOLink;\n\n// Create a link for a GPO named \"Server Baseline\"...\n$link1 = new GPOLink('Server Baseline\");\n\n// Create a link for a specific string GUID that represents a GPO...\n$link2 = new GPOLink('968c00d8-f755-4e34-b7e6-586fd60ff5de');\n\n// Query for a GPO then create the link based off the result...\n$gpo = $ldap->buildLdapQuery()->where([\n        'objectClass' => 'groupPolicyContainer',\n        'displayName' => 'Server Exceptions',\n    ])\n    ->getLdapQuery()\n    ->getSingleResult();\n$link3 = new GPOLink($gpo);\n\n// Set the second link to be disabled...\n$link2->setIsEnabled(false);\n\n// Set the first link to be enforced...\n$link1->setIsEnforced(true);\n\n// Query for an OU to apply the GPO links to...\n$ou = $ldap->buildLdapQuery()->fromOU()->where(['name' => 'Servers'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// The order in which you add the links is the order they end up in for processing...\n$ou->set('gpoLinks', $link1, link2, $link3);\n$ldap->persist($ou);  When searching for OUs you can inspect their GPO links to determine information about them:  // Query for the GPO links for an OU...\n$ou = $ldap->buildLdapQuery()\n    ->fromOU()\n    ->select('gpoLinks')\n    ->where(['name' => 'Servers'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\nforeach ($ou->get('gpoLinks') as $gpoLink) {\n    // The GPO will be the LdapObject representation of the linked GPO... \n    $gpo = $gpoLink->getGpo();\n\n    echo \"GPO Name: \".$gpo->get('name');\n    echo \"GPO GUID: \".$gpo->get('guid');\n    echo \"GPO DN: \".$gpo->get('dn');\n\n    // You can check specifically if the link is being enforced...\n    if ($gpoLink->getIsEnforced()) {\n        echo \"The link \".$gpo->get('name').\" is being enforced.\";\n    }\n\n    // You can check specifically if the link is actually enabled/disabled...\n    if (!$gpoLink->getIsEnabled()) {\n        echo \"The link \".$gpo->get('name').\" is currently disabled.\";\n    }\n}  In the above example, if during the loop you want to modify any of the GPOLink objects you should set all of the GPO\nlinks back to the OU and then persist it back to LDAP:  // Query for the GPO links for an OU...\n$ou = $ldap->buildLdapQuery()\n    ->fromOU()\n    ->select('gpoLinks')\n    ->where(['name' => 'Servers'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Lets enable any disabled links...\nforeach ($ou->get('gpoLinks') as $gpoLink) {\n    if (!$gpoLink->getIsEnabled()) {\n        $gpoLink->setIsEnabled(true);\n    }\n}\n\n// Replace the existing ones with the changes...\n$ou->set('gpoLinks', $ou->get('gpoLinks'));\n$ldap->persist($ou);",
            "title": "Using GPOLink Objects"
        },
        {
            "location": "/tutorials/AD-Permissions/",
            "text": "Active Directory Permissions\n\n\n\n\n\n\nQuerying and Viewing Permissions\n\n\nModifying Existing Permissions\n\n\nSecurity Descriptor Methods\n\n\nDACL and SACL Methods\n\n\nACE Methods\n\n\nParsing SDDL\n\n\n\n\nActive Directory permissions are stored in each object in the directory in an attribute called \nntSecurityDescriptor\n.\nThe format of that value is a binary blob. However, if you decode that value it reveals all the Access Control Entries\n(ACEs) that make up the Discretionary Access Control List (DACL).\n\n\nThis library provides several helper classes for parsing all of the ACEs assigned to an LDAP object. Not only do you\nhave the ability to view all of the ACEs, but you can also add/remove/modify ACEs and send the changes back to LDAP to \nchange AD permissions for an object.\n\n\nQuerying and Viewing Permissions\n\n\nWhen you query for permissions there are a few rules to keep in mind:\n\n\n\n\nYou must send a LDAP control with the SD Flags value to retrieve permissions as a non-admin account.\n\n\nWhen you query for permissions you need to disable paging, otherwise it will not return any results.\n\n\n\n\nSo to query and retrieve the permissions for a specific account, do something like the following:\n\n\nuse LdapTools\\Connection\\LdapControl;\nuse LdapTools\\Connection\\LdapControlType;\nuse LdapTools\\Security\\SecurityDescriptor;\nuse LdapTools\\Security\\Ace\\AceRights;\nuse LdapTools\\Security\\SID;\n\n// ...\n\n// This tells the DC that when we request/process the 'ntSecurityDescriptor' we will exclude the SACL.\n// Without this the attribute will not be returned from AD (unless you're using a domain admin account)\n$sdControl = new LdapControl(LdapControlType::SD_FLAGS_CONTROL, true, LdapControl::berEncodeInt(7));\n$ldap->getConnection()->setControl($sdControl);\n\n$user = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['username' => 'SomeUser'])\n    // The ntSecurityDescriptor is what describes permissions against that object...\n    ->select('ntSecurityDescriptor')\n    // Paging must be set to false, otherwise it interfers with the SD Flags control we set...\n    ->setUsePaging(false)\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Instantiate a new Security Descriptor class that decodes and represents all of the AD permissions...\n$sd = new SecurityDescriptor($user->get('ntSecurityDescriptor'));\n\n// The DACL is what contains all of your ACEs, so loop through it.\n// We will check specifically if this user cannot change their own password.\nforeach ($sd->getDacl()->getAces() as $ace) {\n   // Ignore any ACEs that allow access\n   if ($ace->isAllowAce()) {\n       continue;\n   }\n   // This will check if the user is setup so they cannot change their own password...\n   if ((string) $ace->getSid() === SID::SHORT_NAME['PS'] && (string) $ace->getObjectType() === AceRights::EXTENDED['CHANGE_PASSWORD']) {\n       echo \"User cannot change their password.\".PHP_EOL;\n   }\n}\n\n\n\n\nModifying Existing Permissions\n\n\nWorking off the same example as above, after you determined that a user is set so they cannot change their password,\nyou can switch it back so they can by removing one ACE and flipping the type of another. The following will assume you\nare already working with the Security Descriptor object queried above:\n\n\n// The DACL is what contains all of your ACEs, so loop through it\n// We will check specifically if this user cannot change their own password\nforeach ($sd->getDacl()->getAces() as $ace) {\n   // Ignore any ACEs that allow access\n   if ($ace->isAllowAce()) {\n       continue;\n   }\n   // This will get the ACE that applies to the user themselves ('PS' is the SID short name for 'Principal Self')\n   if ((string) $ace->getSid() === SID::SHORT_NAME['PS'] && (string) $ace->getObjectType() === AceRights::EXTENDED['CHANGE_PASSWORD']) {\n       $sd->getDacl()->removeAce($ace);\n   }\n   // This flips the ACE type to allow for the 'WD' SID ('WD' is the SID short name for \"Everyone\").\n   if ((string) $ace->getSid() === SID::SHORT_NAME['WD'] && (string) $ace->getObjectType() === AceRights::EXTENDED['CHANGE_PASSWORD']) {\n       $ace->setType(new AceType('A'));\n   }\n}\n\n// Now set the new Security Descriptor value and send it back to LDAP...\n$user->set('ntSecurityDescriptor', $sd->toBinary());\n$ldap->persist($user);\n\n\n\n\n\nSecurity Descriptor Methods\n\n\nThe Security Descriptor object is what represents the complete permissions for an LDAP object. It contains the SACL,\nDACL, owner, and group. It can be instantiated with its binary representation, or with nothing then explicitly use the\nmethods below to describe it.\n\n\n\n\ngetDacl()\n\n\nGet the Discretionary Access Control List for the Security Descriptor. This is what contains all of the permission ACEs\nassigned to the LDAP object.\n\n\n$aces = $sd->getDacl()->getAces();\n\n\n\n\n\n\nsetDacl(Dacl $dacl = null)\n\n\nSet the Discretionary Access Control List for the security Descriptor. This must be the DACL object.\n\n\nuse LdapTools\\Security\\Acl\\Dacl;\n\n$sd->setDacl(new Dacl());\n\n\n\n\n\n\ngetSacl()\n\n\nGet the System Access Control List for the Security Descriptor. This contains System Audit entries, not permissions. The\nobjects are still ACEs, but they relate to what specific access rights get audited.\n\n\n$aces = $sd->getSacl()->getAces();\n\n\n\n\n\n\nsetSacl(Sacl $sacl = null)\n\n\nSet the System Access Control List for the Security Descriptor. This must be the SACL object.\n\n\nuse LdapTools\\Security\\Acl\\Sacl;\n\n$sd->setSacl(new Sacl());\n\n\n\n\n\n\ngetOwner()\n\n\nThis returns the owner of the Security Descriptor as a SID object.\n\n\necho $sd->getOwner()->toString();\n\n\n\n\n\n\nsetOwner($owner)\n\n\nSet the owner of the Security Descriptor. This can be a SID object or a string SID/SID short name.\n\n\nuse LdapTools\\Security\\SID;\n\n// The SID can be constructed with a SID string, or a SID short name...\n$sd->setOwner(SID::SHORT_NAME['BA']);\n\n\n\n\n\n\ngetGroup()\n\n\nGet the primary group of the owner of the Security Descriptor. This will be a SID object.\n\n\necho $sd->getGroup()->toString();\n\n\n\n\n\n\nsetGroup($group)\n\n\nSet the primary group of the Security Descriptor. This can be a SID object or a string SID/SID short name.\n\n\n// The SID can be constructed with a SID string, or a SID short name...\n$sd->setGroup('S-1-5-21-1263317781-1938881490-3107577794-512');\n\n\n\n\n\n\ntoBinary($canonical = true)\n\n\nGet the binary representation of the Security Descriptor. This is the format it must be in when being sent back via LDAP.\nYou can optionally pass \nfalse\n as a parameter if you're sending a non-canonical set of ACEs to LDAP. Typically you do\nnot want to do that.\n\n\n$binary = $sd->toBinary();\n\n\n\n\n\n\ntoSddl($canonical = true)\n\n\nGet the Security Descriptor Definition Language (SDDL) string representation of the object. You can optionally pass \n\nfalse\n as a parameter if you want the ACEs represent in a non-canonical form. Typically you do not want to do that.\n\n\necho $sd->toSddl();\n\n\n\n\n\n\ngetControlFlags()\n\n\nGet the Control Flags for the Security Descriptor. This returns a flags object.\n\n\nuse LdapTools\\Security\\ControlFlags;\n\n$flags = $sd->getControlFlags();\n\nif ($flags->has(ControlFlags::FLAG['SACL_PRESENT']) {\n   // ...\n}\n\n\n\n\n\n\nsetControlFlags(ControlFlags $flags)\n\n\nSet the control flags for the Security Descriptor. This must be a ControlFlags object.\n\n\nuse LdapTools\\Security\\ControlFlags;\n\n$sd->setControlFlags(new ControlFlags(ControlFlags::FLAGS['SELF_RELATIVE']);\n\n\n\n\nDACL and SACL Methods\n\n\nThe DACL and SACL both contain a set of ACEs. The DACL is what contains all of the permission ACEs. The SACL contains\nall of the System ACEs used for auditing purposes. However, they both contain the same basic methods, with only a few\nexceptions.\n\n\n\n\ngetAces()\n\n\nGet all of the ACEs assigned to the ACL as an array of ACE objects.\n\n\n// Loop through each ACE and print out the SDDL representation of it...\nforeach ($sd->getDacl()->getAces() as $ace) {\n    echo $ace->toSddl();\n}\n\n\n\n\n\n\nsetAces(Ace ...$aces)\n\n\nSet the ACEs for the ACL. This overwrites any ACEs that might be set on the ACL already.\n\n\n// Set some valid access obviously (not these...)\n$aces = [\n    (new Ace('D')->setTrustee('BA'),\n    (new Ace('A')->setTrustee('PS'),\n]\n\n$sd->getDacl()->setAces(...$aces);\n\n\n\n\n\n\nhasAce(Ace ...$aces)\n\n\nCheck if an ACE (or several ACEs) exists on the ACL. The check is strict, so the ACE needs to be the same object to return true.\n\n\n\n\nremoveAce(Ace ...$aces)\n\n\nRemove an ACE (or several ACEs) from the ACL. The ACE must be the same object already assigned to the ACL.\n\n\nforeach ($sd->getDacl()->getAces() as $ace) {\n    // Perform some logic to check if the ACE should be removed...\n    // ...\n    $sd->getDacl()->removeAce($ace);\n}\n\n\n\n\n\n\naddAce(Ace ...$aces)\n\n\nAdd an ACE (or several ACEs) to the ACL. You do not have to worry about the the ACE order in the ACL when adding it.\nWhen the ACL is converted to binary/SDDL form it is canonicalized to be in the correct order.\n\n\nuse LdapTools\\Security\\Ace\\Ace;\nuse LdapTools\\Security\\Ace\\AceRights;\n\n// OA is short for an object allow ace type...\n$ace = (new Ace('OA'))\n    // The SID of the user being granted the right...\n    ->setTrustee('S-1-5-21-1263317781-1938881490-3107577794-1020')\n    // This is an extended access right allowing the trustee to reset a password...\n    ->setObjectType(AceRights::EXTENDED['RESET_PASSWORD'])\n    // This sets the ACE with the Access Control right...\n    ->setRights(new AceRights(AceRights::FLAGS['DS_CONTROL_ACCESS']));\n\n// Add the ACE to the DACL...\n$sd->getDacl()->addAce($ace);\n\n\n\n\n\n\ntoSddl($canonicalize = true)\n\n\nThis will return a SDDL string that represents all ACEs within the ACL. You can optionally pass a bool to indicate\nwhether or not the ACEs should be canonicalized or not (by default they are).\n\n\necho $sd->getDacl()->toSddl();\n\n\n\n\n\n\ntoBinary($canonicalize = true)\n\n\nThis will return the binary form of the ACL. This is not very useful by itself outside the context of the binary Security\nDescriptor overall. You can optionally pass a bool to indicate whether or not the ACEs should be canonicalized or not\n(by default they are).\n\n\n\n\nisCanonical()\n\n\nThis method is only valid for the DACL. It returns a bool value for whether or not all of the ACEs in the ACL are in \ncanonical form. If you want to see if the ACEs are in canonical for coming from AD then you should call this immediately\nafter instantiating the Security Descriptor.\n\n\nif (!$sd->getDacl()->isCanonical()) {\n    echo \"Warning! The DACL is not in canonical form. Be careful when editing...\";\n}\n\n\n\n\n\n\ncanonicalize()\n\n\nCalling this method forces all ACEs in the ACL into canonical form. This is the order that AD expects the ACEs to be in\nwhen saving it back via LDAP. The ACLs are canonicalized automatically when being converted to binary/SDDL, so you do\nnot have to call this each time you make a modification.\n\n\nAce Methods\n\n\nThe Access Control Entry (ACE) represents a specific permission assigned to an ACL. This can represent whether a specific\nuser (The \"Trustee\" as it is referred to on an ACE) is allowed or denied read/write access to a specific Active Directory\nproperty object, or event if they are allowed or denied rights for specific actions, such as resetting a password or being\nable to have send-as rights on a user's mailbox in Exchange.\n\n\nThere are several helper/convenience methods available to make it easier to decipher and parse the ACEs assigned to an\nobject so you can take the action you need.\n\n\n\n\ngetType()\n\n\nThe ACE type represents if this is an access allowed or access denied type, and whether the ACE relates to an object type\nor not. \n\n\n// Show the SDDL short name of the ACE type...\necho $ace->getType()->getShortName();\n\n\n\n\n\n\nsetType(AceType $type)\n\n\nWhen setting the ACE type explicitly you need to use the AceType object. The ACE type can be one of several types and \ncan be defined by its SDDL short name or one of the constants available on the \nLdapTools\\Security\\Ace\\AceType\n class.\nAvailable types defined on the AceType class include:\n\n\n    const TYPE = [\n        'ACCESS_ALLOWED' => 0x00,\n        'ACCESS_DENIED' => 0x01,\n        'SYSTEM_AUDIT' => 0x02,\n        'SYSTEM_ALARM' => 0x03,\n        'ACCESS_ALLOWED_COMPOUND' => 0x04,\n        'ACCESS_ALLOWED_OBJECT' => 0x05,\n        'ACCESS_DENIED_OBJECT' => 0x06,\n        'SYSTEM_AUDIT_OBJECT' => 0x07,\n        'SYSTEM_ALARM_OBJECT' => 0x08,\n        'ACCESS_ALLOWED_CALLBACK' => 0x09,\n        'ACCESS_DENIED_CALLBACK' => 0x0A,\n        'ACCESS_ALLOWED_CALLBACK_OBJECT' => 0x0B,\n        'ACCESS_DENIED_CALLBACK_OBJECT' => 0x0C,\n        'SYSTEM_AUDIT_CALLBACK' => 0x0D,\n        'SYSTEM_ALARM_CALLBACK' => 0x0E,\n        'SYSTEM_AUDIT_CALLBACK_OBJECT' => 0x0F,\n        'SYSTEM_ALARM_CALLBACK_OBJECT' => 0x10,\n        'SYSTEM_MANDATORY_LABEL' => 0x11,\n        'SYSTEM_RESOURCE_ATTRIBUTE' => 0x12,\n        'SYSTEM_SCOPED_POLICY_ID' => 0x13,\n    ];\n\n\n\n\nOnly \nACCESS_*\n ACEs can be added to a DACL. And only \nSYSTEM_*\n ACEs can be added to a SACL.\n\n\nuse LdapTools\\Ace\\Ace;\nuse LdapTools\\Ace\\AceType;\n\n// You can instantiate an ACE using its AceType SDDL short name...\n$ace = new Ace('A');\n\n// Set the AceType by object, flipping it to a deny...\n$ace->setType(new AceType('D'));\n\n\n\n\n\n\ngetTrustee()\n\n\nGet SID object of the trustee for the ACE.\n\n\n// Print the trustee SID as a string...\necho $ace->getTrustee()->toString();\n\n\n\n\n\n\nsetTrustee($sid)\n\n\nSet the SID of the trustee for this ACE. This can be either a SID object, a string SID, or a SID short name.\n\n\n// Set the trustee SID by short name...\n$ace->setTrustee('PS');\n\n// Set the trustee SID by using a string SID...\n$ace->setTrustee('S-1-5-21-1263317781-1938881490-3107577794-512');\n\n\n\n\n\n\ngetObjectType()\n\n\nGet the GUID object type this ACE controls access for if this is an object type ACE (otherwise this will be null). This GUID\ncan represent a specific AD property, or some type of extended access right for the ACE.\n\n\nif ($ace->getObjectType()) {\n    echo $ace->getObjectType()->toString();\n}\n\n\n\n\n\n\nsetObjectType($guid)\n\n\nSet the GUID object type this ACE controls access for. When you set this it will automatically toggle the AceObjectFlags\nas needed. You can pass either a GUID object or a GUID string as a parameter.\n\n\nuse LdapTools\\Security\\GUID;\nuse LdapTools\\Security\\Ace\\AceRights;\n\n// Set by the GUID object...\n$ace->setObjectType(new GUID('bf967950-0de6-11d0-a285-00aa003049e2'));\n\n// Set by a string GUID from a constant...\n$ace->setObjectType(AceRights::EXTENDED['RESET_PASSWORD']);\n\n\n\n\n\n\ngetInheritedObjectType()\n\n\nGet the GUID object type that represents the type of child objects that can inherit the ACE. This returns the same type\nof value as the \ngetObjectType()\n method. See above.\n\n\n\n\nsetInheritedObjectType($guid)\n\n\nSet the GUID object type that represents the type of child objects that can inherit the ACE. This allows the same type\nof values as the \nsetInheritedObjectType()\n method. See above.\n\n\n\n\ngetRights()\n\n\nReturns an AceRights object that has several helper methods for checking/settting what rights are assigned to this ACE:\n\n\n// Get the AceRights object...\n$rights = $ace->getRights();\n\n// The below functions can either check for access, or set access (pass a bool true or false to toggle)...\n\n/**\n * Check or set the ability to read a specific property.\n */\n$rights->readProperty($action = null);\n\n/**\n * Check or set the ability to write a specific property.\n */\n$rights->writeProperty($action = null);\n\n/**\n * Check or set the ability to create child objects.\n */\n$rights->createChildObject($action = null);\n\n/**\n * Check or set the ability to delete child objects.\n */\n$rights->deleteChildObject($action = null);\n\n/**\n * Check or set the ability to list child objects.\n */\n$rights->listChildObject($action = null);\n\n/**\n * Check or set the ability to delete objects of a certain type (all if objectType on the ACE is empty).\n */\n$rights->deleteObject($action = null);\n\n/**\n * Check or set the ability to list objects of a specific type.\n */\n$rights->listObject($action = null);\n\n/**\n * Check or set the ability to perform a validated write for a property.\n */\n$rights->validatedWrite($action = null);\n\n/**\n * Check or set control access rights. These control specific actions/operations on an object or attribute.\n */\n$rights->controlAccess($action = null);\n\n/**\n * Check or set the ability to read data from the security descriptor (minus the SACL).\n */\n$rights->readSecurity($action = null);\n\n/**\n * Check or set the ability to access the SACL of an object.\n */\n$rights->accessSacl($action = null);\n\n/**\n * Check or set the ability to write the DACL of an object.\n */\n$rights->writeDacl($action = null);\n\n/**\n * Check or set the ability to assume ownership of the object. The user must be an object trustee. The user cannot\n * transfer the ownership to other users.\n */\n$rights->writeOwner($action = null);\n\n/**\n * Check or set the ability to read permissions on this object, read all the properties on this object, list this\n * object name when the parent container is listed, and list the contents of this object if it is a container.\n */\n$rights->readAll($action = null);\n\n/**\n * Check or set the ability to read permissions on this object, write all the properties on this object, and perform\n * all validated writes to this object.\n */\n$rights->writeAll($action = null);\n\n/**\n * Check or set the ability to read permissions on, and list the contents of, a container object.\n */\n$rights->execute($action = null);\n\n/**\n * Check or set the ability to create or delete child objects, delete a subtree, read and write properties, examine\n * child objects and the object itself, add and remove the object from the directory, and read or write with an\n * extended right.\n */\n$rights->fullControl($action = null);\n\n/**\n * Check or set the ability to use the object for synchronization. This enables a thread to wait until the\n * object is in the signaled state.\n */\n$rights->synchronize($action = null);\n\n\n\n\n\n\nsetRights(AceRights $rights)\n\n\nSet a specific AceRights to the ACE.\n\n\nuse LdapTools\\Security\\Ace\\AceRights;\n\n$rights = new AceRights(AceRights::SHORT_NAME['CR']);\n$ace->setRights($rights);\n\n\n\n\n\n\ngetFlags()\n\n\nGets an AceFlags object that represents all of the flags set for the ACE. This has several helper methods for extracting\nuseful information about the ACE:\n\n\n// Get the AceFlags object...\n$flags = $ace->getFlags();\n\n// The below functions can either check for a specific flag, or toggle it on/off with a bool true or false...\n\n/**\n * Check or set whether the ACE does not control access to the object to which it is attached. When this is true,\n * the ACE only controls access on those objects which inherit it.\n */\n$flags->inheritOnly($action = null);\n\n/**\n * Check or set whether inheritance of this ACE should be propagated.\n */\n$flags->propagateInheritance($action = null);\n\n/**\n * Check or set whether containers should inherit this ACE.\n */\n$flags->containerInherit($action = null);\n\n/**\n * Check or set whether objects should inherit this ACE.\n */\n$flags->objectInherit($action = null);\n\n/**\n * Whether or not the ACE should generate audit messages for failed access attempts (only valid in the SACL).\n */\n$flags->auditFailedAccess($action = null);\n\n/**\n * Whether or not the ACE should generate audit messages for successful access attempts (only valid in the SACL).\n */\n$flags->auditSuccessfulAccess($action = null);\n\n/**\n * Check whether or not the ACE is inherited. This method can only be checked, not set.\n */\n$flags->isInherited();\n\n\n\n\n\n\nsetFlags(AceFlags $flags)\n\n\nSet the AceFlags object assigned to the ACE.\n\n\nuse LdapTools\\Security\\Ace\\AceFlags;\n\n$flags = new AceFlags(AceFlags::FLAGS['INHERIT_ONLY']);\n$ace->setFlags($flags);\n\n\n\n\n\n\nisAllowAce()\n\n\nA convenience method that will return true for any ACE type that allows access.\n\n\n\n\nisDenyAce()\n\n\nA convenience method that will return true for any ACE type that denies access.\n\n\n\n\nisObjectAce()\n\n\nA convenience method that will return true for any object type ACE.\n\n\n\n\ntoBinary()\n\n\nReturns the binary representation of the ACE.\n\n\n\n\ntoSddl()\n\n\nReturns the SDDL string representation of the ACE.\n\n\necho $ace->toSddl();\n\n\n\n\nParsing SDDL\n\n\nSecurity Descriptor Definition Language (SDDL) is a string representation of a Security Descriptor. It may be necessary\n, or easier, to represent a set of ACLs/ACEs in string form as you pass it around your application. To that end, this\nlibrary contains a SDDL parser capable of taking a SDDL string and producing a SecurityDescriptor object that contains\neverything represented in the SDDL:\n\n\nuse LdapTools\\Security\\SddlParser;\nuse LdapTools\\Exception\\SddlParserException;\n\n// The following SDDL string represents the default Exchange Security Descriptor...\n$sddl = 'O:PSG:PSD:(A;CI;RCCC;;;PS)';\n\n// Parse will return a \"\\LdapTools\\Security\\SecurityDescriptor\" object, as described in earlier sections...\ntry {\n    $sd = (new SddlParser())->parse($sddl);\n} catch (SddlParserException $e) {\n    echo \"Error Parsing SDDL: \".$e->getMessage();\n    exit;\n}\n\necho \"Owner: \".$sd->getOwner();\necho \"Group: \".$sd->getGroup();\nforeach($sd->getDacl()->getAces() as $ace) {\n    echo sprintf('Ace type \"%s\" for \"%s\"', $ace->getType(), $ace->getTrustee());\n}\n\n\n\n\nWhen you are parsing a more complex SDDL string, you may need to instantiate the parser with an LdapConnection instance\nfrom the LdapManager of this library. It is needed when it translates certain well-known SIDs that relate to domain\nobjects;\n\n\nuse LdapTools\\Security\\SddlParser;\nuse LdapTools\\Exception\\SddlParserException;\n\n// The 'DA' short name needs a lookup to find the Domain Admin group SID... \n$sddl = 'O:DAG:DAD:(A;CI;RCCC;;;DA)';\n\ntry {\n    // Assumes $ldap is the LdapManager instance...\n    $sd = (new SddlParser($ldap->getConnection()))->parse($sddl);\n} catch (SddlParserException $e) {\n    echo \"Error Parsing SDDL: \".$e->getMessage();\n    exit;\n}",
            "title": "AD Permissions"
        },
        {
            "location": "/tutorials/AD-Permissions/#active-directory-permissions",
            "text": "Querying and Viewing Permissions  Modifying Existing Permissions  Security Descriptor Methods  DACL and SACL Methods  ACE Methods  Parsing SDDL   Active Directory permissions are stored in each object in the directory in an attribute called  ntSecurityDescriptor .\nThe format of that value is a binary blob. However, if you decode that value it reveals all the Access Control Entries\n(ACEs) that make up the Discretionary Access Control List (DACL).  This library provides several helper classes for parsing all of the ACEs assigned to an LDAP object. Not only do you\nhave the ability to view all of the ACEs, but you can also add/remove/modify ACEs and send the changes back to LDAP to \nchange AD permissions for an object.",
            "title": "Active Directory Permissions"
        },
        {
            "location": "/tutorials/AD-Permissions/#querying-and-viewing-permissions",
            "text": "When you query for permissions there are a few rules to keep in mind:   You must send a LDAP control with the SD Flags value to retrieve permissions as a non-admin account.  When you query for permissions you need to disable paging, otherwise it will not return any results.   So to query and retrieve the permissions for a specific account, do something like the following:  use LdapTools\\Connection\\LdapControl;\nuse LdapTools\\Connection\\LdapControlType;\nuse LdapTools\\Security\\SecurityDescriptor;\nuse LdapTools\\Security\\Ace\\AceRights;\nuse LdapTools\\Security\\SID;\n\n// ...\n\n// This tells the DC that when we request/process the 'ntSecurityDescriptor' we will exclude the SACL.\n// Without this the attribute will not be returned from AD (unless you're using a domain admin account)\n$sdControl = new LdapControl(LdapControlType::SD_FLAGS_CONTROL, true, LdapControl::berEncodeInt(7));\n$ldap->getConnection()->setControl($sdControl);\n\n$user = $ldap->buildLdapQuery()\n    ->fromUsers()\n    ->where(['username' => 'SomeUser'])\n    // The ntSecurityDescriptor is what describes permissions against that object...\n    ->select('ntSecurityDescriptor')\n    // Paging must be set to false, otherwise it interfers with the SD Flags control we set...\n    ->setUsePaging(false)\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Instantiate a new Security Descriptor class that decodes and represents all of the AD permissions...\n$sd = new SecurityDescriptor($user->get('ntSecurityDescriptor'));\n\n// The DACL is what contains all of your ACEs, so loop through it.\n// We will check specifically if this user cannot change their own password.\nforeach ($sd->getDacl()->getAces() as $ace) {\n   // Ignore any ACEs that allow access\n   if ($ace->isAllowAce()) {\n       continue;\n   }\n   // This will check if the user is setup so they cannot change their own password...\n   if ((string) $ace->getSid() === SID::SHORT_NAME['PS'] && (string) $ace->getObjectType() === AceRights::EXTENDED['CHANGE_PASSWORD']) {\n       echo \"User cannot change their password.\".PHP_EOL;\n   }\n}",
            "title": "Querying and Viewing Permissions"
        },
        {
            "location": "/tutorials/AD-Permissions/#modifying-existing-permissions",
            "text": "Working off the same example as above, after you determined that a user is set so they cannot change their password,\nyou can switch it back so they can by removing one ACE and flipping the type of another. The following will assume you\nare already working with the Security Descriptor object queried above:  // The DACL is what contains all of your ACEs, so loop through it\n// We will check specifically if this user cannot change their own password\nforeach ($sd->getDacl()->getAces() as $ace) {\n   // Ignore any ACEs that allow access\n   if ($ace->isAllowAce()) {\n       continue;\n   }\n   // This will get the ACE that applies to the user themselves ('PS' is the SID short name for 'Principal Self')\n   if ((string) $ace->getSid() === SID::SHORT_NAME['PS'] && (string) $ace->getObjectType() === AceRights::EXTENDED['CHANGE_PASSWORD']) {\n       $sd->getDacl()->removeAce($ace);\n   }\n   // This flips the ACE type to allow for the 'WD' SID ('WD' is the SID short name for \"Everyone\").\n   if ((string) $ace->getSid() === SID::SHORT_NAME['WD'] && (string) $ace->getObjectType() === AceRights::EXTENDED['CHANGE_PASSWORD']) {\n       $ace->setType(new AceType('A'));\n   }\n}\n\n// Now set the new Security Descriptor value and send it back to LDAP...\n$user->set('ntSecurityDescriptor', $sd->toBinary());\n$ldap->persist($user);",
            "title": "Modifying Existing Permissions"
        },
        {
            "location": "/tutorials/AD-Permissions/#security-descriptor-methods",
            "text": "The Security Descriptor object is what represents the complete permissions for an LDAP object. It contains the SACL,\nDACL, owner, and group. It can be instantiated with its binary representation, or with nothing then explicitly use the\nmethods below to describe it.   getDacl()  Get the Discretionary Access Control List for the Security Descriptor. This is what contains all of the permission ACEs\nassigned to the LDAP object.  $aces = $sd->getDacl()->getAces();   setDacl(Dacl $dacl = null)  Set the Discretionary Access Control List for the security Descriptor. This must be the DACL object.  use LdapTools\\Security\\Acl\\Dacl;\n\n$sd->setDacl(new Dacl());   getSacl()  Get the System Access Control List for the Security Descriptor. This contains System Audit entries, not permissions. The\nobjects are still ACEs, but they relate to what specific access rights get audited.  $aces = $sd->getSacl()->getAces();   setSacl(Sacl $sacl = null)  Set the System Access Control List for the Security Descriptor. This must be the SACL object.  use LdapTools\\Security\\Acl\\Sacl;\n\n$sd->setSacl(new Sacl());   getOwner()  This returns the owner of the Security Descriptor as a SID object.  echo $sd->getOwner()->toString();   setOwner($owner)  Set the owner of the Security Descriptor. This can be a SID object or a string SID/SID short name.  use LdapTools\\Security\\SID;\n\n// The SID can be constructed with a SID string, or a SID short name...\n$sd->setOwner(SID::SHORT_NAME['BA']);   getGroup()  Get the primary group of the owner of the Security Descriptor. This will be a SID object.  echo $sd->getGroup()->toString();   setGroup($group)  Set the primary group of the Security Descriptor. This can be a SID object or a string SID/SID short name.  // The SID can be constructed with a SID string, or a SID short name...\n$sd->setGroup('S-1-5-21-1263317781-1938881490-3107577794-512');   toBinary($canonical = true)  Get the binary representation of the Security Descriptor. This is the format it must be in when being sent back via LDAP.\nYou can optionally pass  false  as a parameter if you're sending a non-canonical set of ACEs to LDAP. Typically you do\nnot want to do that.  $binary = $sd->toBinary();   toSddl($canonical = true)  Get the Security Descriptor Definition Language (SDDL) string representation of the object. You can optionally pass  false  as a parameter if you want the ACEs represent in a non-canonical form. Typically you do not want to do that.  echo $sd->toSddl();   getControlFlags()  Get the Control Flags for the Security Descriptor. This returns a flags object.  use LdapTools\\Security\\ControlFlags;\n\n$flags = $sd->getControlFlags();\n\nif ($flags->has(ControlFlags::FLAG['SACL_PRESENT']) {\n   // ...\n}   setControlFlags(ControlFlags $flags)  Set the control flags for the Security Descriptor. This must be a ControlFlags object.  use LdapTools\\Security\\ControlFlags;\n\n$sd->setControlFlags(new ControlFlags(ControlFlags::FLAGS['SELF_RELATIVE']);",
            "title": "Security Descriptor Methods"
        },
        {
            "location": "/tutorials/AD-Permissions/#dacl-and-sacl-methods",
            "text": "The DACL and SACL both contain a set of ACEs. The DACL is what contains all of the permission ACEs. The SACL contains\nall of the System ACEs used for auditing purposes. However, they both contain the same basic methods, with only a few\nexceptions.   getAces()  Get all of the ACEs assigned to the ACL as an array of ACE objects.  // Loop through each ACE and print out the SDDL representation of it...\nforeach ($sd->getDacl()->getAces() as $ace) {\n    echo $ace->toSddl();\n}   setAces(Ace ...$aces)  Set the ACEs for the ACL. This overwrites any ACEs that might be set on the ACL already.  // Set some valid access obviously (not these...)\n$aces = [\n    (new Ace('D')->setTrustee('BA'),\n    (new Ace('A')->setTrustee('PS'),\n]\n\n$sd->getDacl()->setAces(...$aces);   hasAce(Ace ...$aces)  Check if an ACE (or several ACEs) exists on the ACL. The check is strict, so the ACE needs to be the same object to return true.   removeAce(Ace ...$aces)  Remove an ACE (or several ACEs) from the ACL. The ACE must be the same object already assigned to the ACL.  foreach ($sd->getDacl()->getAces() as $ace) {\n    // Perform some logic to check if the ACE should be removed...\n    // ...\n    $sd->getDacl()->removeAce($ace);\n}   addAce(Ace ...$aces)  Add an ACE (or several ACEs) to the ACL. You do not have to worry about the the ACE order in the ACL when adding it.\nWhen the ACL is converted to binary/SDDL form it is canonicalized to be in the correct order.  use LdapTools\\Security\\Ace\\Ace;\nuse LdapTools\\Security\\Ace\\AceRights;\n\n// OA is short for an object allow ace type...\n$ace = (new Ace('OA'))\n    // The SID of the user being granted the right...\n    ->setTrustee('S-1-5-21-1263317781-1938881490-3107577794-1020')\n    // This is an extended access right allowing the trustee to reset a password...\n    ->setObjectType(AceRights::EXTENDED['RESET_PASSWORD'])\n    // This sets the ACE with the Access Control right...\n    ->setRights(new AceRights(AceRights::FLAGS['DS_CONTROL_ACCESS']));\n\n// Add the ACE to the DACL...\n$sd->getDacl()->addAce($ace);   toSddl($canonicalize = true)  This will return a SDDL string that represents all ACEs within the ACL. You can optionally pass a bool to indicate\nwhether or not the ACEs should be canonicalized or not (by default they are).  echo $sd->getDacl()->toSddl();   toBinary($canonicalize = true)  This will return the binary form of the ACL. This is not very useful by itself outside the context of the binary Security\nDescriptor overall. You can optionally pass a bool to indicate whether or not the ACEs should be canonicalized or not\n(by default they are).   isCanonical()  This method is only valid for the DACL. It returns a bool value for whether or not all of the ACEs in the ACL are in \ncanonical form. If you want to see if the ACEs are in canonical for coming from AD then you should call this immediately\nafter instantiating the Security Descriptor.  if (!$sd->getDacl()->isCanonical()) {\n    echo \"Warning! The DACL is not in canonical form. Be careful when editing...\";\n}   canonicalize()  Calling this method forces all ACEs in the ACL into canonical form. This is the order that AD expects the ACEs to be in\nwhen saving it back via LDAP. The ACLs are canonicalized automatically when being converted to binary/SDDL, so you do\nnot have to call this each time you make a modification.",
            "title": "DACL and SACL Methods"
        },
        {
            "location": "/tutorials/AD-Permissions/#ace-methods",
            "text": "The Access Control Entry (ACE) represents a specific permission assigned to an ACL. This can represent whether a specific\nuser (The \"Trustee\" as it is referred to on an ACE) is allowed or denied read/write access to a specific Active Directory\nproperty object, or event if they are allowed or denied rights for specific actions, such as resetting a password or being\nable to have send-as rights on a user's mailbox in Exchange.  There are several helper/convenience methods available to make it easier to decipher and parse the ACEs assigned to an\nobject so you can take the action you need.   getType()  The ACE type represents if this is an access allowed or access denied type, and whether the ACE relates to an object type\nor not.   // Show the SDDL short name of the ACE type...\necho $ace->getType()->getShortName();   setType(AceType $type)  When setting the ACE type explicitly you need to use the AceType object. The ACE type can be one of several types and \ncan be defined by its SDDL short name or one of the constants available on the  LdapTools\\Security\\Ace\\AceType  class.\nAvailable types defined on the AceType class include:      const TYPE = [\n        'ACCESS_ALLOWED' => 0x00,\n        'ACCESS_DENIED' => 0x01,\n        'SYSTEM_AUDIT' => 0x02,\n        'SYSTEM_ALARM' => 0x03,\n        'ACCESS_ALLOWED_COMPOUND' => 0x04,\n        'ACCESS_ALLOWED_OBJECT' => 0x05,\n        'ACCESS_DENIED_OBJECT' => 0x06,\n        'SYSTEM_AUDIT_OBJECT' => 0x07,\n        'SYSTEM_ALARM_OBJECT' => 0x08,\n        'ACCESS_ALLOWED_CALLBACK' => 0x09,\n        'ACCESS_DENIED_CALLBACK' => 0x0A,\n        'ACCESS_ALLOWED_CALLBACK_OBJECT' => 0x0B,\n        'ACCESS_DENIED_CALLBACK_OBJECT' => 0x0C,\n        'SYSTEM_AUDIT_CALLBACK' => 0x0D,\n        'SYSTEM_ALARM_CALLBACK' => 0x0E,\n        'SYSTEM_AUDIT_CALLBACK_OBJECT' => 0x0F,\n        'SYSTEM_ALARM_CALLBACK_OBJECT' => 0x10,\n        'SYSTEM_MANDATORY_LABEL' => 0x11,\n        'SYSTEM_RESOURCE_ATTRIBUTE' => 0x12,\n        'SYSTEM_SCOPED_POLICY_ID' => 0x13,\n    ];  Only  ACCESS_*  ACEs can be added to a DACL. And only  SYSTEM_*  ACEs can be added to a SACL.  use LdapTools\\Ace\\Ace;\nuse LdapTools\\Ace\\AceType;\n\n// You can instantiate an ACE using its AceType SDDL short name...\n$ace = new Ace('A');\n\n// Set the AceType by object, flipping it to a deny...\n$ace->setType(new AceType('D'));   getTrustee()  Get SID object of the trustee for the ACE.  // Print the trustee SID as a string...\necho $ace->getTrustee()->toString();   setTrustee($sid)  Set the SID of the trustee for this ACE. This can be either a SID object, a string SID, or a SID short name.  // Set the trustee SID by short name...\n$ace->setTrustee('PS');\n\n// Set the trustee SID by using a string SID...\n$ace->setTrustee('S-1-5-21-1263317781-1938881490-3107577794-512');   getObjectType()  Get the GUID object type this ACE controls access for if this is an object type ACE (otherwise this will be null). This GUID\ncan represent a specific AD property, or some type of extended access right for the ACE.  if ($ace->getObjectType()) {\n    echo $ace->getObjectType()->toString();\n}   setObjectType($guid)  Set the GUID object type this ACE controls access for. When you set this it will automatically toggle the AceObjectFlags\nas needed. You can pass either a GUID object or a GUID string as a parameter.  use LdapTools\\Security\\GUID;\nuse LdapTools\\Security\\Ace\\AceRights;\n\n// Set by the GUID object...\n$ace->setObjectType(new GUID('bf967950-0de6-11d0-a285-00aa003049e2'));\n\n// Set by a string GUID from a constant...\n$ace->setObjectType(AceRights::EXTENDED['RESET_PASSWORD']);   getInheritedObjectType()  Get the GUID object type that represents the type of child objects that can inherit the ACE. This returns the same type\nof value as the  getObjectType()  method. See above.   setInheritedObjectType($guid)  Set the GUID object type that represents the type of child objects that can inherit the ACE. This allows the same type\nof values as the  setInheritedObjectType()  method. See above.   getRights()  Returns an AceRights object that has several helper methods for checking/settting what rights are assigned to this ACE:  // Get the AceRights object...\n$rights = $ace->getRights();\n\n// The below functions can either check for access, or set access (pass a bool true or false to toggle)...\n\n/**\n * Check or set the ability to read a specific property.\n */\n$rights->readProperty($action = null);\n\n/**\n * Check or set the ability to write a specific property.\n */\n$rights->writeProperty($action = null);\n\n/**\n * Check or set the ability to create child objects.\n */\n$rights->createChildObject($action = null);\n\n/**\n * Check or set the ability to delete child objects.\n */\n$rights->deleteChildObject($action = null);\n\n/**\n * Check or set the ability to list child objects.\n */\n$rights->listChildObject($action = null);\n\n/**\n * Check or set the ability to delete objects of a certain type (all if objectType on the ACE is empty).\n */\n$rights->deleteObject($action = null);\n\n/**\n * Check or set the ability to list objects of a specific type.\n */\n$rights->listObject($action = null);\n\n/**\n * Check or set the ability to perform a validated write for a property.\n */\n$rights->validatedWrite($action = null);\n\n/**\n * Check or set control access rights. These control specific actions/operations on an object or attribute.\n */\n$rights->controlAccess($action = null);\n\n/**\n * Check or set the ability to read data from the security descriptor (minus the SACL).\n */\n$rights->readSecurity($action = null);\n\n/**\n * Check or set the ability to access the SACL of an object.\n */\n$rights->accessSacl($action = null);\n\n/**\n * Check or set the ability to write the DACL of an object.\n */\n$rights->writeDacl($action = null);\n\n/**\n * Check or set the ability to assume ownership of the object. The user must be an object trustee. The user cannot\n * transfer the ownership to other users.\n */\n$rights->writeOwner($action = null);\n\n/**\n * Check or set the ability to read permissions on this object, read all the properties on this object, list this\n * object name when the parent container is listed, and list the contents of this object if it is a container.\n */\n$rights->readAll($action = null);\n\n/**\n * Check or set the ability to read permissions on this object, write all the properties on this object, and perform\n * all validated writes to this object.\n */\n$rights->writeAll($action = null);\n\n/**\n * Check or set the ability to read permissions on, and list the contents of, a container object.\n */\n$rights->execute($action = null);\n\n/**\n * Check or set the ability to create or delete child objects, delete a subtree, read and write properties, examine\n * child objects and the object itself, add and remove the object from the directory, and read or write with an\n * extended right.\n */\n$rights->fullControl($action = null);\n\n/**\n * Check or set the ability to use the object for synchronization. This enables a thread to wait until the\n * object is in the signaled state.\n */\n$rights->synchronize($action = null);   setRights(AceRights $rights)  Set a specific AceRights to the ACE.  use LdapTools\\Security\\Ace\\AceRights;\n\n$rights = new AceRights(AceRights::SHORT_NAME['CR']);\n$ace->setRights($rights);   getFlags()  Gets an AceFlags object that represents all of the flags set for the ACE. This has several helper methods for extracting\nuseful information about the ACE:  // Get the AceFlags object...\n$flags = $ace->getFlags();\n\n// The below functions can either check for a specific flag, or toggle it on/off with a bool true or false...\n\n/**\n * Check or set whether the ACE does not control access to the object to which it is attached. When this is true,\n * the ACE only controls access on those objects which inherit it.\n */\n$flags->inheritOnly($action = null);\n\n/**\n * Check or set whether inheritance of this ACE should be propagated.\n */\n$flags->propagateInheritance($action = null);\n\n/**\n * Check or set whether containers should inherit this ACE.\n */\n$flags->containerInherit($action = null);\n\n/**\n * Check or set whether objects should inherit this ACE.\n */\n$flags->objectInherit($action = null);\n\n/**\n * Whether or not the ACE should generate audit messages for failed access attempts (only valid in the SACL).\n */\n$flags->auditFailedAccess($action = null);\n\n/**\n * Whether or not the ACE should generate audit messages for successful access attempts (only valid in the SACL).\n */\n$flags->auditSuccessfulAccess($action = null);\n\n/**\n * Check whether or not the ACE is inherited. This method can only be checked, not set.\n */\n$flags->isInherited();   setFlags(AceFlags $flags)  Set the AceFlags object assigned to the ACE.  use LdapTools\\Security\\Ace\\AceFlags;\n\n$flags = new AceFlags(AceFlags::FLAGS['INHERIT_ONLY']);\n$ace->setFlags($flags);   isAllowAce()  A convenience method that will return true for any ACE type that allows access.   isDenyAce()  A convenience method that will return true for any ACE type that denies access.   isObjectAce()  A convenience method that will return true for any object type ACE.   toBinary()  Returns the binary representation of the ACE.   toSddl()  Returns the SDDL string representation of the ACE.  echo $ace->toSddl();",
            "title": "Ace Methods"
        },
        {
            "location": "/tutorials/AD-Permissions/#parsing-sddl",
            "text": "Security Descriptor Definition Language (SDDL) is a string representation of a Security Descriptor. It may be necessary\n, or easier, to represent a set of ACLs/ACEs in string form as you pass it around your application. To that end, this\nlibrary contains a SDDL parser capable of taking a SDDL string and producing a SecurityDescriptor object that contains\neverything represented in the SDDL:  use LdapTools\\Security\\SddlParser;\nuse LdapTools\\Exception\\SddlParserException;\n\n// The following SDDL string represents the default Exchange Security Descriptor...\n$sddl = 'O:PSG:PSD:(A;CI;RCCC;;;PS)';\n\n// Parse will return a \"\\LdapTools\\Security\\SecurityDescriptor\" object, as described in earlier sections...\ntry {\n    $sd = (new SddlParser())->parse($sddl);\n} catch (SddlParserException $e) {\n    echo \"Error Parsing SDDL: \".$e->getMessage();\n    exit;\n}\n\necho \"Owner: \".$sd->getOwner();\necho \"Group: \".$sd->getGroup();\nforeach($sd->getDacl()->getAces() as $ace) {\n    echo sprintf('Ace type \"%s\" for \"%s\"', $ace->getType(), $ace->getTrustee());\n}  When you are parsing a more complex SDDL string, you may need to instantiate the parser with an LdapConnection instance\nfrom the LdapManager of this library. It is needed when it translates certain well-known SIDs that relate to domain\nobjects;  use LdapTools\\Security\\SddlParser;\nuse LdapTools\\Exception\\SddlParserException;\n\n// The 'DA' short name needs a lookup to find the Domain Admin group SID... \n$sddl = 'O:DAG:DAD:(A;CI;RCCC;;;DA)';\n\ntry {\n    // Assumes $ldap is the LdapManager instance...\n    $sd = (new SddlParser($ldap->getConnection()))->parse($sddl);\n} catch (SddlParserException $e) {\n    echo \"Error Parsing SDDL: \".$e->getMessage();\n    exit;\n}",
            "title": "Parsing SDDL"
        },
        {
            "location": "/tutorials/AD-User-Modification/",
            "text": "AD User Modification\n\n\n\n\n\n\nUser Account Properties\n\n\nGroup Membership\n\n\nLog-On-To Workstations List\n\n\nAccount Expiration Date\n\n\nManager Modification\n\n\n\n\nModifying an Active Directory user is really no different than modifying any other LDAP object, but there are a few\nthings to note. For example, using a few simple statements you can modify many of the user's properties typically seen\nin the \"Account\" tab in the \"AD Users and Computers\" tool:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n//...\n\n// First get the user object via a repository.\n$repository = $ldapManager->getRepository(LdapObjectType::USER);\n$user = $repository->findOneByUsername('chad');\n\n// Make sure the user account is set to enabled.\n$user->setEnabled(true);\n// Set their password to never expire.\n$user->setPasswordNeverExpires(true);\n\ntry {\n    $ldapManager->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error modifying user! \".$e->getMessage();\n}\n\n\n\n\nWith the above statement you have just the user account to be enabled and set the password to never expire.\n\n\nUser Account Properties\n\n\nThis table contains many useful AD attributes you can toggle with a simple \ntrue\n or \nfalse\n value like above.\n\n\n\n\n\n\n\n\nProperty Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndisabled\n\n\nWhether or not the account is disabled.\n\n\n\n\n\n\nenabled\n\n\nWhether or not the account is enabled.\n\n\n\n\n\n\npasswordIsReversible\n\n\nLegacy AD setting. Should NOT be used.\n\n\n\n\n\n\npasswordMustChange\n\n\nSet that the user's password must change on the next login.\n\n\n\n\n\n\npasswordNeverExpires\n\n\nSet the user's password to never expire.\n\n\n\n\n\n\nsmartCardRequired\n\n\nSet that a smart card is required for interactive login.\n\n\n\n\n\n\ntrustedForAllDelegation\n\n\nTrust the user for delegation to any service (Kerberos).\n\n\n\n\n\n\ntrustedForAnyAuthDelegation\n\n\nDelegate using any authentication protocol (When selected for delegation to specific services only).\n\n\n\n\n\n\n\n\nGroup Membership\n\n\nGroup membership can be modified directly using the \ngroups\n attribute on a user. You can reference a group using its\nname, SID, GUID, DN, or a \nLdapObject\n.\n\n\n// First get the user object via a query.\n$user = $ldapManager->buildLdapQuery()\n    ->select('groups')\n    ->fromUsers()\n    ->where(['username' => 'Chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Add a few groups by name, with the last one being by GUID\n$user->addGroups('Employees', 'VPN Users', '270db4d0-249d-46a7-9cc5-eb695d9af9ac');\n\n// Remove a group by a SID\n$user->removeGroups('S-1-5-21-1004336348-1177238915-682003330-512');\n\n// Reset the current groups. This will remove any groups they are currently a member of\n$user->resetGroups();\n\n// Add a group from the result of a separate LDAP query...\n$group = $ldapManager->buildLdapQuery()\n    ->fromGroups()\n    ->where(['name' => 'IT Stuff'])\n    ->getLdapQuery()\n    ->getSingleResult();\n$user->addGroups($group);\n\n// Save the changes back to LDAP...\ntry {\n    $ldapManager->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error modifying groups: \".$e->getMessage();\n}\n\n\n\n\nUser Log On To Workstations List\n\n\nTo easily modify the workstations that an account can log into, you can use the \nlogonWorkstations\n attribute. This\nattribute functions like an array and maps to to the \"Log on To...\" section of an account.\n\n\n\n// A LdapObject as the result of a search. Set the workstations allowed...\n$user->setLogonWorkstations(['PC01', 'PC02', 'PC03']);\n\n// Add only one workstation...\n$user->addLogonWorkstations('PC04');\n\n// Remove one of the workstations...\n$user->removeLogonWorkstations('PC01');\n\n\n\n\nAccount Expiration Date\n\n\nTo modify the date at which an account will expire, which will prevent the user from logging in past that time, you can \nuse the \naccountExpirationDate\n attribute. This attribute accepts either a bool \nfalse\n (the account never expires) or\n a PHP \n\\DateTime\n object specifying the date at which the account should expire.\n\n\n\n// A LdapObject as the result of a search. Set the account to never expire.\n$user->setAccountExpirationDate(false);\n\n// Instead, set the account to expire sometime in the future.\n$user->setAccountExpirationDate(new \\DateTime('2228-3-22'));\n\n\n\n\nManager Modification\n\n\nYou can set the \nmanager\n attribute by using several values: A string GUID, string SID, a distinguished name, username,\nor a \nLdapObject\n:\n\n\n// First get the user object via a query.\n$user = $ldapManager->buildLdapQuery()\n    ->select('manager')\n    ->fromUsers()\n    ->where(['username' => 'Chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Set the manager via username\n$user->setManager('Tim');\n// Set the manager via a SID\n$user->setManager('S-1-5-21-1004336348-1177238915-682003330-512');\n// Set the manager via a GUID\n$user->setManager('270db4d0-249d-46a7-9cc5-eb695d9af9ac');\n// Set the manager via a DN\n$user->setManager('CN=Tim,OU=Employees,DC=example,DC=local');\n\n// Set the manager as a result of an LDAP object for a different query\n$manager = $ldapManager->buildLdapQuery()\n    ->select()\n    ->fromUsers()\n    ->where(['lastName' => 'Smith', 'office' => 'Head Office'])\n    ->getLdapQuery()\n    ->getSingleResult();\n$user->setManager($manager);\n\n// All of the above will ultimately produce the same result.\ntry {\n    $ldapManager->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error changing the manager: \".$e->getMessage();\n}",
            "title": "AD User Modification"
        },
        {
            "location": "/tutorials/AD-User-Modification/#ad-user-modification",
            "text": "User Account Properties  Group Membership  Log-On-To Workstations List  Account Expiration Date  Manager Modification   Modifying an Active Directory user is really no different than modifying any other LDAP object, but there are a few\nthings to note. For example, using a few simple statements you can modify many of the user's properties typically seen\nin the \"Account\" tab in the \"AD Users and Computers\" tool:  use LdapTools\\Object\\LdapObjectType;\n\n//...\n\n// First get the user object via a repository.\n$repository = $ldapManager->getRepository(LdapObjectType::USER);\n$user = $repository->findOneByUsername('chad');\n\n// Make sure the user account is set to enabled.\n$user->setEnabled(true);\n// Set their password to never expire.\n$user->setPasswordNeverExpires(true);\n\ntry {\n    $ldapManager->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error modifying user! \".$e->getMessage();\n}  With the above statement you have just the user account to be enabled and set the password to never expire.",
            "title": "AD User Modification"
        },
        {
            "location": "/tutorials/AD-User-Modification/#user-account-properties",
            "text": "This table contains many useful AD attributes you can toggle with a simple  true  or  false  value like above.     Property Name  Description      disabled  Whether or not the account is disabled.    enabled  Whether or not the account is enabled.    passwordIsReversible  Legacy AD setting. Should NOT be used.    passwordMustChange  Set that the user's password must change on the next login.    passwordNeverExpires  Set the user's password to never expire.    smartCardRequired  Set that a smart card is required for interactive login.    trustedForAllDelegation  Trust the user for delegation to any service (Kerberos).    trustedForAnyAuthDelegation  Delegate using any authentication protocol (When selected for delegation to specific services only).",
            "title": "User Account Properties"
        },
        {
            "location": "/tutorials/AD-User-Modification/#group-membership",
            "text": "Group membership can be modified directly using the  groups  attribute on a user. You can reference a group using its\nname, SID, GUID, DN, or a  LdapObject .  // First get the user object via a query.\n$user = $ldapManager->buildLdapQuery()\n    ->select('groups')\n    ->fromUsers()\n    ->where(['username' => 'Chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Add a few groups by name, with the last one being by GUID\n$user->addGroups('Employees', 'VPN Users', '270db4d0-249d-46a7-9cc5-eb695d9af9ac');\n\n// Remove a group by a SID\n$user->removeGroups('S-1-5-21-1004336348-1177238915-682003330-512');\n\n// Reset the current groups. This will remove any groups they are currently a member of\n$user->resetGroups();\n\n// Add a group from the result of a separate LDAP query...\n$group = $ldapManager->buildLdapQuery()\n    ->fromGroups()\n    ->where(['name' => 'IT Stuff'])\n    ->getLdapQuery()\n    ->getSingleResult();\n$user->addGroups($group);\n\n// Save the changes back to LDAP...\ntry {\n    $ldapManager->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error modifying groups: \".$e->getMessage();\n}",
            "title": "Group Membership"
        },
        {
            "location": "/tutorials/AD-User-Modification/#user-log-on-to-workstations-list",
            "text": "To easily modify the workstations that an account can log into, you can use the  logonWorkstations  attribute. This\nattribute functions like an array and maps to to the \"Log on To...\" section of an account.  \n// A LdapObject as the result of a search. Set the workstations allowed...\n$user->setLogonWorkstations(['PC01', 'PC02', 'PC03']);\n\n// Add only one workstation...\n$user->addLogonWorkstations('PC04');\n\n// Remove one of the workstations...\n$user->removeLogonWorkstations('PC01');",
            "title": "User Log On To Workstations List"
        },
        {
            "location": "/tutorials/AD-User-Modification/#account-expiration-date",
            "text": "To modify the date at which an account will expire, which will prevent the user from logging in past that time, you can \nuse the  accountExpirationDate  attribute. This attribute accepts either a bool  false  (the account never expires) or\n a PHP  \\DateTime  object specifying the date at which the account should expire.  \n// A LdapObject as the result of a search. Set the account to never expire.\n$user->setAccountExpirationDate(false);\n\n// Instead, set the account to expire sometime in the future.\n$user->setAccountExpirationDate(new \\DateTime('2228-3-22'));",
            "title": "Account Expiration Date"
        },
        {
            "location": "/tutorials/AD-User-Modification/#manager-modification",
            "text": "You can set the  manager  attribute by using several values: A string GUID, string SID, a distinguished name, username,\nor a  LdapObject :  // First get the user object via a query.\n$user = $ldapManager->buildLdapQuery()\n    ->select('manager')\n    ->fromUsers()\n    ->where(['username' => 'Chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\n// Set the manager via username\n$user->setManager('Tim');\n// Set the manager via a SID\n$user->setManager('S-1-5-21-1004336348-1177238915-682003330-512');\n// Set the manager via a GUID\n$user->setManager('270db4d0-249d-46a7-9cc5-eb695d9af9ac');\n// Set the manager via a DN\n$user->setManager('CN=Tim,OU=Employees,DC=example,DC=local');\n\n// Set the manager as a result of an LDAP object for a different query\n$manager = $ldapManager->buildLdapQuery()\n    ->select()\n    ->fromUsers()\n    ->where(['lastName' => 'Smith', 'office' => 'Head Office'])\n    ->getLdapQuery()\n    ->getSingleResult();\n$user->setManager($manager);\n\n// All of the above will ultimately produce the same result.\ntry {\n    $ldapManager->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error changing the manager: \".$e->getMessage();\n}",
            "title": "Manager Modification"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/",
            "text": "Building LDAP Queries\n\n\n\n\nThe \nLdapQueryBuilder\n class provides an easy object oriented method of producing LDAP filters of any complexity. Those\nfamiliar with Doctrine's QueryBuilder will find this syntax easy to adapt to, as it is pretty much the same. This class\ntakes care of escaping all values passed to it when generating the filter.\n\n\n\n\nLdapQueryBuilder Methods\n\n\nFilter Method Shortcuts\n\n\nUsing Aliases\n\n\nRetrieving Query Results\n\n\n\n\nGenerating LDAP Filters Without LdapManager\n\n\n\n\nThis class is most easily used in the context of the \nLdapManager\n, but it is also possible to use on its own if your \nonly desire is to generate LDAP filters.\n\n\nuse LdapTools\\Query\\LdapQueryBuilder;\n\n$lqb = new LdapQueryBuilder();\n\n$filter = $lqb->select('givenName', 'sn', 'l')\n    ->where(['objectClass' => 'user'])\n    ->andWhere($lqb->filter()->like('sAMAccountName','*smith'))\n    ->toLdapFilter();\n\necho \"LDAP Filter: \".$filter.PHP_EOL;\n\n\n\n\nGenerating Queries When Using the LdapManager\n\n\n\n\nWhen you call \nbuildLdapQuery\n in the \nLdapManager\n you will get an instance of the \nLdapQueryBuilder\n class that knows\nall the information about the schema of your domain, and a \nLdapConnection\n capable of executing the query. With this\ninformation it can do a lot of the heavy lifting to allow it to easily generate any LDAP filter.\n\n\n$lqb = $ldapManager->buildLdapQuery();\n\n// When no attributes are specifically selected, it will pull a default set defined in the schema.\n$users = $lqb->fromUsers()\n    ->where(['state' => 'Wisconsin'])\n    ->getLdapQuery()\n    ->getResult();\n\nforeach ($users as $user) {\n    foreach ($user->toArray() as $attribute => $value) {\n        echo $attribute.' => '.$value.PHP_EOL;\n    }\n}\n\n\n\n\nLdapQueryBuilder Methods\n\n\nThis class provides many methods that simplify the process of creating complex LDAP filters. The following is a list of\nthe methods and their general use.\n\n\n\n\nselect($attributes)\n\n\nThe \nselect\n method allows you to choose specifically which attributes you would like to return from the query. Simply\npass an array of attribute names to it that you would like, or a single attribute as a string. In the absence of \nanything passed to it, it will select the default set of attributes for the query as defined for the type in the schema.\n\n\nTo retrieve all attributes defined in the schema you can pass a single wildcard \n*\n as a selected attribute. In the\nabsence of a schema doing that will also select all LDAP attributes. To select all LDAP attributes and all schema\nattributes for a LDAP object you can pass a double wildcard \n**\n as a selected attribute.\n\n\nAttribute names are looked for in the schema to see if they map to specific LDAP attributes.\n\n\n$lqb->select(['firstName', 'city', 'state', 'sid']);\n\n// Select only a single attribute\n$lqb->select('guid');\n\n// Attribute names will always be returned in the case you enter it in, irrespective of how LDAP returns the data.\n$lqb->select(['FirstName', 'City', 'State', 'SID']);\n\n// Select all attributes defined in the schema for a LDAP object\n$lqb->select('*');\n\n// Select all attributes both in the schema and from LDAP for an object\n$lqb->select('**');\n\n\n\n\nIf you want the raw data to be returned from LDAP you can select LDAP attribute names explicitly. You can also include \nschema names at the same time. Attributes selected by their LDAP attribute name will \nNOT\n have attribute \nconversion done.\n\n\n// Will return 'objectSid' AND 'sid'\n$lqb->select(['givenName', 'l', 'objectSid', 'sid']);\n\n\n\n\n\n\nfrom($ldapType, $alias = null)\n\n\nThe \nfrom\n method requires an argument for the LDAP type. This type must be defined in your LDAP schema. Common types\nthat are in the schema by default include: \nuser\n, \ngroup\n, \ncontact\n, \ncomputer\n, \nou\n. These types are defined as constants\nin the \n\\LdapTools\\Object\\LdapObjectType\n class. Using this method makes the query aware of the attribute name mapping\nand converters defined for the type.\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n// Search for users\n$lqb->from(LdapObjectType::USER);\n\n// Search for computers\n$lqb->from(LdapObjectType::COMPUTER);\n\n// Search for users and assign an alias to it\n$lqb->from(LdapObjectType::USER, 'u');\n\n\n\n\nYou can also call the \nfrom()\n method dynamically for schema types you have defined:\n\n\n// Selects from the 'ExchangeServer' schema type.\n$lqb->fromExchangeServer();\n\n// Selects from the 'container' schema type, and assigns it an alias of 'c'.\n$lqb->fromContainer('c');\n\n\n\n\n\n\nfromUsers($alias = null)\n\n\nA convenience shortcut of the \nfrom\n method to select from LDAP \nuser\n types. Optionally pass a string alias name.\n\n\n// Search for users\n$lqb->fromUsers();\n\n\n\n\n\n\nfromGroups($alias = null)\n\n\nA convenience shortcut of the \nfrom\n method to select from LDAP \ngroup\n types. Optionally pass a string alias name.\n\n\n// Search for groups\n$lqb->fromGroups();\n\n\n\n\n\n\nfromOUs($alias = null)\n\n\nA convenience shortcut of the \nfrom\n method to select from LDAP \nou\n types. Optionally pass a string alias name.\n\n\n// Search for OUs\n$lqb->fromOUs();\n\n\n\n\n\n\nwhere(...$statements)\n\n\nThis method encapsulates its arguments into a logical 'AND' statement. You can either pass a simple array of attributes\nand values that must be met, or any number of filter operator statements.\n\n\n// Pass a simple array of attributes => values. These attributes must be equal to these values.\n$lqb->where(['firstName' => 'Timmy', 'state' => 'Wyoming']);\n\n// Pass filter operator statements instead. It will take care of attribute value conversions as well.\n$lqb->where($lqb->filter()->gte('created', new \\DateTime('5-4-2000'));\n\n// A more complex series of statements\n$lqb->where(\n    $lqb->filter()->neq('firstName', 'Jimbo'),\n    $lqb->filter()->bOr(\n        $lqb->filter()->eq('lastName', 'Dodgson'), \n        $lqb->filter()->eq('lastName', 'Venkman')\n    )\n);\n\n\n\n\n\n\nandWhere(...$statements)\n\n\nThis method is the same as the \nwhere\n method. It encapsulates its arguments into a logical 'AND' statement. Statements\npassed will be added to the same logical 'AND' statement that the \nwhere\n method created.\n\n\n// This adds to the existing and statement...\n$lqb->andWhere(['lastName' => 'Smith']);\n\n\n\n\n\n\norWhere(...$statements)\n\n\nThis method is the same as the \nwhere\n method, but it will instead encapsulate any passed arguments into a logical 'OR'\nstatement.\n\n\n// This creates a separate OR statement...\n$lqb->orWhere(['department' => 'IT', 'department' => 'Marketing']);\n\n\n\n\n\n\nadd(...$statements)\n\n\nThis is a low-level method that will take any object that is an instance of a \nBaseOperator\n and add it to the query.\nThe shorthand \n$lqb->filter()\n methods is what does the heavy-lifting for creating the various operator objects. You\nshould not need to call this method explicitly, but it is included if you need it.\n\n\n// Add some operators directly to the query\n$lqb->add($lqb->filter()->startsWith('name', 'srv'), $lqb->filter()->notPresent('description'));\n\n\n\n\n\n\nsetServer($server)\n\n\nThis lets you set the LDAP server that the query will run against when executed. After the query finishes executing the\nconnection switches back to the LDAP server it was originally connected to.\n\n\n// Query a specific LDAP server\n$lqb->setServer('dc3.example.local');\n\n\n\n\n\n\nsetBaseDn($baseDn)\n\n\nThis method sets the base DN (distinguished name) for the query. That means that any LDAP object at or below this point\nin the directory will be queried for. This will default first to a \nbase_dn\n set in the schema for the object type you\n are searching for and if that is not set it will default to whatever you set in the domain configuration for the\n\nbase_dn\n value.\n\n\n$lqb->setBaseDn('OU=Employees,OU=Users,DC=example,DC=com')\n\n\n\n\n\n\nsetScopeSubTree()\n\n\n'subtree' is the default search scope for the query and should not need to be called explicitly. This method sets the \nLDAP search scope recursively from the point of the base DN onwards.\n\n\n\n\nsetScopeOneLevel()\n\n\nThis method sets the LDAP search scope to one level at the point of the base DN. This is equivalent to a non-recursive\n listing of the contents of a folder directory. The search will not recurse any further than the level of the base DN.\n\n\n\n\nsetScopeBase()\n\n\nThis method sets the LDAP search scope to the base level. This is used to retrieve the contents of a single entry, and \nis most commonly used to retrieve the RootDSE of a domain.\n\n\nExample usage to return the RootDSE for a domain:\n\n\n// NOTE: You can also call the getRootDse() method on the connection object to get the RootDSE...\n$rootDse = $lqb->where($lqb->filter()->present('objectClass'))\n                ->setBaseDn('')\n                ->setScopeBase()\n                ->getLdapQuery()\n                ->getSingleResult();\n\n\n\n\n\n\nsetScope($scope)\n\n\nExplicitly set the scope for the query using the \nQueryOperation::SCOPE\n constant. The available options are:\n\nQueryOperation::SCOPE['SUBTREE']\n, \nQueryOperation::SCOPE['ONELEVEL']\n, \nQueryOperation::SCOPE['BASE']\n\n\nuse LdapTools\\Operation\\QueryOperation;\n\n$lqb->setScope(QueryOperation::SCOPE['ONELEVEL']);\n\n\n\n\n\n\norderBy($attribute, $direction = 'ASC')\n\n\nThis method sets the attribute to order the results by in either ascending (default) or descending order. Calling this \noverwrites any already set orderBy statements. To stack multiple order statements call \naddOrderBy($attribute)\n.\n\n\n// Order results by last name (ascending).\n$users = $lqb->fromUsers()\n    ->where(['firstName' => 'John'])\n    ->orderBy('lastName')\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nBy default the results are ordered in a case-insensitive manner. The order results using a case-sensitive manner use the\n\nsetIsCaseSensitiveSort()\n method of the \nLdapQuery\n class:\n\n\n// Order results in a case-sensitive manner.\n$users = $lqb->fromUsers()\n    ->where(['firstName' => 'John'])\n    ->orderBy('lastName')\n    ->getLdapQuery()\n    ->setIsCaseSensitiveSort(true)\n    ->getResult();\n\n\n\n\n\n\naddOrderBy($attribute, $direction = 'ASC')\n\n\nThis method works the same as \norderBy($attribute)\n, only calling this one will not overwrite already declared order-by \nstatements. Call this when you want to order by multiple attributes.\n\n\n// Order results by last name (descending) and first name (ascending).\n$users = $lqb->fromUsers()\n    ->where(['state' => 'Wisconsin'])\n    ->orderBy('lastName', 'DESC')\n    ->addOrderBy('firstName', 'ASC')\n    ->getResult();\n\n\n\n\n\n\nsetSizeLimit($size)\n\n\nThis methods sets the size limit for the amount of results returned from LDAP for the query.\n\n\n$lqb->setSizeLimit(10);\n\n\n\n\n\n\nsetPageSize($size)\n\n\nThis methods sets the paging size for the query. It will default to whatever value you set in your configuration. The\ndefault when no value is explicitly set is 1000.\n\n\n$lqb->setPageSize(500);\n\n\n\n\n\n\nsetUsePaging($usePaging)\n\n\nThis methods lets you set whether or not paging should be used for the query. This overrides whatever is set in the\ndomain configuration. If this is not set, then whatever is set in the domain configuration is used.\n\n\n$lqb->setUsePaging(false);\n\n\n\n\n\n\ntoLdapFilter()\n\n\nGets the LDAP filter, as a string, that the query would produce.\n\n\n$filter = $lqb->toLdapFilter();\n\n\n\n\nUsing Aliases\n\n\nWhen you want to search for multiple object types you can assign them specific aliases to refer to them in your filter.\nThis makes it easy to get all the results you need with a single query:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$query = $ldap->buildLdapQuery();\n\n// Get all users with a department that starts with IT and groups that contain 'admin' in their description.\n// The resulting objects are ordered by their name (for both users and groups).\n$results = $query\n    ->fromUsers('u')\n    ->fromGroups('g')\n    ->where($query->filter()->startsWith('u.department', 'IT'))\n    ->andWhere($query->filter()->contains('g.description', 'admin'))\n    ->sortBy('name')\n    ->getLdapQuery()\n    ->getResult();\n\nforeach ($results as $result) {\n    if ($result->isType(LdapObjectType::USER)) {\n        echo \"User: \".$result->getName();\n    } else {\n        echo \"Group: \".$result->getName();\n    }\n}\n\n// Select all OUs and Containers at the root of the domain. Order them by name with OUs first, then containers.\n$results = $ldap->buildLdapQuery()\n    ->from(LdapObjectType::OU, 'u')\n    ->from(LdapObjectType::CONTAINER, 'c')\n    ->addOrderBy('u.name', 'ASC')\n    ->addOrderBy('c.name', 'ASC')\n    ->setScopeOneLevel()\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nYou can reference an alias in the query builder anywhere that you would reference a specific attribute (select,\norderBy, where/andWhere/or/orWhere statements, etc). The only rule that applies for alias names is that they can only\nbe alphanumeric (but can also contain underscores).\n\n\nLdapQuery Methods to Retrieve LDAP Results\n\n\n\n\nThere are a few ways to retrieve LDAP results after you have a query built. How you retrieve the results depends upon\nwhat type of data you're looking for. To start to retrieve results you need to first get a \nLdapQuery\n instance by using\nthe \ngetLdapQuery()\n method.\n\n\nThe \ngetLdapQuery()\n method retrieves an instance of the \nLdapQuery\n object that you can then call methods on to get \nyour results. The \nLdapQuery\n object has the filter, page size, base DN, scope, etc that you set in the builder and \ntakes care of converting the LDAP results array using a hydration process. It returns an easier to use set of objects. \nOr you can have it return a simple set of arrays with the attributes and values.\n\n\n\n// By default the results will be a collection of LdapUser objects you can iterate over...\n$results = $lqb->getLdapQuery()->getResult();\n\nforeach ($results as $result) {\n    echo $result->getEmailAddress();\n}\n\n// If you just want simple arrays returned you can specify that\n$results = $lqb->getLdapQuery()->getArrayResult();\n\nforeach ($results as $result) {\n    foreach ($result as $attribute => $value) {\n        echo \"$attribute => $value\";\n    }\n}\n\n\n\n\n\nexecute($hydrationType = HydratorFactory::TO_OBJECT)\n\n\n\n\nThis \nLdapQuery\n method executes the LDAP filter with the options you have set and returns the results as either a set\nobjects (this is the default) or as an array (use the hydration type \nHydratorFactory::TO_ARRAY\n). See previous example \nfor full usage.\n\n\ngetResult($hydrationType = HydratorFactory::TO_OBJECT)\n\n\n\n\nThis is an alias for the \nexecute()\n method. It will return a \nLdapObjectCollection\n by default, or an array of LDAP\nentries if specified as \ngetResult(HydratorFactory::TO_ARRAY)\n.\n\n\ngetArrayResult()\n\n\n\n\nThis functions the same as the \ngetResult()\n method, but it will always return the LDAP entries as an array instead of a\ncollection of objects. This is identical to calling \ngetResult(HydratorFactory::TO_ARRAY)\n.\n\n\ngetSingleResult($hydrationType = HydratorFactory::TO_OBJECT)\n\n\n\n\nThis \nLdapQuery\n method will retrieve a single result from LDAP. So instead of a collection of objects or arrays you\nwill be given a single result you can immediately begin to work with.\n\n\n$lqb = $ldap->buildLdapQuery();\n\n// Retrieve a single LdapObject from a query...\n$user = $lqb->fromUsers()\n    ->Where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\necho \"DN : \".$user->getDn();\n\n\n\n\nIf an empty result set is returned from LDAP then it will throw a \n\\LdapTools\\Exception\\EmptyResultException\n. If more\nthan one result is returned from LDAP then it will throw a \n\\LdapTools\\Exception\\MultiResultException\n. Additionally, \nyou may pass an explicit hydration type to this method if you wish to get the result as a single array of attributes and\nvalues.\n\n\ngetOneOrNullResult($hydrationType = HydratorFactory::TO_OBJECT)\n\n\n\n\nThe behavior of this method is very similar to \ngetSingleResult()\n, but if no results are found for the query it will\nreturn \nnull\n instead of throwing an exception. However, it will still throw an exception in the case that more than one\nresult is returned from LDAP.\n\n\n$lqb = $ldap->buildLdapQuery();\n\n// Retrieve a single LdapObject from a query, or a null result if it doesn't exist...\n$user = $lqb->fromUsers()\n    ->Where(['username' => 'john'])\n    ->getLdapQuery()\n    ->getOneOrNullResult();\n\n// Could be null, so check first...\nif ($user) {\n    echo \"DN : \".$user->getDn();\n}\n\n\n\n\ngetSingleScalarResult()\n\n\n\n\nUsing this method you can get the value of a single attribute from the query. If the LDAP object or attribute does not\nexist then it will throw an exception.\n\n\n$lqb = $ldap->buildLdapQuery();\n\n// Retrieve the GUID string of a specific AD user...\n$guid = $lqb->select('guid')\n    ->fromUsers()\n    ->Where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleScalarResult();\n\necho \"GUID : \".$guid;\n\n\n\n\ngetSingleScalarOrNullResult()\n\n\n\n\nThe behavior of this method is very similar to \ngetSingleScalarResult()\n, but if the attribute is not found/set\nfor the LDAP object it will return \nnull\n instead of throwing an exception. However, it will still throw an exception\nin the case that more than one result is returned from LDAP or if the LDAP object does not exist.\n\n\n$lqb = $ldap->buildLdapQuery();\n\n// Retrieve the title of a specific AD user...\n$title = $lqb->select('title')\n    ->fromUsers()\n    ->Where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleScalarOrNullResult();\n\n// Check if the attribute actually had a value first\n$title = $title ?: 'Unknown';\n\necho $title;\n\n\n\n\nFilter Method Shortcuts\n\n\n\n\nThe \nfilter()\n method of the \nLdapQueryBuilder\n returns a helper class that provides many shortcut methods for creating\nthe LDAP operator classes within the \n\\LdapTools\\Query\\Operator\n namespace. This way you do not have to manually\nconstruct the operators by doing:\n\n\nuse \\LdapTools\\Query\\Operator\\bOr;\nuse \\LdapTools\\Query\\Operator\\Comparison;\n\n// ...\n$lqb->where(new bOr(\n    new Comparison('firstName', Comparison::EQ, 'Bill'),\n    new Comparison('firstName', Comparison::EQ, 'Egon')\n));\n\n\n\n\nInstead you can write:\n\n\n$lqb->where($lqb->filter()->or(\n    $lqb->filter()->eq('firstName', 'Bill'),\n    $lqb->filter()->eq('firstName', 'Egon')\n));\n\n\n\n\nWhen you call \nfilter()\n you are just calling a method on the \n\\LdapTools\\Query\\Builder\\FilterBuilder\n class. The full \nlist and description of available methods is below.\n\n\n\n\naeq($attribute, $value)\n\n\nCreates an \"approximately-equal-to\" comparison between the attribute and the value. The results are dependent on the\nLDAP specific implementation of this operator. But it will typically function as a \"sounds like\" comparison: \n\n(attribute~=value)\n\n\n$lqb->filter()->aeq('firstName', 'Sue');\n\n\n\n\n\n\neq($attribute, $value)\n\n\nCreates an \"equal-to\" comparison between the attribute and the value: \n(attribute=value)\n\n\n$lqb->filter()->eq('lastName', 'Sikorra');\n\n\n\n\n\n\nneq($attribute, $value)\n\n\nCreates a \"not-equal-to\" comparison between the attribute and the value. This is equivalent to wrapping a\n \neq($attribute, $value)\n within a 'NOT' statement: \n(!(attribute=value))\n\n\n$lqb->filter()->neq('department', 'Purchasing');\n\n\n\n\n\n\nlt($attribute, $value)\n\n\nCreates a \"less-than\" comparison between the attribute and the value. Since an actual '<' operator does not exist in \nLDAP, this is a combination of a greater-than-or-equal-to operator along with a check if the attribute is set/present.\nThis is encapsulated within a logical 'AND' operator: \n(&(!(attribute>=value))(attribute=*))\n\n\n$lqb->filter()->lt('badPasswordCount', 2);\n\n\n\n\n\n\nleq($attribute, $value)\n\n\nCreates a \"less-than-or-equal-to\" comparison between the attribute and the value: \n(attribute<=value)\n\n\n$lqb->filter()->leq('badPasswordCount', 1);\n\n\n\n\n\n\ngt($attribute, $value)\n\n\nCreates a \"greater-than\" comparison between the attribute and the value. Since an actual '>' operator does not exist in \nLDAP, this is a combination of a less-than-or-equal-to operator along with a check if the attribute is set/present.\nThis is encapsulated within a logical 'AND' operator: \n(&(!(attribute<=value))(attribute=*))\n\n\n$lqb->filter()->gt('created', new \\DateTime('01-20-2013'));\n\n\n\n\n\n\ngeq($attribute, $value)\n\n\nCreates a \"greater-than-or-equal-to\" comparison between the attribute and the value: \n(attribute>=value)\n\n\n$lqb->filter()->geq('badPasswordCount', 3);\n\n\n\n\n\n\nbitwiseAnd($attribute, $value)\n\n\nCreates a bitwise 'AND' comparison between the attribute and the value: \n(attribute:1.2.840.113556.1.4.803:=value)\n\n\nuse LdapTools\\Query\\UserAccountControlFlags;\n\n$lqb->filter()->bitwiseAnd('userAccountControl', UserAccountControlFlags::DISABLED);\n\n\n\n\n\n\nbitwiseOr($attribute, $value)\n\n\nCreates a bitwise 'OR' comparison between the attribute and the value: \n(attribute:1.2.840.113556.1.4.804:=value)\n\n\nuse LdapTools\\Query\\GroupTypeFlags;\n\n$lqb->filter()->bitwiseOr('groupType', GroupTypeFlags::UNIVERSAL_GROUP);\n\n\n\n\n\n\nstartsWith($attribute, $value)\n\n\nCreates a \"equal-to\" comparison with a wildcard after the value: \n(attribute=value*)\n\n\n$lqb->filter()->startsWith('department', 'IT');\n\n\n\n\n\n\nendsWith($attribute, $value)\n\n\nCreates a \"equal-to\" comparison with a wildcard before the value: \n(attribute=*value)\n\n\n$lqb->filter()->endsWith('description', 'service');\n\n\n\n\n\n\ncontains($attribute, $value)\n\n\nCreates a \"equal-to\" comparison with a wildcards at each end of the value: \n(attribute=*value*)\n\n\n$lqb->filter()->contains('name', 'admin');\n\n\n\n\n\n\nlike($attribute, $value)\n\n\nCreates a \"equal-to\" comparison that will not escape any wildcards you use in the value: \n(attribute=v*a*l*u*e)\n.\n\n\n$lqb->filter()->like('description', '*Some*thing*');\n\n\n\n\n\n\npresent($attribute)\n\n\nCreates a \"equal-to\" comparison with a single wildcard as the value. Returns any entry with this attribute populated: \n\n(attribute=*)\n\n\n$lqb->filter()->present('mail');\n\n\n\n\n\n\nnotPresent($attribute)\n\n\nCreates a negated form of the \npresent($attribute)\n method. Returns any entry that does not contain the attribute: \n\n(!(attribute=*))\n\n\n$lqb->filter()->notPresent('department');\n\n\n\n\n\n\nbAnd(...$statements)\n\n\nCreates a logical 'AND' statement against all other operators passed to it: \n(&((attribute=value)(attribute=value)))\n\n\n$lqb->filter()->bAnd(\n    $lqb->filter()->eq('department', 'IT'), \n    $lqb->filter()->startsWith('firstName', 'Tim')\n);\n\n\n\n\n\n\nbOr(...$statements)\n\n\nCreates a logical 'OR' statement against all other operators passed to it: \n(|((attribute=value)(attribute=value)))\n\n\n$lqb->filter()->bOr(\n    $lqb->filter()->eq('department', 'IT'), \n    $lqb->filter()->eq('department', 'Purchasing')\n);\n\n\n\n\n\n\nbNot($statements)\n\n\nCreates a logical 'NOT' statement against whatever other statement you pass it it: \n(!(attribute=value))\n\n\n$lqb->filter()->bNot($lqb->filter()->eq('department', 'IT'));\n\n\n\n\nActive Directory Filter Method Shortcuts\n\n\nIf you're using a \nLdapConnection\n that has a LDAP type set as \nad\n, then when you call \nfilter()\n you will also have\nadditional filter method shortcuts that are specific to Active Directory:\n\n\n\n\nhasMemberRecursively($member, $attribute = 'members')\n\n\n\n\nRecursively checks groups for a specific member. The \n$member\n parameter can be any of the following:\n\n\n\n\nA username. This must be unique! If a computer and user share the same name then an exception will be thrown.\n\n\nThe GUID of an object (ie. a value like \nbee66f2f-bcf7-4905-b65b-2f36d5008f1e\n)\n\n\nThe SID of an object (ie. a value like \nS-1-5-21-1004336348-1177238915-682003330-512\n)\n\n\nThe full distinguished name of an object.\n\n\nA \nLdapObject\n as the result of another query.\n\n\n\n\nThis creates a matching rule comparison using the OID \nIN_CHAIN\n against the groups \nmembers\n attribute by default. If\nyou have a custom attribute, or some other attribute you would like to run it against, you must pass it as the second\nargument.\n\n\n$username = 'chad';\n\n// Query by a username to get all of their groups recursively...\n$groups = $ldap->buildLdapQuery()\n    ->fromGroups()\n    ->where($query->filter()->hasMemberRecursively($username))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\n\n\nisRecursivelyMemberOf($group)\n\n\nRecursively checks an object's group membership for a group. The \n$group\n parameter can be any of the following:\n\n\n\n\nThe name of a group.\n\n\nThe GUID of a group (ie. a value like \nbee66f2f-bcf7-4905-b65b-2f36d5008f1e\n)\n\n\nThe SID of a group (ie. a value like \nS-1-5-21-1004336348-1177238915-682003330-512\n)\n\n\nThe full distinguished name of a group.\n\n\nA \nLdapObject\n as the result of another query.\n\n\n\n\nThis creates a matching rule comparison using the OID \nIN_CHAIN\n against the users \ngroups\n attribute.\n\n\n// Query by a group name...\n$query = $ldap->buildLdapQuery();\n$users = $query->select()\n    ->fromUsers()\n    ->where($query->filter()->isRecursivelyMemberOf('Employees'))\n    ->getLdapQuery()\n    ->getResult();\n\n// If you are not targeting a specific set of objects from the schema, then you must\n// pass 'false' as the second argument and specify a full DN. Otherwise this method\n// will attempt to use the 'groups' attribute from the schema by default.\n$ldapObjects = $ldap->buildLdapQuery()\n    ->select('description')\n    ->where(['cn' => 'foo'])\n    ->andWhere($query->filter()->isRecursivelyMemberOf('CN=Foo,DC=foo,DC=bar', false))\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\n\n\nmailEnabled()\n\n\n\n\nPerforms a simple check to determine whether an LDAP object is mail-enabled (ie. can receive email from Exchange).",
            "title": "Building LDAP Queries"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#building-ldap-queries",
            "text": "The  LdapQueryBuilder  class provides an easy object oriented method of producing LDAP filters of any complexity. Those\nfamiliar with Doctrine's QueryBuilder will find this syntax easy to adapt to, as it is pretty much the same. This class\ntakes care of escaping all values passed to it when generating the filter.   LdapQueryBuilder Methods  Filter Method Shortcuts  Using Aliases  Retrieving Query Results",
            "title": "Building LDAP Queries"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#generating-ldap-filters-without-ldapmanager",
            "text": "This class is most easily used in the context of the  LdapManager , but it is also possible to use on its own if your \nonly desire is to generate LDAP filters.  use LdapTools\\Query\\LdapQueryBuilder;\n\n$lqb = new LdapQueryBuilder();\n\n$filter = $lqb->select('givenName', 'sn', 'l')\n    ->where(['objectClass' => 'user'])\n    ->andWhere($lqb->filter()->like('sAMAccountName','*smith'))\n    ->toLdapFilter();\n\necho \"LDAP Filter: \".$filter.PHP_EOL;",
            "title": "Generating LDAP Filters Without LdapManager"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#generating-queries-when-using-the-ldapmanager",
            "text": "When you call  buildLdapQuery  in the  LdapManager  you will get an instance of the  LdapQueryBuilder  class that knows\nall the information about the schema of your domain, and a  LdapConnection  capable of executing the query. With this\ninformation it can do a lot of the heavy lifting to allow it to easily generate any LDAP filter.  $lqb = $ldapManager->buildLdapQuery();\n\n// When no attributes are specifically selected, it will pull a default set defined in the schema.\n$users = $lqb->fromUsers()\n    ->where(['state' => 'Wisconsin'])\n    ->getLdapQuery()\n    ->getResult();\n\nforeach ($users as $user) {\n    foreach ($user->toArray() as $attribute => $value) {\n        echo $attribute.' => '.$value.PHP_EOL;\n    }\n}",
            "title": "Generating Queries When Using the LdapManager"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#ldapquerybuilder-methods",
            "text": "This class provides many methods that simplify the process of creating complex LDAP filters. The following is a list of\nthe methods and their general use.   select($attributes)  The  select  method allows you to choose specifically which attributes you would like to return from the query. Simply\npass an array of attribute names to it that you would like, or a single attribute as a string. In the absence of \nanything passed to it, it will select the default set of attributes for the query as defined for the type in the schema.  To retrieve all attributes defined in the schema you can pass a single wildcard  *  as a selected attribute. In the\nabsence of a schema doing that will also select all LDAP attributes. To select all LDAP attributes and all schema\nattributes for a LDAP object you can pass a double wildcard  **  as a selected attribute.  Attribute names are looked for in the schema to see if they map to specific LDAP attributes.  $lqb->select(['firstName', 'city', 'state', 'sid']);\n\n// Select only a single attribute\n$lqb->select('guid');\n\n// Attribute names will always be returned in the case you enter it in, irrespective of how LDAP returns the data.\n$lqb->select(['FirstName', 'City', 'State', 'SID']);\n\n// Select all attributes defined in the schema for a LDAP object\n$lqb->select('*');\n\n// Select all attributes both in the schema and from LDAP for an object\n$lqb->select('**');  If you want the raw data to be returned from LDAP you can select LDAP attribute names explicitly. You can also include \nschema names at the same time. Attributes selected by their LDAP attribute name will  NOT  have attribute \nconversion done.  // Will return 'objectSid' AND 'sid'\n$lqb->select(['givenName', 'l', 'objectSid', 'sid']);   from($ldapType, $alias = null)  The  from  method requires an argument for the LDAP type. This type must be defined in your LDAP schema. Common types\nthat are in the schema by default include:  user ,  group ,  contact ,  computer ,  ou . These types are defined as constants\nin the  \\LdapTools\\Object\\LdapObjectType  class. Using this method makes the query aware of the attribute name mapping\nand converters defined for the type.  use LdapTools\\Object\\LdapObjectType;\n\n// Search for users\n$lqb->from(LdapObjectType::USER);\n\n// Search for computers\n$lqb->from(LdapObjectType::COMPUTER);\n\n// Search for users and assign an alias to it\n$lqb->from(LdapObjectType::USER, 'u');  You can also call the  from()  method dynamically for schema types you have defined:  // Selects from the 'ExchangeServer' schema type.\n$lqb->fromExchangeServer();\n\n// Selects from the 'container' schema type, and assigns it an alias of 'c'.\n$lqb->fromContainer('c');   fromUsers($alias = null)  A convenience shortcut of the  from  method to select from LDAP  user  types. Optionally pass a string alias name.  // Search for users\n$lqb->fromUsers();   fromGroups($alias = null)  A convenience shortcut of the  from  method to select from LDAP  group  types. Optionally pass a string alias name.  // Search for groups\n$lqb->fromGroups();   fromOUs($alias = null)  A convenience shortcut of the  from  method to select from LDAP  ou  types. Optionally pass a string alias name.  // Search for OUs\n$lqb->fromOUs();   where(...$statements)  This method encapsulates its arguments into a logical 'AND' statement. You can either pass a simple array of attributes\nand values that must be met, or any number of filter operator statements.  // Pass a simple array of attributes => values. These attributes must be equal to these values.\n$lqb->where(['firstName' => 'Timmy', 'state' => 'Wyoming']);\n\n// Pass filter operator statements instead. It will take care of attribute value conversions as well.\n$lqb->where($lqb->filter()->gte('created', new \\DateTime('5-4-2000'));\n\n// A more complex series of statements\n$lqb->where(\n    $lqb->filter()->neq('firstName', 'Jimbo'),\n    $lqb->filter()->bOr(\n        $lqb->filter()->eq('lastName', 'Dodgson'), \n        $lqb->filter()->eq('lastName', 'Venkman')\n    )\n);   andWhere(...$statements)  This method is the same as the  where  method. It encapsulates its arguments into a logical 'AND' statement. Statements\npassed will be added to the same logical 'AND' statement that the  where  method created.  // This adds to the existing and statement...\n$lqb->andWhere(['lastName' => 'Smith']);   orWhere(...$statements)  This method is the same as the  where  method, but it will instead encapsulate any passed arguments into a logical 'OR'\nstatement.  // This creates a separate OR statement...\n$lqb->orWhere(['department' => 'IT', 'department' => 'Marketing']);   add(...$statements)  This is a low-level method that will take any object that is an instance of a  BaseOperator  and add it to the query.\nThe shorthand  $lqb->filter()  methods is what does the heavy-lifting for creating the various operator objects. You\nshould not need to call this method explicitly, but it is included if you need it.  // Add some operators directly to the query\n$lqb->add($lqb->filter()->startsWith('name', 'srv'), $lqb->filter()->notPresent('description'));   setServer($server)  This lets you set the LDAP server that the query will run against when executed. After the query finishes executing the\nconnection switches back to the LDAP server it was originally connected to.  // Query a specific LDAP server\n$lqb->setServer('dc3.example.local');   setBaseDn($baseDn)  This method sets the base DN (distinguished name) for the query. That means that any LDAP object at or below this point\nin the directory will be queried for. This will default first to a  base_dn  set in the schema for the object type you\n are searching for and if that is not set it will default to whatever you set in the domain configuration for the base_dn  value.  $lqb->setBaseDn('OU=Employees,OU=Users,DC=example,DC=com')   setScopeSubTree()  'subtree' is the default search scope for the query and should not need to be called explicitly. This method sets the \nLDAP search scope recursively from the point of the base DN onwards.   setScopeOneLevel()  This method sets the LDAP search scope to one level at the point of the base DN. This is equivalent to a non-recursive\n listing of the contents of a folder directory. The search will not recurse any further than the level of the base DN.   setScopeBase()  This method sets the LDAP search scope to the base level. This is used to retrieve the contents of a single entry, and \nis most commonly used to retrieve the RootDSE of a domain.  Example usage to return the RootDSE for a domain:  // NOTE: You can also call the getRootDse() method on the connection object to get the RootDSE...\n$rootDse = $lqb->where($lqb->filter()->present('objectClass'))\n                ->setBaseDn('')\n                ->setScopeBase()\n                ->getLdapQuery()\n                ->getSingleResult();   setScope($scope)  Explicitly set the scope for the query using the  QueryOperation::SCOPE  constant. The available options are: QueryOperation::SCOPE['SUBTREE'] ,  QueryOperation::SCOPE['ONELEVEL'] ,  QueryOperation::SCOPE['BASE']  use LdapTools\\Operation\\QueryOperation;\n\n$lqb->setScope(QueryOperation::SCOPE['ONELEVEL']);   orderBy($attribute, $direction = 'ASC')  This method sets the attribute to order the results by in either ascending (default) or descending order. Calling this \noverwrites any already set orderBy statements. To stack multiple order statements call  addOrderBy($attribute) .  // Order results by last name (ascending).\n$users = $lqb->fromUsers()\n    ->where(['firstName' => 'John'])\n    ->orderBy('lastName')\n    ->getLdapQuery()\n    ->getResult();  By default the results are ordered in a case-insensitive manner. The order results using a case-sensitive manner use the setIsCaseSensitiveSort()  method of the  LdapQuery  class:  // Order results in a case-sensitive manner.\n$users = $lqb->fromUsers()\n    ->where(['firstName' => 'John'])\n    ->orderBy('lastName')\n    ->getLdapQuery()\n    ->setIsCaseSensitiveSort(true)\n    ->getResult();   addOrderBy($attribute, $direction = 'ASC')  This method works the same as  orderBy($attribute) , only calling this one will not overwrite already declared order-by \nstatements. Call this when you want to order by multiple attributes.  // Order results by last name (descending) and first name (ascending).\n$users = $lqb->fromUsers()\n    ->where(['state' => 'Wisconsin'])\n    ->orderBy('lastName', 'DESC')\n    ->addOrderBy('firstName', 'ASC')\n    ->getResult();   setSizeLimit($size)  This methods sets the size limit for the amount of results returned from LDAP for the query.  $lqb->setSizeLimit(10);   setPageSize($size)  This methods sets the paging size for the query. It will default to whatever value you set in your configuration. The\ndefault when no value is explicitly set is 1000.  $lqb->setPageSize(500);   setUsePaging($usePaging)  This methods lets you set whether or not paging should be used for the query. This overrides whatever is set in the\ndomain configuration. If this is not set, then whatever is set in the domain configuration is used.  $lqb->setUsePaging(false);   toLdapFilter()  Gets the LDAP filter, as a string, that the query would produce.  $filter = $lqb->toLdapFilter();",
            "title": "LdapQueryBuilder Methods"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#using-aliases",
            "text": "When you want to search for multiple object types you can assign them specific aliases to refer to them in your filter.\nThis makes it easy to get all the results you need with a single query:  use LdapTools\\Object\\LdapObjectType;\n\n$query = $ldap->buildLdapQuery();\n\n// Get all users with a department that starts with IT and groups that contain 'admin' in their description.\n// The resulting objects are ordered by their name (for both users and groups).\n$results = $query\n    ->fromUsers('u')\n    ->fromGroups('g')\n    ->where($query->filter()->startsWith('u.department', 'IT'))\n    ->andWhere($query->filter()->contains('g.description', 'admin'))\n    ->sortBy('name')\n    ->getLdapQuery()\n    ->getResult();\n\nforeach ($results as $result) {\n    if ($result->isType(LdapObjectType::USER)) {\n        echo \"User: \".$result->getName();\n    } else {\n        echo \"Group: \".$result->getName();\n    }\n}\n\n// Select all OUs and Containers at the root of the domain. Order them by name with OUs first, then containers.\n$results = $ldap->buildLdapQuery()\n    ->from(LdapObjectType::OU, 'u')\n    ->from(LdapObjectType::CONTAINER, 'c')\n    ->addOrderBy('u.name', 'ASC')\n    ->addOrderBy('c.name', 'ASC')\n    ->setScopeOneLevel()\n    ->getLdapQuery()\n    ->getResult();  You can reference an alias in the query builder anywhere that you would reference a specific attribute (select,\norderBy, where/andWhere/or/orWhere statements, etc). The only rule that applies for alias names is that they can only\nbe alphanumeric (but can also contain underscores).",
            "title": "Using Aliases"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#ldapquery-methods-to-retrieve-ldap-results",
            "text": "There are a few ways to retrieve LDAP results after you have a query built. How you retrieve the results depends upon\nwhat type of data you're looking for. To start to retrieve results you need to first get a  LdapQuery  instance by using\nthe  getLdapQuery()  method.  The  getLdapQuery()  method retrieves an instance of the  LdapQuery  object that you can then call methods on to get \nyour results. The  LdapQuery  object has the filter, page size, base DN, scope, etc that you set in the builder and \ntakes care of converting the LDAP results array using a hydration process. It returns an easier to use set of objects. \nOr you can have it return a simple set of arrays with the attributes and values.  \n// By default the results will be a collection of LdapUser objects you can iterate over...\n$results = $lqb->getLdapQuery()->getResult();\n\nforeach ($results as $result) {\n    echo $result->getEmailAddress();\n}\n\n// If you just want simple arrays returned you can specify that\n$results = $lqb->getLdapQuery()->getArrayResult();\n\nforeach ($results as $result) {\n    foreach ($result as $attribute => $value) {\n        echo \"$attribute => $value\";\n    }\n}  execute($hydrationType = HydratorFactory::TO_OBJECT)   This  LdapQuery  method executes the LDAP filter with the options you have set and returns the results as either a set\nobjects (this is the default) or as an array (use the hydration type  HydratorFactory::TO_ARRAY ). See previous example \nfor full usage.  getResult($hydrationType = HydratorFactory::TO_OBJECT)   This is an alias for the  execute()  method. It will return a  LdapObjectCollection  by default, or an array of LDAP\nentries if specified as  getResult(HydratorFactory::TO_ARRAY) .  getArrayResult()   This functions the same as the  getResult()  method, but it will always return the LDAP entries as an array instead of a\ncollection of objects. This is identical to calling  getResult(HydratorFactory::TO_ARRAY) .  getSingleResult($hydrationType = HydratorFactory::TO_OBJECT)   This  LdapQuery  method will retrieve a single result from LDAP. So instead of a collection of objects or arrays you\nwill be given a single result you can immediately begin to work with.  $lqb = $ldap->buildLdapQuery();\n\n// Retrieve a single LdapObject from a query...\n$user = $lqb->fromUsers()\n    ->Where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleResult();\n\necho \"DN : \".$user->getDn();  If an empty result set is returned from LDAP then it will throw a  \\LdapTools\\Exception\\EmptyResultException . If more\nthan one result is returned from LDAP then it will throw a  \\LdapTools\\Exception\\MultiResultException . Additionally, \nyou may pass an explicit hydration type to this method if you wish to get the result as a single array of attributes and\nvalues.  getOneOrNullResult($hydrationType = HydratorFactory::TO_OBJECT)   The behavior of this method is very similar to  getSingleResult() , but if no results are found for the query it will\nreturn  null  instead of throwing an exception. However, it will still throw an exception in the case that more than one\nresult is returned from LDAP.  $lqb = $ldap->buildLdapQuery();\n\n// Retrieve a single LdapObject from a query, or a null result if it doesn't exist...\n$user = $lqb->fromUsers()\n    ->Where(['username' => 'john'])\n    ->getLdapQuery()\n    ->getOneOrNullResult();\n\n// Could be null, so check first...\nif ($user) {\n    echo \"DN : \".$user->getDn();\n}  getSingleScalarResult()   Using this method you can get the value of a single attribute from the query. If the LDAP object or attribute does not\nexist then it will throw an exception.  $lqb = $ldap->buildLdapQuery();\n\n// Retrieve the GUID string of a specific AD user...\n$guid = $lqb->select('guid')\n    ->fromUsers()\n    ->Where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleScalarResult();\n\necho \"GUID : \".$guid;  getSingleScalarOrNullResult()   The behavior of this method is very similar to  getSingleScalarResult() , but if the attribute is not found/set\nfor the LDAP object it will return  null  instead of throwing an exception. However, it will still throw an exception\nin the case that more than one result is returned from LDAP or if the LDAP object does not exist.  $lqb = $ldap->buildLdapQuery();\n\n// Retrieve the title of a specific AD user...\n$title = $lqb->select('title')\n    ->fromUsers()\n    ->Where(['username' => 'chad'])\n    ->getLdapQuery()\n    ->getSingleScalarOrNullResult();\n\n// Check if the attribute actually had a value first\n$title = $title ?: 'Unknown';\n\necho $title;",
            "title": "LdapQuery Methods to Retrieve LDAP Results"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#filter-method-shortcuts",
            "text": "The  filter()  method of the  LdapQueryBuilder  returns a helper class that provides many shortcut methods for creating\nthe LDAP operator classes within the  \\LdapTools\\Query\\Operator  namespace. This way you do not have to manually\nconstruct the operators by doing:  use \\LdapTools\\Query\\Operator\\bOr;\nuse \\LdapTools\\Query\\Operator\\Comparison;\n\n// ...\n$lqb->where(new bOr(\n    new Comparison('firstName', Comparison::EQ, 'Bill'),\n    new Comparison('firstName', Comparison::EQ, 'Egon')\n));  Instead you can write:  $lqb->where($lqb->filter()->or(\n    $lqb->filter()->eq('firstName', 'Bill'),\n    $lqb->filter()->eq('firstName', 'Egon')\n));  When you call  filter()  you are just calling a method on the  \\LdapTools\\Query\\Builder\\FilterBuilder  class. The full \nlist and description of available methods is below.   aeq($attribute, $value)  Creates an \"approximately-equal-to\" comparison between the attribute and the value. The results are dependent on the\nLDAP specific implementation of this operator. But it will typically function as a \"sounds like\" comparison:  (attribute~=value)  $lqb->filter()->aeq('firstName', 'Sue');   eq($attribute, $value)  Creates an \"equal-to\" comparison between the attribute and the value:  (attribute=value)  $lqb->filter()->eq('lastName', 'Sikorra');   neq($attribute, $value)  Creates a \"not-equal-to\" comparison between the attribute and the value. This is equivalent to wrapping a\n  eq($attribute, $value)  within a 'NOT' statement:  (!(attribute=value))  $lqb->filter()->neq('department', 'Purchasing');   lt($attribute, $value)  Creates a \"less-than\" comparison between the attribute and the value. Since an actual '<' operator does not exist in \nLDAP, this is a combination of a greater-than-or-equal-to operator along with a check if the attribute is set/present.\nThis is encapsulated within a logical 'AND' operator:  (&(!(attribute>=value))(attribute=*))  $lqb->filter()->lt('badPasswordCount', 2);   leq($attribute, $value)  Creates a \"less-than-or-equal-to\" comparison between the attribute and the value:  (attribute<=value)  $lqb->filter()->leq('badPasswordCount', 1);   gt($attribute, $value)  Creates a \"greater-than\" comparison between the attribute and the value. Since an actual '>' operator does not exist in \nLDAP, this is a combination of a less-than-or-equal-to operator along with a check if the attribute is set/present.\nThis is encapsulated within a logical 'AND' operator:  (&(!(attribute<=value))(attribute=*))  $lqb->filter()->gt('created', new \\DateTime('01-20-2013'));   geq($attribute, $value)  Creates a \"greater-than-or-equal-to\" comparison between the attribute and the value:  (attribute>=value)  $lqb->filter()->geq('badPasswordCount', 3);   bitwiseAnd($attribute, $value)  Creates a bitwise 'AND' comparison between the attribute and the value:  (attribute:1.2.840.113556.1.4.803:=value)  use LdapTools\\Query\\UserAccountControlFlags;\n\n$lqb->filter()->bitwiseAnd('userAccountControl', UserAccountControlFlags::DISABLED);   bitwiseOr($attribute, $value)  Creates a bitwise 'OR' comparison between the attribute and the value:  (attribute:1.2.840.113556.1.4.804:=value)  use LdapTools\\Query\\GroupTypeFlags;\n\n$lqb->filter()->bitwiseOr('groupType', GroupTypeFlags::UNIVERSAL_GROUP);   startsWith($attribute, $value)  Creates a \"equal-to\" comparison with a wildcard after the value:  (attribute=value*)  $lqb->filter()->startsWith('department', 'IT');   endsWith($attribute, $value)  Creates a \"equal-to\" comparison with a wildcard before the value:  (attribute=*value)  $lqb->filter()->endsWith('description', 'service');   contains($attribute, $value)  Creates a \"equal-to\" comparison with a wildcards at each end of the value:  (attribute=*value*)  $lqb->filter()->contains('name', 'admin');   like($attribute, $value)  Creates a \"equal-to\" comparison that will not escape any wildcards you use in the value:  (attribute=v*a*l*u*e) .  $lqb->filter()->like('description', '*Some*thing*');   present($attribute)  Creates a \"equal-to\" comparison with a single wildcard as the value. Returns any entry with this attribute populated:  (attribute=*)  $lqb->filter()->present('mail');   notPresent($attribute)  Creates a negated form of the  present($attribute)  method. Returns any entry that does not contain the attribute:  (!(attribute=*))  $lqb->filter()->notPresent('department');   bAnd(...$statements)  Creates a logical 'AND' statement against all other operators passed to it:  (&((attribute=value)(attribute=value)))  $lqb->filter()->bAnd(\n    $lqb->filter()->eq('department', 'IT'), \n    $lqb->filter()->startsWith('firstName', 'Tim')\n);   bOr(...$statements)  Creates a logical 'OR' statement against all other operators passed to it:  (|((attribute=value)(attribute=value)))  $lqb->filter()->bOr(\n    $lqb->filter()->eq('department', 'IT'), \n    $lqb->filter()->eq('department', 'Purchasing')\n);   bNot($statements)  Creates a logical 'NOT' statement against whatever other statement you pass it it:  (!(attribute=value))  $lqb->filter()->bNot($lqb->filter()->eq('department', 'IT'));",
            "title": "Filter Method Shortcuts"
        },
        {
            "location": "/tutorials/Building-LDAP-Queries/#active-directory-filter-method-shortcuts",
            "text": "If you're using a  LdapConnection  that has a LDAP type set as  ad , then when you call  filter()  you will also have\nadditional filter method shortcuts that are specific to Active Directory:   hasMemberRecursively($member, $attribute = 'members')   Recursively checks groups for a specific member. The  $member  parameter can be any of the following:   A username. This must be unique! If a computer and user share the same name then an exception will be thrown.  The GUID of an object (ie. a value like  bee66f2f-bcf7-4905-b65b-2f36d5008f1e )  The SID of an object (ie. a value like  S-1-5-21-1004336348-1177238915-682003330-512 )  The full distinguished name of an object.  A  LdapObject  as the result of another query.   This creates a matching rule comparison using the OID  IN_CHAIN  against the groups  members  attribute by default. If\nyou have a custom attribute, or some other attribute you would like to run it against, you must pass it as the second\nargument.  $username = 'chad';\n\n// Query by a username to get all of their groups recursively...\n$groups = $ldap->buildLdapQuery()\n    ->fromGroups()\n    ->where($query->filter()->hasMemberRecursively($username))\n    ->getLdapQuery()\n    ->getResult();   isRecursivelyMemberOf($group)  Recursively checks an object's group membership for a group. The  $group  parameter can be any of the following:   The name of a group.  The GUID of a group (ie. a value like  bee66f2f-bcf7-4905-b65b-2f36d5008f1e )  The SID of a group (ie. a value like  S-1-5-21-1004336348-1177238915-682003330-512 )  The full distinguished name of a group.  A  LdapObject  as the result of another query.   This creates a matching rule comparison using the OID  IN_CHAIN  against the users  groups  attribute.  // Query by a group name...\n$query = $ldap->buildLdapQuery();\n$users = $query->select()\n    ->fromUsers()\n    ->where($query->filter()->isRecursivelyMemberOf('Employees'))\n    ->getLdapQuery()\n    ->getResult();\n\n// If you are not targeting a specific set of objects from the schema, then you must\n// pass 'false' as the second argument and specify a full DN. Otherwise this method\n// will attempt to use the 'groups' attribute from the schema by default.\n$ldapObjects = $ldap->buildLdapQuery()\n    ->select('description')\n    ->where(['cn' => 'foo'])\n    ->andWhere($query->filter()->isRecursivelyMemberOf('CN=Foo,DC=foo,DC=bar', false))\n    ->getLdapQuery()\n    ->getResult();   mailEnabled()   Performs a simple check to determine whether an LDAP object is mail-enabled (ie. can receive email from Exchange).",
            "title": "Active Directory Filter Method Shortcuts"
        },
        {
            "location": "/tutorials/Creating-AD-Password-Settings-Objects/",
            "text": "Creating AD Password Settings Objects (PSOs)\n\n\n\n\nPassword Settings Objects were introduced in Windows Server 2008 as part of the Fine Grained Password Policy changes.\nThese are objects that you can create to apply to security groups (recommended) or directly to users. This allows you to\ndefine multiple password policies in a domain where as prior to this you were limited to what could be defined in the \nDefault Domain Policy.\n\n\nThe PSOs can be easily created using a schema definition called \nPSO\n:\n\n\nuse LdapTools\\Configuration;\nuse LdapTools\\Utilities\\ADTimeSpan;\nuse LdapTools\\LdapManager;\n\n$config = (new Configuration())->load('/path/to/my/ldap.yml');\n$ldap = new LdapManager($config);\n\n// Create a basic PSO.\n$ldap->createLdapObject()\n    ->create('PSO')\n    ->with([\n        'name' => 'Employee Password Policy',\n        'precedence' => 5,\n        'lockoutDuration' => (new ADTimeSpan())->setMinutes(30),\n        'lockoutObservationWindow' => (new ADTimeSpan())->setMinutes(30),\n        'lockoutThreshold' => 6,\n        'maximumPasswordAge' => (new ADTimeSpan())->setDays(90),\n        'minimumPasswordAge' => (new ADTimeSpan())->setDays(3),\n        'minimumPasswordLength' => 8,\n        'passwordComplexity' => true,\n        'passwordHistoryLength' => 10,\n    ])\n    ->execute();\n\n// Create a more restrictive PSO tied to a specific security group.\n$ldap->createLdapObject()\n    ->create('PSO')\n    ->with([\n        'name' => 'Admin Password Policy',\n        'precedence' => 1,\n        'lockoutDuration' => (new ADTimeSpan())->setMinutes(60),\n        'lockoutObservationWindow' => (new ADTimeSpan())->setMinutes(60),\n        'lockoutThreshold' => 3,\n        'maximumPasswordAge' => (new ADTimeSpan())->setDays(60),\n        'minimumPasswordAge' => (new ADTimeSpan())->setDays(3),\n        'minimumPasswordLength' => 12,\n        'passwordComplexity' => true,\n        'passwordHistoryLength' => 10,\n        'appliesTo' => 'Network Administrators'     // This can be the name, SID, or GUID of a security group\n    ])\n    ->execute();\n\n\n\n\nUnlike other default schema types, you do NOT have to specify a default OU/container for this object type. It will be\nautomatically placed in the \nPassword Settings Container\n within your domain's system container. \n\n\nDefining Time Spans and Durations\n\n\nThe time span values (lockout duration, password age, etc) are defined by using a special object \n\\LdapTools\\Utilities\\ADTimeSpan\n.\nThis class can be instantiated to create many different time representations:\n\n\nuse LdapTools\\Utilities\\ADTimeSpan;\n\n// All of these values are cumulative.\n$adTimeSpan = (new ADTimeSpan())\n    ->setDays(30)\n    ->setHours(5)\n    ->setMinutes(30)\n    ->setSeconds(10);\n\n// Specify a 'Never' time span. Such as a lockout duration that NEVER expires.\n// While not necessarily recommended, this can be done by doing the following.\n$adTimeSpan = (new ADTimeSpan())->setNever(true);\n\n// Specify no values to keep it as '0' which is interpreted as 'None' for some attributes.\n$adTimeSpan = new ADTimeSpan();",
            "title": "Creating AD Password Settings Objects"
        },
        {
            "location": "/tutorials/Creating-AD-Password-Settings-Objects/#creating-ad-password-settings-objects-psos",
            "text": "Password Settings Objects were introduced in Windows Server 2008 as part of the Fine Grained Password Policy changes.\nThese are objects that you can create to apply to security groups (recommended) or directly to users. This allows you to\ndefine multiple password policies in a domain where as prior to this you were limited to what could be defined in the \nDefault Domain Policy.  The PSOs can be easily created using a schema definition called  PSO :  use LdapTools\\Configuration;\nuse LdapTools\\Utilities\\ADTimeSpan;\nuse LdapTools\\LdapManager;\n\n$config = (new Configuration())->load('/path/to/my/ldap.yml');\n$ldap = new LdapManager($config);\n\n// Create a basic PSO.\n$ldap->createLdapObject()\n    ->create('PSO')\n    ->with([\n        'name' => 'Employee Password Policy',\n        'precedence' => 5,\n        'lockoutDuration' => (new ADTimeSpan())->setMinutes(30),\n        'lockoutObservationWindow' => (new ADTimeSpan())->setMinutes(30),\n        'lockoutThreshold' => 6,\n        'maximumPasswordAge' => (new ADTimeSpan())->setDays(90),\n        'minimumPasswordAge' => (new ADTimeSpan())->setDays(3),\n        'minimumPasswordLength' => 8,\n        'passwordComplexity' => true,\n        'passwordHistoryLength' => 10,\n    ])\n    ->execute();\n\n// Create a more restrictive PSO tied to a specific security group.\n$ldap->createLdapObject()\n    ->create('PSO')\n    ->with([\n        'name' => 'Admin Password Policy',\n        'precedence' => 1,\n        'lockoutDuration' => (new ADTimeSpan())->setMinutes(60),\n        'lockoutObservationWindow' => (new ADTimeSpan())->setMinutes(60),\n        'lockoutThreshold' => 3,\n        'maximumPasswordAge' => (new ADTimeSpan())->setDays(60),\n        'minimumPasswordAge' => (new ADTimeSpan())->setDays(3),\n        'minimumPasswordLength' => 12,\n        'passwordComplexity' => true,\n        'passwordHistoryLength' => 10,\n        'appliesTo' => 'Network Administrators'     // This can be the name, SID, or GUID of a security group\n    ])\n    ->execute();  Unlike other default schema types, you do NOT have to specify a default OU/container for this object type. It will be\nautomatically placed in the  Password Settings Container  within your domain's system container.",
            "title": "Creating AD Password Settings Objects (PSOs)"
        },
        {
            "location": "/tutorials/Creating-AD-Password-Settings-Objects/#defining-time-spans-and-durations",
            "text": "The time span values (lockout duration, password age, etc) are defined by using a special object  \\LdapTools\\Utilities\\ADTimeSpan .\nThis class can be instantiated to create many different time representations:  use LdapTools\\Utilities\\ADTimeSpan;\n\n// All of these values are cumulative.\n$adTimeSpan = (new ADTimeSpan())\n    ->setDays(30)\n    ->setHours(5)\n    ->setMinutes(30)\n    ->setSeconds(10);\n\n// Specify a 'Never' time span. Such as a lockout duration that NEVER expires.\n// While not necessarily recommended, this can be done by doing the following.\n$adTimeSpan = (new ADTimeSpan())->setNever(true);\n\n// Specify no values to keep it as '0' which is interpreted as 'None' for some attributes.\n$adTimeSpan = new ADTimeSpan();",
            "title": "Defining Time Spans and Durations"
        },
        {
            "location": "/tutorials/Creating-LDAP-Objects/",
            "text": "Creating LDAP Objects\n\n\n\n\n\n\nUsing Parameters\n\n\nCreator Methods\n\n\n\n\nThe \nLdapObjectCreator\n class provides an easy method for creating LDAP objects. It can accessed directly from the LDAP\nManager and provides shortcuts and helpers for creating Users, Groups, Contacts, and Computers using the default schema.\nIt also supports setting parameters within attribute values to avoid repetition.\n\n\nTo get an instance of the object creator class and create some objects:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n// Optionally pass an object type directly when getting the creator instance...\n$ldap->createLdapObject(LdapObjectType::USER)\n    ->with(['username' => 'foo', 'password' => 'bar'])\n    ->in('dc=example,dc=local')\n    ->execute();\n\n$ldapObject = $ldap->createLdapObject();\n\n// Creating a user account (enabled by default)\n$ldapObject->createUser()\n    ->in('cn=Users,dc=example,dc=local')\n    ->with(['username' => 'jsmith', 'password' => '12345'])\n    ->execute();\n\n// Create a typical AD global security group...\n$ldapObject->createGroup()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Generic Security Group'])\n    ->execute();\n\n// Creates a contact user...\n$ldapObject->createContact()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Some Guy', 'emailAddress' => 'SomeGuy@SomeDomain.com'])\n    ->execute();\n\n// Creates a computer object...\n$ldapObject->createComputer()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'MYWOKRSTATION'])\n    ->execute();\n\n// Creates an OU object...\n$ldapObject->createOU()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Employees'])\n    ->execute();\n\n// Create an object by passing the schema type name to the create method...\n$ldapObject->create('user')\n    ->in('dc=example,dc=local')\n    ->with(['username' => 'Foo', 'password' => 'correct-horse-battery-staple'])\n    ->execute();\n\n\n\n\n\nUsing Parameters in Attribute Values\n\n\n\n\nWhen you create a generic \nuser\n, \ngroup\n, \ncontact\n, etc there are very few values you need to explicitly set for them\nto be created. Part of the reason for this is that the schema is leveraging parameters to fill in values for the rest of\nthe required attributes. You can use parameters to fill in attribute values based off other attributes, or any value you\nwant. For instance:\n\n\n$ldapObject = $ldap->createLdapObject();\n\n$ldapObject->createContact()\n    ->in('%OUPath%,%_defaultnamingcontext_%')\n    ->with([\n        'name' => '%firstname% %lastname%',\n        'firstName' => 'Some',\n        'lastName' => 'Guy',\n        'emailAddress' => '%firstname%.%lastname%@%somedomain%'\n    ])\n    ->setParameter('somedomain','foo.bar')\n    ->setParameter('OUPath','OU=Sales,OU=Departments')\n    ->execute();\n\n\n\n\nThis contains several parameters. All parameters start and end with a percentage symbol. The \n%firstname%\n and \n%lastname%\n\nparameters will populate their value with their corresponding attribute name. However, \n%somedomain%\n and \n%OUPath%\n do\nnot correspond to a known attribute, so the parameter must be defined. It will be filled in with \nfoo.bar\n and\n\nOU=Sales,OU=Departments\n, respectively.\n\n\nThere is also a special parameter for \n%_domainname_%\n and \n%_defaultnamingcontext_%\n when creating LDAP objects. The \n\n%_domainname_%\n will resolve to the fully qualified domain name of the connection in the current context (ie. \n\nexample.com\n). The \n%_defaultnamingcontext_%\n will resolve the the base distinguished name of the domain (ie. \n\ndc=example,dc=com\n).\n\n\nLdapObjectCreator Methods\n\n\nThis class provides a few methods to make it easier to create LDAP objects.\n\n\n\n\nin($container)\n\n\nThe \nin\n method specifies the container/OU you want to place the LDAP object. It should be a string with the common LDAP\ndistinguished name form (ie. \nou=users,dc=mydomain,dc=com\n).\n\n\nYou can also specify a default location all objects of a certain type by defining the \ndefault_container\n directive in \nyour schema (see \nthe schema configuration reference\n). If you define that can omit this method.\nYou can also place parameters in this value that will be resolved upon creation (ie. \nOU=%department%,%EmployeeOU%,DC=example,DC=com\n).\nYou can use LDAP object attributes for parameters in this string as well.\n\n\n\n\nwith($attributes)\n\n\nThis specifies the attributes and values you would like for the object to have once created in LDAP. All attribute values are\nconverted and renamed to their proper LDAP form based on your schema. To check the name mappings and expected value types\nsee the \ndefault schema attributes\n documentation.\n\n\n\n\nsetDn($container)\n\n\nThis method allows you to explicitly set the distinguished name for the object you are creating. Typically you should\nnot have to call this. The DN is determined automatically based off the \nname\n attribute in your schema, and the\nlocation you specified with the \nin($container)\n method.\n\n\n\n\nsetParameter($name, $value)\n\n\nThis allows you to set any parameter you want that you can later use within an attribute value to have it resolve to the\nparameter value. See the full explanation of parameters near the start of this document. If you simply want to use the\nvalue of a separate attribute name then there is no reason to set it here, as all attribute names you define values in\nare also available as parameters automatically.\n\n\n\n\ncreateUser()\n\n\nThis specifies that the resulting object should be a user LDAP object type.\n\n\n\n\ncreateGroup()\n\n\nThis specifies that the resulting object should be a group LDAP object type.\n\n\n\n\ncreateOU()\n\n\nThis specifies that the resulting object should be an OU LDAP object type.\n\n\n\n\ncreateComputer()\n\n\nThis specifies that the resulting object should be a computer LDAP object type.\n\n\n\n\ncreateContact()\n\n\nThis specifies that the resulting object should be a contact LDAP object type.\n\n\n\n\ncreate($type)\n\n\nThis allows you to manually specify a LDAP object type from the schema that you would like to create. This is the method\nthat all the other shorthand \ncreate*\n methods actually call. \n\n\n\n\nsetServer($server)\n\n\nThis lets you set the LDAP server that the LDAP object will be initially created on. This switches the connections LDAP\nserver during execution and then switches back to the LDAP server you were originally connected to afterwards.\n\n\n\n\nexecute()\n\n\nTakes all of your set attributes, parameters, OU location, etc and adds the object to LDAP. If an issue is encountered\nwhile adding to LDAP it will throw an exception...\n\n\nuse LdapTools\\Exception\\LdapConnectionException;\n\n//...\n\n$ldapObject = $ldapManager->createLdapObject();\n\n// Creating a user account (enabled by default) with a few group memberships\ntry {\n    $object->createUser()\n        ->in('cn=Users,dc=example,dc=local')\n        ->with(['username' => 'jsmith', 'password' => '12345', 'groups' => ['Employees', 'IT Staff', 'VPN Users']])\n        ->execute();\n} catch (LdapConnectionException $e) {\n    echo \"Failed to add user!\".PHP_EOL;\n    echo $e->getMessage().PHP_EOL;\n}",
            "title": "Creating LDAP Objects"
        },
        {
            "location": "/tutorials/Creating-LDAP-Objects/#creating-ldap-objects",
            "text": "Using Parameters  Creator Methods   The  LdapObjectCreator  class provides an easy method for creating LDAP objects. It can accessed directly from the LDAP\nManager and provides shortcuts and helpers for creating Users, Groups, Contacts, and Computers using the default schema.\nIt also supports setting parameters within attribute values to avoid repetition.  To get an instance of the object creator class and create some objects:  use LdapTools\\Object\\LdapObjectType;\n\n// Optionally pass an object type directly when getting the creator instance...\n$ldap->createLdapObject(LdapObjectType::USER)\n    ->with(['username' => 'foo', 'password' => 'bar'])\n    ->in('dc=example,dc=local')\n    ->execute();\n\n$ldapObject = $ldap->createLdapObject();\n\n// Creating a user account (enabled by default)\n$ldapObject->createUser()\n    ->in('cn=Users,dc=example,dc=local')\n    ->with(['username' => 'jsmith', 'password' => '12345'])\n    ->execute();\n\n// Create a typical AD global security group...\n$ldapObject->createGroup()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Generic Security Group'])\n    ->execute();\n\n// Creates a contact user...\n$ldapObject->createContact()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Some Guy', 'emailAddress' => 'SomeGuy@SomeDomain.com'])\n    ->execute();\n\n// Creates a computer object...\n$ldapObject->createComputer()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'MYWOKRSTATION'])\n    ->execute();\n\n// Creates an OU object...\n$ldapObject->createOU()\n    ->in('dc=example,dc=local')\n    ->with(['name' => 'Employees'])\n    ->execute();\n\n// Create an object by passing the schema type name to the create method...\n$ldapObject->create('user')\n    ->in('dc=example,dc=local')\n    ->with(['username' => 'Foo', 'password' => 'correct-horse-battery-staple'])\n    ->execute();",
            "title": "Creating LDAP Objects"
        },
        {
            "location": "/tutorials/Creating-LDAP-Objects/#using-parameters-in-attribute-values",
            "text": "When you create a generic  user ,  group ,  contact , etc there are very few values you need to explicitly set for them\nto be created. Part of the reason for this is that the schema is leveraging parameters to fill in values for the rest of\nthe required attributes. You can use parameters to fill in attribute values based off other attributes, or any value you\nwant. For instance:  $ldapObject = $ldap->createLdapObject();\n\n$ldapObject->createContact()\n    ->in('%OUPath%,%_defaultnamingcontext_%')\n    ->with([\n        'name' => '%firstname% %lastname%',\n        'firstName' => 'Some',\n        'lastName' => 'Guy',\n        'emailAddress' => '%firstname%.%lastname%@%somedomain%'\n    ])\n    ->setParameter('somedomain','foo.bar')\n    ->setParameter('OUPath','OU=Sales,OU=Departments')\n    ->execute();  This contains several parameters. All parameters start and end with a percentage symbol. The  %firstname%  and  %lastname% \nparameters will populate their value with their corresponding attribute name. However,  %somedomain%  and  %OUPath%  do\nnot correspond to a known attribute, so the parameter must be defined. It will be filled in with  foo.bar  and OU=Sales,OU=Departments , respectively.  There is also a special parameter for  %_domainname_%  and  %_defaultnamingcontext_%  when creating LDAP objects. The  %_domainname_%  will resolve to the fully qualified domain name of the connection in the current context (ie.  example.com ). The  %_defaultnamingcontext_%  will resolve the the base distinguished name of the domain (ie.  dc=example,dc=com ).",
            "title": "Using Parameters in Attribute Values"
        },
        {
            "location": "/tutorials/Creating-LDAP-Objects/#ldapobjectcreator-methods",
            "text": "This class provides a few methods to make it easier to create LDAP objects.   in($container)  The  in  method specifies the container/OU you want to place the LDAP object. It should be a string with the common LDAP\ndistinguished name form (ie.  ou=users,dc=mydomain,dc=com ).  You can also specify a default location all objects of a certain type by defining the  default_container  directive in \nyour schema (see  the schema configuration reference ). If you define that can omit this method.\nYou can also place parameters in this value that will be resolved upon creation (ie.  OU=%department%,%EmployeeOU%,DC=example,DC=com ).\nYou can use LDAP object attributes for parameters in this string as well.   with($attributes)  This specifies the attributes and values you would like for the object to have once created in LDAP. All attribute values are\nconverted and renamed to their proper LDAP form based on your schema. To check the name mappings and expected value types\nsee the  default schema attributes  documentation.   setDn($container)  This method allows you to explicitly set the distinguished name for the object you are creating. Typically you should\nnot have to call this. The DN is determined automatically based off the  name  attribute in your schema, and the\nlocation you specified with the  in($container)  method.   setParameter($name, $value)  This allows you to set any parameter you want that you can later use within an attribute value to have it resolve to the\nparameter value. See the full explanation of parameters near the start of this document. If you simply want to use the\nvalue of a separate attribute name then there is no reason to set it here, as all attribute names you define values in\nare also available as parameters automatically.   createUser()  This specifies that the resulting object should be a user LDAP object type.   createGroup()  This specifies that the resulting object should be a group LDAP object type.   createOU()  This specifies that the resulting object should be an OU LDAP object type.   createComputer()  This specifies that the resulting object should be a computer LDAP object type.   createContact()  This specifies that the resulting object should be a contact LDAP object type.   create($type)  This allows you to manually specify a LDAP object type from the schema that you would like to create. This is the method\nthat all the other shorthand  create*  methods actually call.    setServer($server)  This lets you set the LDAP server that the LDAP object will be initially created on. This switches the connections LDAP\nserver during execution and then switches back to the LDAP server you were originally connected to afterwards.   execute()  Takes all of your set attributes, parameters, OU location, etc and adds the object to LDAP. If an issue is encountered\nwhile adding to LDAP it will throw an exception...  use LdapTools\\Exception\\LdapConnectionException;\n\n//...\n\n$ldapObject = $ldapManager->createLdapObject();\n\n// Creating a user account (enabled by default) with a few group memberships\ntry {\n    $object->createUser()\n        ->in('cn=Users,dc=example,dc=local')\n        ->with(['username' => 'jsmith', 'password' => '12345', 'groups' => ['Employees', 'IT Staff', 'VPN Users']])\n        ->execute();\n} catch (LdapConnectionException $e) {\n    echo \"Failed to add user!\".PHP_EOL;\n    echo $e->getMessage().PHP_EOL;\n}",
            "title": "LdapObjectCreator Methods"
        },
        {
            "location": "/tutorials/LDIF-Files/",
            "text": "LDIF Files\n\n\n\n\n\n\nLDIF Parsing\n\n\nLDIF URL Loaders\n\n\nLDIF Creation\n\n\nThe LDIF Object\n\n\nLDIF Line Endings\n\n\nLine Folding and Max Line Length\n\n\n\n\nLdapTools provides an easy method to both parse and create LDIF files. The parser is able to take a LDIF string and\nreturn an object that allows you to get all the entries it contains. From the object you can get all the LDAP operations\nrepresented by those entries and enter them into LDAP. You also have the ability to build a LDIF file in an \nobject-oriented way and then output the result to a LDIF string.\n\n\nLDIF Parsing\n\n\nTo parse a LDIF file you can pass the contents of it to the parser then do what you need with the LDIF object returned:\n\n\nuse LdapTools\\Ldif\\LdifParser;\nuse LdapTools\\Exception\\LdifParserException;\n\n$parser = new LdifParser();\n\ntry {\n    $ldif = $parser->parse(file_get_contents('/path/to/ldif.txt'));\n} catch (LdifParserException $e) {\n    echo \"Error Parsing LDIF: \".$e->getMessage();\n}\n\n// Assuming $ldap is your LdapManager instance, execute the LDIF entries into LDAP...\nforeach ($ldif->toOperations() as $operation) {\n    $ldap->getConnection()->execute($operation);\n}\n\n\n\n\nLDIF URL Loaders\n\n\nIn a LDIF file you can specify the data of an attributes value from a remote source using a URL format such as:\n\n\ndescription:< file:///some/path/to/data.txt\n\n\n\n\nThe valid default URL types recognized by the parser are: \nfile\n, \nhttp\n, and \nhttps\n. You can implement your own URL\nloader by creating a class that implements \nLdapTools\\Ldif\\UrlLoader\\UrlLoaderInterface\n. The only needed method to be\nimplemented is \nload($url)\n. You can then add the URL loader to the parser using the \nsetUrlLoader($type, $loader)\n\nmethod.\n\n\nuse LdapTools\\Ldif\\LdifParser;\n\n$parser = new LdifParser();\n\n// Add a custom URL loader. The $type is the string at the beginning of the URL, such as 'file' or 'http'.\n// The $loader is your constructed class that implements 'LdapTools\\Ldif\\UrlLoader\\UrlLoaderInterface'.\n$parser->setUrlLoader($type, $loader);\n\n// Remove a URL loader by type if you don't want it to be supported...\n$parser->removeUrlLoader($type);\n\n// Check if a URL loader for a specific type exists...\nif ($parser->hasUrlLoader($type)) {\n   // do something...\n}\n\n\n\n\nLDIF Creation\n\n\nYou can easily construct LDIF files by using a few classes. The easiest way to construct a LDIF file is in the context\nof your LDAP manager object:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n// Assuming $ldap is your LdapManager instance. \n// The 'add' and 'modify' LDIF entries are schema aware when you constructed using your LdapManager...\n$ldif = $ldap->createLdif();\n\n$userEntry = $ldif->entry()->add()\n    ->setType(LdapObjectType::USER)\n    ->setAttributes(['username' => 'Jimmy', 'password' => '12345'])\n    ->setLocation('ou=employees,dc=example,dc=local');\n\n$ldif->addEntry(\n    $userEntry,\n    $ldif->entry()->delete('cn=Some User,dc=foo,dc=bar'),\n    $ldif->entry()->move('cn=Frank,dc=foo,dc=bar', 'ou=Employees,dc=foo,dc=bar')\n);\n\n// Output the LDIF object as a string to a file.\nfile_put_contents('/path/to/ldif.txt', $ldif->toString());\n\n\n\n\nHowever, you can also build LDIF files by just constructing the class and passing whatever you want:\n\n\nuse LdapTools\\Ldif\\Ldif;\n\n$ldif = new Ldif();\n\n$ldif->addEntry(\n    $ldif->entry()->add('cn=Some Group,dc=foo,dc=bar', [\n        'sAMAccountName' => 'Some Group',\n        'objectClass' => 'group'\n    ]),\n    $ldif->entry()->delete('cn=Some User,dc=foo,dc=bar'),\n    $ldif->entry()->move(\n        'cn=Frank,dc=foo,dc=bar',\n        'ou=Employees,dc=foo,dc=bar'\n    )\n);\n\n// Output the LDIF object as a string to a file.\nfile_put_contents('/path/to/ldif.txt', $ldif->toString());\n\n\n\n\nThe above is the general method for creating a LDIF file. But there are a lot of the methods and options available.\nBelow is a summary of some of the objects and methods involved and how to use them.\n\n\n\n\nThe LDIF Object\n\n\nThe LDIF object is used to represent the LDIF file in its entirety. When you parse a LDIF file via the parser it returns\nthis object. Likewise, you can construct a LDIF object to get the LDIF string representation from it.\n\n\nuse LdapTools\\Ldif\\Ldif;\n\n// Construct the LDIF object...\n$ldif = new Ldif();\n\n// By default the LDIF version is set to '1' to follow the RFC. \n// You can remove it by setting it to null.\n$ldif->setVersion(null);\n\n// Add a few comments to appear at the top of the LDIF...\n$ldif->addComment('This is just a test LDIF file', 'Created on '.date(\"m.d.y\"));\n\n// Create a new entry for the LDIF by using the helper 'entry()' method.\n// This creates an entry that will add a new object to LDAP.\n$entry = $ldif->entry()->add('cn=Some User,dc=example,dc=local')->addAttribute('sn', 'Sikorra');\n\n// Add the created entry to the LDIF. This method is variadic, so add as many entries at a time as you like.\n$ldif->addEntry($entry);\n\n// Output the LDIF to a string and do whatever you need with it...\n$ldifData = $ldif->toString();\necho $ldifData;\n\n\n\n\nThe LDIF Delete Entry Type\n\n\nThe delete entry type is a \ndelete\n changetype in LDIF. It is used to delete an object from LDAP. All you need to\ndo is pass it the full DN of the object you'd like to delete.\n\n\nuse LdapTools\\Ldif\\Entry\\LdifDeleteEntry;\n\n$dn = 'cn=foo,dc=example,dc=local';\n\n// Either construct it on your own...\n$delete = new LdifEntryDelete($dn);\n\n// Or construct it with the helper method on the LDIF object...\n$delete = $ldif->entry()->delete($dn);\n\n\n\n\nThe LDIF Add Entry Type\n\n\nThe add entry type is an 'add' changetype in LDIF. It is used to add a new object to LDAP. It needs the full DN\nand all the attributes.\n\n\nuse LdapTools\\Ldif\\Entry\\LdifEntryAdd;\n\n$dn = 'cn=foo,dc=example,dc=local';\n$attributes = [\n    'objectclass' => ['top', 'person', 'organizationalPerson'],\n    'cn' => 'Barbara Jensen',\n    'sn' => 'Jensen',\n    'uid' => 'bjensen',\n    'telephonenumber' => '+1 408 555 1212',\n    'description' => \"Peon\",\n    'title' => 'Awesome Stuff',\n];\n\n// Construct the entry on your own...\n$add = new LdifEntryAdd($dn, $attributes);\n\n// Or construct it with the helper method on the LDIF object...\n$add = $ldif->entry()->add($dn)->setAttributes($attributes);\n\n// Construct the entry from the helper method and use the methods on the add entry type to add individual attributes...\n$add = $ldif->entry()->add($dn)\n    ->addAttribute('objectClass', ['top', 'person', 'organizationalPerson'])\n    ->addAttribute('sn', 'Jensen')\n    ->addAttribute('description', 'Peon');\n\n\n\n\nThe LDIF Modify Entry Type\n\n\nThe modify entry type is a 'modify' changetype in LDIF. You can use this to modify an already existing object in LDAP.\n\n\nuse LdapTools\\Ldif\\Entry\\LdifEntryModify;\n\n$dn = 'cn=foo,dc=example,dc=local';\n\n// Construct it manually...\n$modify = new LdifEntryModify($dn);\n\n$modify->replace('description', 'Works at building 2') // Replace the contents of an attribute.\n    ->reset('title')                                   // Reset the attribute, which removes any value it has.\n    ->add('telephonenumber', '555-5555')               // Add a new value to an attribute.\n    ->delete('faxnumber', '222-2222');                 // Delete a specific attribute value. The value must exist.\n\n// Use the helper method on the LDIF object...\n$modify = $ldif->entry()->modify($dn)\n    ->delete('faxnumber', '222-2222')\n    ->replace('sn', 'Johnson');\n\n\n\n\n\nThe LDIF Mod DN Entry Type\n\n\nThe Mod DN entry type is a 'moddn' changetype in LDIF. This allows you to rename, move, or add to the DN of an object in\nLDAP.\n\n\nuse LdapTools\\Ldif\\Entry\\LdifEntryModDn;\n\n$dn = 'cn=foo,dc=example,dc=local';\n\n// Construct it manually...\n$moddn = new LdifEntryModDn($dn);\n\n// Move it to a new location. Specify the full DN of the new location:\n$moddn->setNewLocation('ou=employees,dc=example,dc=local');\n\n// Tell it that the old RDN from the previous location should be removed:\n$moddn->setDeleteOldRdn(true);\n\n// Set a new name (RDN) for the object (Needs to be in 'attribute=value' format!):\n$moddn->setNewName('cn=bar');\n\n// Constructing the entry using the helper method on the LDIF object...\n$moddn = $ldif->entry()->moddn($dn)\n    ->setNewLocation('ou=employees,dc=example,dc=local')\n    ->setDeleteOldRdn(true)\n    ->setNewName('cn=bar');\n\n\n\n\nThe LDIF Mod RDN Type\n\n\nThe Mod RDN type is implemented to adhere to RFC 2849. There is no functional difference between the 'modrdn' and 'moddn'\nchangetypes. The class for 'modrdn' simply extends the class for the 'moddn' type. The only difference being that when\nit is output as a LDIF string the changetype will be 'modrdn':\n\n\nuse LdapTools\\Ldif\\Entry\\LdifEntryModRdn;\n\n$modrdn = new LdifEntryModRdn('cn=foo,dc=example,dc=local');\n$modrdn->newLocation($someOU);\n\n// Outputs a 'changetype' of 'modrdn'...\necho $modrdn->toString();\n\n\n\n\nHelper Methods to Create LDIF Entries\n\n\nAn easy way to construct the LDIF entries is to use the 'entry()' method of the LDIF object. This takes care of some of\nthe manual object construction so you don't have to remember class names and produces a more fluent object-oriented\nmethod to build up the LDIF object.\n\n\nuse LdapTools\\Ldif\\Ldif;\n\n$ldif = new Ldif();\n\n// An entry to delete a LDAP object...\n$ldif->addEntry($ldif->entry()->delete('cn=user,dc=example,dc=local'));\n\n// An entry to add a new object to LDAP...\n$ldif->addEntry($ldif->entry()->add('cn=Josh,ou=employees,dc=example,dc=local')->setAttributes([\n    'objectclass' => ['top', 'person', 'organizationalPerson'],\n    'cn' => 'Josh Jensen',\n    'sn' => 'Jensen',\n    'uid' => 'jjensen',\n]));\n\n// Modify an existing LDAP object...\n$modify = $ldif->entry()->modify('cn=foo,dc=example,dc=local')\n    ->addAttribute('phonenumber', '555-5555')\n    ->replace('title', 'worker');\n$ldif->addEntry($modify);\n\n// Rename an object in LDAP...\n$ldif->addEntry($ldif->entry()->rename('cn=josh,dc=example,dc=local', 'cn=jill'));\n\n// Move an object in LDAP...\n$ldif->addEntry($ldif->entry()->move('cn=jill,dc=example,dc=local', 'ou=employees,dc=example,dc=local'));\n\n// Modify the DN of an LDAP object...\n$ldif->addEntry($ldif->entry()->moddn('cn=jill,ou=employees,dc=example,dc=local')->setNewRdn('cn=jill'));\n\n\n\n\nLDIF Line Endings\n\n\nBy default when you call \ntoString()\n on an LDIF object all of the line endings will be in Windows format (CRLF). If you\nwant to use Unix/Linux format (LF) you can use the \nsetLineEnding()\n method:\n\n\nuse LdapTools\\Ldif\\Ldif;\n\n$ldif = $ldap->createLdif();\n\n$ldif->setLineEnding(Ldif::LINE_ENDING['UNIX']);\n\n\n\n\nThis is mostly useful for compatibility purposes. Some utilities consuming the LDIF file may be expecting a certain line\nending in order to work correctly.\n\n\nLine Folding and Max Line Length\n\n\nBy default when you call \ntoString()\n on an LDIF object it will not fold any lines regardless of how long they are. If\nyou would like for the long lines to be folded and continued on the next line after a certain length (to improve the\nreadability of the file) you can use the \nsetLineFolding(true)\n and \nsetMaxLineLength($length)\n methods:\n\n\nuse LdapTools\\Ldif\\Ldif;\n\n$ldif = $ldap->createLdif();\n\n# Long line (including comments) will be broken into smaller chunks now...\n$ldif->setLineFolding(true);\n# Unless this is explicitly set, the max line length is 76 by default.\n$ldif->setMaxLineLength(100);",
            "title": "LDIF Files"
        },
        {
            "location": "/tutorials/LDIF-Files/#ldif-files",
            "text": "LDIF Parsing  LDIF URL Loaders  LDIF Creation  The LDIF Object  LDIF Line Endings  Line Folding and Max Line Length   LdapTools provides an easy method to both parse and create LDIF files. The parser is able to take a LDIF string and\nreturn an object that allows you to get all the entries it contains. From the object you can get all the LDAP operations\nrepresented by those entries and enter them into LDAP. You also have the ability to build a LDIF file in an \nobject-oriented way and then output the result to a LDIF string.",
            "title": "LDIF Files"
        },
        {
            "location": "/tutorials/LDIF-Files/#ldif-parsing",
            "text": "To parse a LDIF file you can pass the contents of it to the parser then do what you need with the LDIF object returned:  use LdapTools\\Ldif\\LdifParser;\nuse LdapTools\\Exception\\LdifParserException;\n\n$parser = new LdifParser();\n\ntry {\n    $ldif = $parser->parse(file_get_contents('/path/to/ldif.txt'));\n} catch (LdifParserException $e) {\n    echo \"Error Parsing LDIF: \".$e->getMessage();\n}\n\n// Assuming $ldap is your LdapManager instance, execute the LDIF entries into LDAP...\nforeach ($ldif->toOperations() as $operation) {\n    $ldap->getConnection()->execute($operation);\n}  LDIF URL Loaders  In a LDIF file you can specify the data of an attributes value from a remote source using a URL format such as:  description:< file:///some/path/to/data.txt  The valid default URL types recognized by the parser are:  file ,  http , and  https . You can implement your own URL\nloader by creating a class that implements  LdapTools\\Ldif\\UrlLoader\\UrlLoaderInterface . The only needed method to be\nimplemented is  load($url) . You can then add the URL loader to the parser using the  setUrlLoader($type, $loader) \nmethod.  use LdapTools\\Ldif\\LdifParser;\n\n$parser = new LdifParser();\n\n// Add a custom URL loader. The $type is the string at the beginning of the URL, such as 'file' or 'http'.\n// The $loader is your constructed class that implements 'LdapTools\\Ldif\\UrlLoader\\UrlLoaderInterface'.\n$parser->setUrlLoader($type, $loader);\n\n// Remove a URL loader by type if you don't want it to be supported...\n$parser->removeUrlLoader($type);\n\n// Check if a URL loader for a specific type exists...\nif ($parser->hasUrlLoader($type)) {\n   // do something...\n}",
            "title": "LDIF Parsing"
        },
        {
            "location": "/tutorials/LDIF-Files/#ldif-creation",
            "text": "You can easily construct LDIF files by using a few classes. The easiest way to construct a LDIF file is in the context\nof your LDAP manager object:  use LdapTools\\Object\\LdapObjectType;\n\n// Assuming $ldap is your LdapManager instance. \n// The 'add' and 'modify' LDIF entries are schema aware when you constructed using your LdapManager...\n$ldif = $ldap->createLdif();\n\n$userEntry = $ldif->entry()->add()\n    ->setType(LdapObjectType::USER)\n    ->setAttributes(['username' => 'Jimmy', 'password' => '12345'])\n    ->setLocation('ou=employees,dc=example,dc=local');\n\n$ldif->addEntry(\n    $userEntry,\n    $ldif->entry()->delete('cn=Some User,dc=foo,dc=bar'),\n    $ldif->entry()->move('cn=Frank,dc=foo,dc=bar', 'ou=Employees,dc=foo,dc=bar')\n);\n\n// Output the LDIF object as a string to a file.\nfile_put_contents('/path/to/ldif.txt', $ldif->toString());  However, you can also build LDIF files by just constructing the class and passing whatever you want:  use LdapTools\\Ldif\\Ldif;\n\n$ldif = new Ldif();\n\n$ldif->addEntry(\n    $ldif->entry()->add('cn=Some Group,dc=foo,dc=bar', [\n        'sAMAccountName' => 'Some Group',\n        'objectClass' => 'group'\n    ]),\n    $ldif->entry()->delete('cn=Some User,dc=foo,dc=bar'),\n    $ldif->entry()->move(\n        'cn=Frank,dc=foo,dc=bar',\n        'ou=Employees,dc=foo,dc=bar'\n    )\n);\n\n// Output the LDIF object as a string to a file.\nfile_put_contents('/path/to/ldif.txt', $ldif->toString());  The above is the general method for creating a LDIF file. But there are a lot of the methods and options available.\nBelow is a summary of some of the objects and methods involved and how to use them.   The LDIF Object  The LDIF object is used to represent the LDIF file in its entirety. When you parse a LDIF file via the parser it returns\nthis object. Likewise, you can construct a LDIF object to get the LDIF string representation from it.  use LdapTools\\Ldif\\Ldif;\n\n// Construct the LDIF object...\n$ldif = new Ldif();\n\n// By default the LDIF version is set to '1' to follow the RFC. \n// You can remove it by setting it to null.\n$ldif->setVersion(null);\n\n// Add a few comments to appear at the top of the LDIF...\n$ldif->addComment('This is just a test LDIF file', 'Created on '.date(\"m.d.y\"));\n\n// Create a new entry for the LDIF by using the helper 'entry()' method.\n// This creates an entry that will add a new object to LDAP.\n$entry = $ldif->entry()->add('cn=Some User,dc=example,dc=local')->addAttribute('sn', 'Sikorra');\n\n// Add the created entry to the LDIF. This method is variadic, so add as many entries at a time as you like.\n$ldif->addEntry($entry);\n\n// Output the LDIF to a string and do whatever you need with it...\n$ldifData = $ldif->toString();\necho $ldifData;  The LDIF Delete Entry Type  The delete entry type is a  delete  changetype in LDIF. It is used to delete an object from LDAP. All you need to\ndo is pass it the full DN of the object you'd like to delete.  use LdapTools\\Ldif\\Entry\\LdifDeleteEntry;\n\n$dn = 'cn=foo,dc=example,dc=local';\n\n// Either construct it on your own...\n$delete = new LdifEntryDelete($dn);\n\n// Or construct it with the helper method on the LDIF object...\n$delete = $ldif->entry()->delete($dn);  The LDIF Add Entry Type  The add entry type is an 'add' changetype in LDIF. It is used to add a new object to LDAP. It needs the full DN\nand all the attributes.  use LdapTools\\Ldif\\Entry\\LdifEntryAdd;\n\n$dn = 'cn=foo,dc=example,dc=local';\n$attributes = [\n    'objectclass' => ['top', 'person', 'organizationalPerson'],\n    'cn' => 'Barbara Jensen',\n    'sn' => 'Jensen',\n    'uid' => 'bjensen',\n    'telephonenumber' => '+1 408 555 1212',\n    'description' => \"Peon\",\n    'title' => 'Awesome Stuff',\n];\n\n// Construct the entry on your own...\n$add = new LdifEntryAdd($dn, $attributes);\n\n// Or construct it with the helper method on the LDIF object...\n$add = $ldif->entry()->add($dn)->setAttributes($attributes);\n\n// Construct the entry from the helper method and use the methods on the add entry type to add individual attributes...\n$add = $ldif->entry()->add($dn)\n    ->addAttribute('objectClass', ['top', 'person', 'organizationalPerson'])\n    ->addAttribute('sn', 'Jensen')\n    ->addAttribute('description', 'Peon');  The LDIF Modify Entry Type  The modify entry type is a 'modify' changetype in LDIF. You can use this to modify an already existing object in LDAP.  use LdapTools\\Ldif\\Entry\\LdifEntryModify;\n\n$dn = 'cn=foo,dc=example,dc=local';\n\n// Construct it manually...\n$modify = new LdifEntryModify($dn);\n\n$modify->replace('description', 'Works at building 2') // Replace the contents of an attribute.\n    ->reset('title')                                   // Reset the attribute, which removes any value it has.\n    ->add('telephonenumber', '555-5555')               // Add a new value to an attribute.\n    ->delete('faxnumber', '222-2222');                 // Delete a specific attribute value. The value must exist.\n\n// Use the helper method on the LDIF object...\n$modify = $ldif->entry()->modify($dn)\n    ->delete('faxnumber', '222-2222')\n    ->replace('sn', 'Johnson');  The LDIF Mod DN Entry Type  The Mod DN entry type is a 'moddn' changetype in LDIF. This allows you to rename, move, or add to the DN of an object in\nLDAP.  use LdapTools\\Ldif\\Entry\\LdifEntryModDn;\n\n$dn = 'cn=foo,dc=example,dc=local';\n\n// Construct it manually...\n$moddn = new LdifEntryModDn($dn);\n\n// Move it to a new location. Specify the full DN of the new location:\n$moddn->setNewLocation('ou=employees,dc=example,dc=local');\n\n// Tell it that the old RDN from the previous location should be removed:\n$moddn->setDeleteOldRdn(true);\n\n// Set a new name (RDN) for the object (Needs to be in 'attribute=value' format!):\n$moddn->setNewName('cn=bar');\n\n// Constructing the entry using the helper method on the LDIF object...\n$moddn = $ldif->entry()->moddn($dn)\n    ->setNewLocation('ou=employees,dc=example,dc=local')\n    ->setDeleteOldRdn(true)\n    ->setNewName('cn=bar');  The LDIF Mod RDN Type  The Mod RDN type is implemented to adhere to RFC 2849. There is no functional difference between the 'modrdn' and 'moddn'\nchangetypes. The class for 'modrdn' simply extends the class for the 'moddn' type. The only difference being that when\nit is output as a LDIF string the changetype will be 'modrdn':  use LdapTools\\Ldif\\Entry\\LdifEntryModRdn;\n\n$modrdn = new LdifEntryModRdn('cn=foo,dc=example,dc=local');\n$modrdn->newLocation($someOU);\n\n// Outputs a 'changetype' of 'modrdn'...\necho $modrdn->toString();  Helper Methods to Create LDIF Entries  An easy way to construct the LDIF entries is to use the 'entry()' method of the LDIF object. This takes care of some of\nthe manual object construction so you don't have to remember class names and produces a more fluent object-oriented\nmethod to build up the LDIF object.  use LdapTools\\Ldif\\Ldif;\n\n$ldif = new Ldif();\n\n// An entry to delete a LDAP object...\n$ldif->addEntry($ldif->entry()->delete('cn=user,dc=example,dc=local'));\n\n// An entry to add a new object to LDAP...\n$ldif->addEntry($ldif->entry()->add('cn=Josh,ou=employees,dc=example,dc=local')->setAttributes([\n    'objectclass' => ['top', 'person', 'organizationalPerson'],\n    'cn' => 'Josh Jensen',\n    'sn' => 'Jensen',\n    'uid' => 'jjensen',\n]));\n\n// Modify an existing LDAP object...\n$modify = $ldif->entry()->modify('cn=foo,dc=example,dc=local')\n    ->addAttribute('phonenumber', '555-5555')\n    ->replace('title', 'worker');\n$ldif->addEntry($modify);\n\n// Rename an object in LDAP...\n$ldif->addEntry($ldif->entry()->rename('cn=josh,dc=example,dc=local', 'cn=jill'));\n\n// Move an object in LDAP...\n$ldif->addEntry($ldif->entry()->move('cn=jill,dc=example,dc=local', 'ou=employees,dc=example,dc=local'));\n\n// Modify the DN of an LDAP object...\n$ldif->addEntry($ldif->entry()->moddn('cn=jill,ou=employees,dc=example,dc=local')->setNewRdn('cn=jill'));  LDIF Line Endings  By default when you call  toString()  on an LDIF object all of the line endings will be in Windows format (CRLF). If you\nwant to use Unix/Linux format (LF) you can use the  setLineEnding()  method:  use LdapTools\\Ldif\\Ldif;\n\n$ldif = $ldap->createLdif();\n\n$ldif->setLineEnding(Ldif::LINE_ENDING['UNIX']);  This is mostly useful for compatibility purposes. Some utilities consuming the LDIF file may be expecting a certain line\nending in order to work correctly.  Line Folding and Max Line Length  By default when you call  toString()  on an LDIF object it will not fold any lines regardless of how long they are. If\nyou would like for the long lines to be folded and continued on the next line after a certain length (to improve the\nreadability of the file) you can use the  setLineFolding(true)  and  setMaxLineLength($length)  methods:  use LdapTools\\Ldif\\Ldif;\n\n$ldif = $ldap->createLdif();\n\n# Long line (including comments) will be broken into smaller chunks now...\n$ldif->setLineFolding(true);\n# Unless this is explicitly set, the max line length is 76 by default.\n$ldif->setMaxLineLength(100);",
            "title": "LDIF Creation"
        },
        {
            "location": "/tutorials/Modifying-LDAP-Objects/",
            "text": "Modifying LDAP Objects\n\n\n\n\n\n\nAutomatic Setters and Getters\n\n\nAutomatic Property Access\n\n\nSet an Attribute Value\n\n\nAdd an Attribute Value\n\n\nRemove an Attribute Value\n\n\nReset an Attribute Value\n\n\nCheck if an Attribute Exists\n\n\n\n\nModifying an existing LDAP object is as easy as searching for it, making your changes to the object via either the \nsetters/properties then sending the object back to the \nLdapManager\n class with the \npersist()\n method. All the changes\nyou make to the object are tracked and when you call \npersist()\n it will only update the attributes you actually changed.\n\n\nPlease keep in mind that this is not an active record design. The \nLdapObject\n instance is only aware of properties\nyou explicitly selected as part of the LDAP query. So if you want to check if an attribute exists, or has a specific value,\nthen make sure to actually select the attribute when you query LDAP. If you selected the attribute as part of the query,\nbut the \nhas($attribute)\n method returns false, then the attribute is not set.\n\n\nA simple example:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n//...\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n$user = $repository->findOneByUsername('chad');\n\n// Replaces the current title with whatever you choose.\n$user->setTitle('CEO');\n// Resets whatever value might have been set to this attribute.\n$user->resetMobilePhone();\n// Remove a specific value from a multi-valued attribute. Careful! If it doesn't exist LDAP will complain.\n$user->removePhoneNumber('555-5555');\n// Remove multiple values for a multi-valued attribute at once (Using splat notation)...\n$user->removeOtherPhoneNumber(...['555-5555', '123-4567', '765-4321']);\n// Adds a value to an attribute in addition to what it might already have\n$user->addOtherIpPhones('#001-1000');\n// Add multiple values at once...\n$user->addOtherIpPhones('#001-1234','#002-5678', '#003-1001');\n\n// Check if a specific attribute exists\nif ($user->hasEmailAddress()) {\n    // do something....\n}\n\n// Check if an attribute with a specific value exists\nif ($user->hasState('WI')) {\n    // do something else....\n}\n\n// Now actually save the changes back to LDAP\ntry {\n    $ldap->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error updating user! \".$e->getMessage();\n}\n\n\n\n\nAutomatic Setters and Getters\n\n\nWhen you search for and retrieve an object in LDAP you will get an \nLdapObject\n instance by default. This class has\nseveral \"magic\" PHP methods defined to make your life easier. You can get/set any attribute by its actual schema name\njust as if it had an actual setter defined. So to get the \nfirstName\n attribute you can call \ngetFirstName()\n. And\nto change it you simply call \nsetFirstName($firstName)\n.\n\n\nHowever, be sure to check if the attribute exists in the returned object first by calling \nhas($attributeName)\n\nbefore trying to actually get its value.\n\n\nAutomatic Property Access\n\n\nIn addition to the automatic setters/getters mentioned above, you can also access attributes by simply accessing them as\nif they were public properties on the object. Behind the scenes it still tracks any changes you might make by setting a \nproperty this way.\n\n\n// Instead of '$user->getFirstName()' ...\necho \"First Name:\".$user->firstName.PHP_EOL;\necho \"Last Name:\".$user->lastName.PHP_EOL;\n\n// Or set them this way too, which is equivalent to calling: $user->setFirstName('Some Dude')\n$user->firstName = 'Fred';\n$user->lastName = 'Fuchs';\n\n// You can also call isset on a property to determine if it exists on the object...\nif (isset($user>phoneNumber)) {\n    echo \"Phone: \".$user->phoneNumber.PHP_EOL; \n}\n\n\n\n\n\n\nStandard Method Access\n\n\nIn Addition to all of the easy automatic property/setters/getters described above, you can also do it through more\nverbose methods. All of the below methods are ultimately what the automatic methods use to do everything behind the\nscenes.\n\n\n\n\nset($attribute, $value)\n\n\nReplaces any value that might exist in the attribute with the value you specify. If you pass \nnull\n, an empty string, or\nan empty array, then the call will perform a reset of the attribute (which clears an existing value), which is identical\nto calling \nreset($attribute)\n.\n\n\n// Sets or replaces any value that may exist.\n$user->set('firstName', 'Chad');\n\n// This will trigger a reset of the attribute, as a null/empty value is not valid for LDAP\n$user->set('firstName', null);\n// This triggers a reset too...\n$user->set('groups', []);\n\n\n\n\n\n\nadd($attribute, ...$value)\n\n\nAdds a value to an attribute in addition to what it already may have. It will keep the existing value intact. This\nmethod is also variadic, so you can pass as many values you want as arguments to this function.\n\n\n// Adds an additional attribute value...\n$user->add('otherTelephoneNumbers', '555-555-5555');\n\n// Check if the attribute exists before adding it...\nif ($user->has('otherTelephoneNumbers', '888-888-888')) {\n    $user->add('otherTelephoneNumbers', '888-888-888');\n}\n\n\n\n\n\n\nremove($attribute, ...$value)\n\n\nRemove a specific value from an attribute. Be careful with this. If the value does not actually exist within the\nattribute then an exception will be thrown during persist. It's best to wrap persist in a try/catch block. This\nmethod is also variadic, so you can pass as many values you want as arguments to this function.\n\n\n// Remove a specific attribute value...\n$user->remove('otherTelephoneNumbers', '555-555-5555');\n\n// Check if the attribute exists before removing it...\nif ($user->has('otherTelephoneNumbers', '888-888-888')) {\n    $user->remove('otherTelephoneNumbers', '888-888-888');\n}\n\n\n\n\n\n\nreset(...$attributes)\n\n\nResets an attribute (or attributes) by removing any values it may contain. Be careful with this method, just like the\nremove method you should select the attribute in the LDAP query then check if the attribute exists before resetting it.\nIf you try to reset an attribute that is already empty/unset, then LDAP will throw an error.\n\n\n// Reset a specific attribute value...\n$user->reset('groups');\n\n// Check if the attribute exists before resetting it...\nif ($user->has('title')) {\n    $user->reset('title');\n}\n\n\n\n\n\n\nhas($attribute, $value = null)\n\n\nCheck for the existence of an attribute before you attempt to retrieve its value. If you attempt to get the value of a\nnon-existent attribute then it will throw an exception. You can optionally specify a value check as well. In that case \nthe attribute must exist and it must have the specified value for it to return \ntrue\n.\n\n\n// Check if the attribute exists...\nif ($user->has('title')) {\n    // do something...\n}\n\n// Check if an attribute exists with a specific value...\nif ($user->has('otherTelephoneNumbers', '555-5555')) {\n    // do something else...\n}",
            "title": "Modifying LDAP Objects"
        },
        {
            "location": "/tutorials/Modifying-LDAP-Objects/#modifying-ldap-objects",
            "text": "Automatic Setters and Getters  Automatic Property Access  Set an Attribute Value  Add an Attribute Value  Remove an Attribute Value  Reset an Attribute Value  Check if an Attribute Exists   Modifying an existing LDAP object is as easy as searching for it, making your changes to the object via either the \nsetters/properties then sending the object back to the  LdapManager  class with the  persist()  method. All the changes\nyou make to the object are tracked and when you call  persist()  it will only update the attributes you actually changed.  Please keep in mind that this is not an active record design. The  LdapObject  instance is only aware of properties\nyou explicitly selected as part of the LDAP query. So if you want to check if an attribute exists, or has a specific value,\nthen make sure to actually select the attribute when you query LDAP. If you selected the attribute as part of the query,\nbut the  has($attribute)  method returns false, then the attribute is not set.  A simple example:  use LdapTools\\Object\\LdapObjectType;\n\n//...\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n$user = $repository->findOneByUsername('chad');\n\n// Replaces the current title with whatever you choose.\n$user->setTitle('CEO');\n// Resets whatever value might have been set to this attribute.\n$user->resetMobilePhone();\n// Remove a specific value from a multi-valued attribute. Careful! If it doesn't exist LDAP will complain.\n$user->removePhoneNumber('555-5555');\n// Remove multiple values for a multi-valued attribute at once (Using splat notation)...\n$user->removeOtherPhoneNumber(...['555-5555', '123-4567', '765-4321']);\n// Adds a value to an attribute in addition to what it might already have\n$user->addOtherIpPhones('#001-1000');\n// Add multiple values at once...\n$user->addOtherIpPhones('#001-1234','#002-5678', '#003-1001');\n\n// Check if a specific attribute exists\nif ($user->hasEmailAddress()) {\n    // do something....\n}\n\n// Check if an attribute with a specific value exists\nif ($user->hasState('WI')) {\n    // do something else....\n}\n\n// Now actually save the changes back to LDAP\ntry {\n    $ldap->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error updating user! \".$e->getMessage();\n}",
            "title": "Modifying LDAP Objects"
        },
        {
            "location": "/tutorials/Modifying-LDAP-Objects/#automatic-setters-and-getters",
            "text": "When you search for and retrieve an object in LDAP you will get an  LdapObject  instance by default. This class has\nseveral \"magic\" PHP methods defined to make your life easier. You can get/set any attribute by its actual schema name\njust as if it had an actual setter defined. So to get the  firstName  attribute you can call  getFirstName() . And\nto change it you simply call  setFirstName($firstName) .  However, be sure to check if the attribute exists in the returned object first by calling  has($attributeName) \nbefore trying to actually get its value.",
            "title": "Automatic Setters and Getters"
        },
        {
            "location": "/tutorials/Modifying-LDAP-Objects/#automatic-property-access",
            "text": "In addition to the automatic setters/getters mentioned above, you can also access attributes by simply accessing them as\nif they were public properties on the object. Behind the scenes it still tracks any changes you might make by setting a \nproperty this way.  // Instead of '$user->getFirstName()' ...\necho \"First Name:\".$user->firstName.PHP_EOL;\necho \"Last Name:\".$user->lastName.PHP_EOL;\n\n// Or set them this way too, which is equivalent to calling: $user->setFirstName('Some Dude')\n$user->firstName = 'Fred';\n$user->lastName = 'Fuchs';\n\n// You can also call isset on a property to determine if it exists on the object...\nif (isset($user>phoneNumber)) {\n    echo \"Phone: \".$user->phoneNumber.PHP_EOL; \n}",
            "title": "Automatic Property Access"
        },
        {
            "location": "/tutorials/Modifying-LDAP-Objects/#standard-method-access",
            "text": "In Addition to all of the easy automatic property/setters/getters described above, you can also do it through more\nverbose methods. All of the below methods are ultimately what the automatic methods use to do everything behind the\nscenes.   set($attribute, $value)  Replaces any value that might exist in the attribute with the value you specify. If you pass  null , an empty string, or\nan empty array, then the call will perform a reset of the attribute (which clears an existing value), which is identical\nto calling  reset($attribute) .  // Sets or replaces any value that may exist.\n$user->set('firstName', 'Chad');\n\n// This will trigger a reset of the attribute, as a null/empty value is not valid for LDAP\n$user->set('firstName', null);\n// This triggers a reset too...\n$user->set('groups', []);   add($attribute, ...$value)  Adds a value to an attribute in addition to what it already may have. It will keep the existing value intact. This\nmethod is also variadic, so you can pass as many values you want as arguments to this function.  // Adds an additional attribute value...\n$user->add('otherTelephoneNumbers', '555-555-5555');\n\n// Check if the attribute exists before adding it...\nif ($user->has('otherTelephoneNumbers', '888-888-888')) {\n    $user->add('otherTelephoneNumbers', '888-888-888');\n}   remove($attribute, ...$value)  Remove a specific value from an attribute. Be careful with this. If the value does not actually exist within the\nattribute then an exception will be thrown during persist. It's best to wrap persist in a try/catch block. This\nmethod is also variadic, so you can pass as many values you want as arguments to this function.  // Remove a specific attribute value...\n$user->remove('otherTelephoneNumbers', '555-555-5555');\n\n// Check if the attribute exists before removing it...\nif ($user->has('otherTelephoneNumbers', '888-888-888')) {\n    $user->remove('otherTelephoneNumbers', '888-888-888');\n}   reset(...$attributes)  Resets an attribute (or attributes) by removing any values it may contain. Be careful with this method, just like the\nremove method you should select the attribute in the LDAP query then check if the attribute exists before resetting it.\nIf you try to reset an attribute that is already empty/unset, then LDAP will throw an error.  // Reset a specific attribute value...\n$user->reset('groups');\n\n// Check if the attribute exists before resetting it...\nif ($user->has('title')) {\n    $user->reset('title');\n}   has($attribute, $value = null)  Check for the existence of an attribute before you attempt to retrieve its value. If you attempt to get the value of a\nnon-existent attribute then it will throw an exception. You can optionally specify a value check as well. In that case \nthe attribute must exist and it must have the specified value for it to return  true .  // Check if the attribute exists...\nif ($user->has('title')) {\n    // do something...\n}\n\n// Check if an attribute exists with a specific value...\nif ($user->has('otherTelephoneNumbers', '555-5555')) {\n    // do something else...\n}",
            "title": "Standard Method Access"
        },
        {
            "location": "/tutorials/Using-the-LDAP-Manager/",
            "text": "Using the LdapManager Class\n\n\n\n\n\n\nThe LDAP Query Builder\n\n\nLDAP Object Repositories\n\n\nSwitching Domains\n\n\nThe LDAP Connection\n\n\nModifying LDAP Objects\n\n\nDeleting LDAP Objects\n\n\nMoving LDAP Objects\n\n\nRestoring LDAP Objects\n\n\n\n\nThe \nLdapManager\n provides an easy point of access into the different parts of this library after you have setup the\n\nconfiguration\n. You can use the \nLdapManager\n to generate LDAP queries for a\ncertain domain, get a \"Repository\" for a specific LDAP type in your schema, switch between domains when you have \nmultiple defined in your configuration, and retrieve a \nLdapConnection\n object for the domain.\n\n\nGetting a LdapQueryBuilder Instance\n\n\n\n\nYou can retrieve a \nLdapQueryBuilder\n for a specific domain. For example, the below query will select all users with \nthe first name 'John', last name starts with a 'S', and whose accounts are enabled.\n\n\n$query = $ldapManager->buildLdapQuery();\n\n$users = $query\n    ->select(['username', 'city', 'state', 'guid'])\n    ->fromUsers()\n    ->where(\n        $query->filter()->eq('enabled', true)\n        $query->filter()->eq('firstName', 'John'),\n        $query->filter()->startsWith('lastName', 'S'),\n    )\n    ->getLdapQuery()\n    ->getResult();\n\n\n\n\nFor more information on building LDAP queries, see \nthe docs for it\n.\n\n\nGetting a Repository Object for a LDAP Type\n\n\n\n\nA repository object lets you easily query specific attributes for a LDAP object type to retrieve either a single result\nor many results. You can also define your own custom repository for a LDAP type to encapsulate an reuse your queries.\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Retrieve the user with a specific username.\n$user = $repository->findOneByUsername('jsmith');\n\n// Retrieve all users with their city set as Seattle\n$users = $repository->findByCity('Seattle');\n\n\n\n\nSwitching Domains\n\n\n\n\nIf you have multiple domains defined in your configuration, you can easily switch the contexts of your calls in the\n\nLdapManager\n by using \nswitchDomain\n:\n\n\n// Now calls to 'getRepository', 'buildLdapQuery', etc will return objects that execute in the context of this domain.\n$query = $ldap->switchDomain('example.local')->buildLdapQuery();\n\n// Will return 'example.local'\n$ldap->getDomainContext();\n\n// Switch back to the other domain...\n$ldap->switchDomain('foo.bar');\n\n\n\n\nGetting The LdapConnection\n\n\n\n\nThe \nLdapConnection\n is what ultimately executes queries against LDAP. It encapsulates the PHP \nldap_*\n functions into\nan object oriented form. It has several functions that also may be useful on their own.\n\n\nuse LdapTools\\Operation\\AuthenticationOperation;\n\n$connection = $ldapManager->getConnection();\n// Construct a LDAP authentication operation to run against the connection...\n$operation = (new AuthenticationOperation())->setUsername('username')->setPassword('password');\n// Run the authentication operation against the connection to get the response object...\n$response = $connection->execute($operation);\n\nif ($response->isAuthenticated()) {\n    echo sprintf(\"Successfully authenticated %s.\".PHP_EOL, $operation->getUsername());\n} else {\n    echo sprintf(\n        \"Failed to authenticate %s. (%s) %s.\".PHP_EOL,\n         $operation->getUsername(),\n         $response->getErrorCode(),\n         $response->getErrorMessage()\n     );\n}\n\n// Retrieve an object containing the RootDSE for the domain\n$rootDse = $connection->getRootDse();\n\nvar_dump($rootDse->toArray());\nvar_dump($rootDse->getDefaultNamingContext());\n\n\n\n\nModifying LDAP Objects\n\n\n\n\nUsing the \nLdapManager\n class you can save changes to LDAP users you have searched for back to LDAP using the\n\npersist($ldapObject)\n method.\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Change some attribute value\n$user->setCity('Milwaukee');\n\n// Save the changes back to LDAP using the persist method...\ntry {\n    $ldap->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error saving object to LDAP: \".$e->getMessage();\n}\n\n\n\n\nFor more information on modifying LDAP objects \nsee the docs for it\n.\n\n\nDeleting LDAP Objects\n\n\n\n\nUsing the \nLdapManager\n class you can also remove an object from LDAP using the \ndelete($ldapObject)\n method. To \nrecursively delete a LDAP object (including anything beneath it) pass \ntrue\n to the second parameter. \n\n\nA simple deletion:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Delete the object from LDAP...\ntry {\n    $ldap->delete($user);\n} catch (\\Exception $e) {\n    echo \"Error deleting object from LDAP: \".$e->getMessage();\n}\n\n\n\n\nRecursively deleting an OU and anything beneath it:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::OU);\n\n// Retrieve the user that has a specific GUID.\n$ou = $repository->findOneByName('Consultants');\n\n// Delete the OU, along with anything beneath it...\ntry {\n    $ldap->delete($ou, true);\n} catch (\\Exception $e) {\n    echo \"Error deleting OU: \".$e->getMessage();\n}\n\n\n\n\nMoving LDAP Objects\n\n\n\n\nUsing the \nLdapManager\n class you can move an object from one location to another in LDAP. The method for doing this is \nto call \nmove($ldapObject, $container)\n. All this requires is you pass the existing LdapObject and then the new location\nof the OU/container in standard DN form:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Move the object to a new OU...\ntry {\n    $ldap->move($user, 'ou=Employees,dc=example,dc=local');\n} catch (\\Exception $e) {\n    echo \"Error moving object: \".$e->getMessage();\n}\n\n\n\n\nRestoring LDAP Objects\n\n\n\n\nUsing the \nLdapManager\n class you can restore a deleted LDAP object. The method for doing this is \nrestore($ldapObject)\n\nHowever, this is currently only supported when you are using Active Directory. This requires that you first search for\nthe LDAP object you want to restore using the \nLdapObjectType::DELETED\n type then passing it to the restore method:\n\n\nuse LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::DELETED);\n\n// Retrieve the deleted LDAP object by its original GUID\n$ldapObject = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Restore the LDAP object to its original location\ntry {\n    $ldap->restore($ldapObject);\n} catch (\\Exception $e) {\n    echo \"Unable to restore LDAP object: \".$e->getMessage();\n}",
            "title": "Using the LDAP Manager"
        },
        {
            "location": "/tutorials/Using-the-LDAP-Manager/#using-the-ldapmanager-class",
            "text": "The LDAP Query Builder  LDAP Object Repositories  Switching Domains  The LDAP Connection  Modifying LDAP Objects  Deleting LDAP Objects  Moving LDAP Objects  Restoring LDAP Objects   The  LdapManager  provides an easy point of access into the different parts of this library after you have setup the configuration . You can use the  LdapManager  to generate LDAP queries for a\ncertain domain, get a \"Repository\" for a specific LDAP type in your schema, switch between domains when you have \nmultiple defined in your configuration, and retrieve a  LdapConnection  object for the domain.  Getting a LdapQueryBuilder Instance   You can retrieve a  LdapQueryBuilder  for a specific domain. For example, the below query will select all users with \nthe first name 'John', last name starts with a 'S', and whose accounts are enabled.  $query = $ldapManager->buildLdapQuery();\n\n$users = $query\n    ->select(['username', 'city', 'state', 'guid'])\n    ->fromUsers()\n    ->where(\n        $query->filter()->eq('enabled', true)\n        $query->filter()->eq('firstName', 'John'),\n        $query->filter()->startsWith('lastName', 'S'),\n    )\n    ->getLdapQuery()\n    ->getResult();  For more information on building LDAP queries, see  the docs for it .  Getting a Repository Object for a LDAP Type   A repository object lets you easily query specific attributes for a LDAP object type to retrieve either a single result\nor many results. You can also define your own custom repository for a LDAP type to encapsulate an reuse your queries.  use LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Retrieve the user with a specific username.\n$user = $repository->findOneByUsername('jsmith');\n\n// Retrieve all users with their city set as Seattle\n$users = $repository->findByCity('Seattle');  Switching Domains   If you have multiple domains defined in your configuration, you can easily switch the contexts of your calls in the LdapManager  by using  switchDomain :  // Now calls to 'getRepository', 'buildLdapQuery', etc will return objects that execute in the context of this domain.\n$query = $ldap->switchDomain('example.local')->buildLdapQuery();\n\n// Will return 'example.local'\n$ldap->getDomainContext();\n\n// Switch back to the other domain...\n$ldap->switchDomain('foo.bar');  Getting The LdapConnection   The  LdapConnection  is what ultimately executes queries against LDAP. It encapsulates the PHP  ldap_*  functions into\nan object oriented form. It has several functions that also may be useful on their own.  use LdapTools\\Operation\\AuthenticationOperation;\n\n$connection = $ldapManager->getConnection();\n// Construct a LDAP authentication operation to run against the connection...\n$operation = (new AuthenticationOperation())->setUsername('username')->setPassword('password');\n// Run the authentication operation against the connection to get the response object...\n$response = $connection->execute($operation);\n\nif ($response->isAuthenticated()) {\n    echo sprintf(\"Successfully authenticated %s.\".PHP_EOL, $operation->getUsername());\n} else {\n    echo sprintf(\n        \"Failed to authenticate %s. (%s) %s.\".PHP_EOL,\n         $operation->getUsername(),\n         $response->getErrorCode(),\n         $response->getErrorMessage()\n     );\n}\n\n// Retrieve an object containing the RootDSE for the domain\n$rootDse = $connection->getRootDse();\n\nvar_dump($rootDse->toArray());\nvar_dump($rootDse->getDefaultNamingContext());  Modifying LDAP Objects   Using the  LdapManager  class you can save changes to LDAP users you have searched for back to LDAP using the persist($ldapObject)  method.  use LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Change some attribute value\n$user->setCity('Milwaukee');\n\n// Save the changes back to LDAP using the persist method...\ntry {\n    $ldap->persist($user);\n} catch (\\Exception $e) {\n    echo \"Error saving object to LDAP: \".$e->getMessage();\n}  For more information on modifying LDAP objects  see the docs for it .  Deleting LDAP Objects   Using the  LdapManager  class you can also remove an object from LDAP using the  delete($ldapObject)  method. To \nrecursively delete a LDAP object (including anything beneath it) pass  true  to the second parameter.   A simple deletion:  use LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Delete the object from LDAP...\ntry {\n    $ldap->delete($user);\n} catch (\\Exception $e) {\n    echo \"Error deleting object from LDAP: \".$e->getMessage();\n}  Recursively deleting an OU and anything beneath it:  use LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::OU);\n\n// Retrieve the user that has a specific GUID.\n$ou = $repository->findOneByName('Consultants');\n\n// Delete the OU, along with anything beneath it...\ntry {\n    $ldap->delete($ou, true);\n} catch (\\Exception $e) {\n    echo \"Error deleting OU: \".$e->getMessage();\n}  Moving LDAP Objects   Using the  LdapManager  class you can move an object from one location to another in LDAP. The method for doing this is \nto call  move($ldapObject, $container) . All this requires is you pass the existing LdapObject and then the new location\nof the OU/container in standard DN form:  use LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::USER);\n\n// Retrieve the user that has a specific GUID.\n$user = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Move the object to a new OU...\ntry {\n    $ldap->move($user, 'ou=Employees,dc=example,dc=local');\n} catch (\\Exception $e) {\n    echo \"Error moving object: \".$e->getMessage();\n}  Restoring LDAP Objects   Using the  LdapManager  class you can restore a deleted LDAP object. The method for doing this is  restore($ldapObject) \nHowever, this is currently only supported when you are using Active Directory. This requires that you first search for\nthe LDAP object you want to restore using the  LdapObjectType::DELETED  type then passing it to the restore method:  use LdapTools\\Object\\LdapObjectType;\n\n$repository = $ldap->getRepository(LdapObjectType::DELETED);\n\n// Retrieve the deleted LDAP object by its original GUID\n$ldapObject = $repository->findOneByGuid('29d46992-a5c4-4dc2-ac51-ac432db2a078');\n\n// Restore the LDAP object to its original location\ntry {\n    $ldap->restore($ldapObject);\n} catch (\\Exception $e) {\n    echo \"Unable to restore LDAP object: \".$e->getMessage();\n}",
            "title": "Using the LdapManager Class"
        },
        {
            "location": "/reference/Attribute-Converters/",
            "text": "Attribute Converters\n\n\n\n\nAttribute converters are responsible for converting data from LDAP to the format you want it as in PHP, and vice-versa.\nSeveral attribute converters are built-in and exist under the \n\\LdapTools\\AttributeConverter\n namespace. All attribute\nconverters have the methods \ntoLdap($value)\n and \nfromLdap($value)\n that you can use to convert your data to the correct\nform. Typically this is done automatically from the schema definition, but you can also use them on their own as long as\nthey don't have a dependency on the \nLdapConnection\n to make the data conversion.\n\n\nuse LdapTools\\Factory\\AttributeConvertFactory;\n\n// will return the string form of an objectGuid binary value.\n$guid = AttributeConverterFactory::get('windows_guid')->fromLdap($value)\n\n\n\n\nThe \nAttributeConverterInterface\n requires a method called \nsetLdapConnection\n. This is called during the data hydration\nprocess and the converter may use the connection to make LDAP calls to resolve data as necessary.\n\n\nDefault Attribute Converters\n\n\n\n\nbool\n\n\n\n\n\n\ntoLdap\n: Converts a PHP bool to a string of 'TRUE' or 'FALSE'.\n\n\n\n\n\n\nfromLdap\n: Converts a LDAP 'TRUE' or 'FALSE' string into a corresponding PHP bool.\n\n\n\n\n\n\nint\n\n\n\n\n\n\ntoLdap\n: Converts a PHP int to a string.\n\n\n\n\n\n\nfromLdap\n: Converts a LDAP numeric string to a PHP int.\n\n\n\n\n\n\ngeneralized_time\n\n\n\n\n\n\ntoLdap\n: Converts a PHP \n\\DateTime\n object to a generalized timestamp string.\n\n\n\n\n\n\nfromLdap\n: Converts a LDAP generalized timestamp into a PHP \n\\DateTime\n object.\n\n\n\n\n\n\npassword_must_change\n\n\n\n\n\n\ntoLdap\n: Converts a PHP bool to either a -1 (false) or 0 (true). This toggles the \"Password Must Change\" property.\n\n\n\n\n\n\nfromLdap\n: Converts a LDAP '0' (true - password must change) or '>0' (false - password doesn't have to change).\n\n\n\n\n\n\nwindows_generalized_time\n\n\n\n\n\n\ntoLdap\n: Converts a PHP \n\\DateTime\n object to the generalized timestamp format string that Active Directory expects.\n\n\n\n\n\n\nfromLdap\n: Converts an Active Directory generalized timestamp format to a PHP \n\\DateTime\n object.\n\n\n\n\n\n\nwindows_guid\n\n\n\n\n\n\ntoLdap\n: Converts a string GUID to an escaped hex sequence string.\n\n\n\n\n\n\nfromLdap\n: Converts a binary GUID to its string representation.\n\n\n\n\n\n\nwindows_sid\n\n\n\n\n\n\ntoLdap\n: Converts a string SID to an escaped hex sequence string.\n\n\n\n\n\n\nfromLdap\n: Converts a binary SID to its string representation.\n\n\n\n\n\n\nwindows_time\n\n\n\n\n\n\ntoLdap\n: Converts a PHP \n\\DateTime\n object into a string representation of Windows time (nanoseconds).\n\n\n\n\n\n\nfromLdap\n: Converts a Windows timestamp into a PHP \n\\DateTime\n object.\n\n\n\n\n\n\nencode_windows_password\n\n\n\n\n\n\ntoLdap\n: Encodes a string to its unicodePwd representation, which is a quote encased UTF-16LE encoded value.\n\n\n\n\n\n\nfromLdap\n: This will not do anything since a unicodePwd attribute cannot be queried.\n\n\n\n\n\n\nexchange_proxy_address\n\n\n\n\n\n\ntoLdap\n: Takes an array of email addresses and formats them properly for the proxyAddresses attribute.\n\n\n\n\n\n\nfromLdap\n: Parses through the proxyAddresses attribute to return only the address portion for a specific address type.\n\n\n\n\n\n\nlogon_workstations\n\n\n\n\n\n\ntoLdap\n: Takes an array of computer names and formats it as a comma-separated list for LDAP.\n\n\n\n\n\n\nfromLdap\n: Formats the comma-separated list from LDAP as an array of computer names.\n\n\n\n\n\n\naccount_expires\n\n\n\n\n\n\ntoLdap\n: Takes either a bool false (never expires) or a \n\\DateTime\n object for when it should expire.\n\n\n\n\n\n\nfromLdap\n: Will either be false (never expires) or a \n\\DateTime\n object of when it will expire.\n\n\n\n\n\n\ngroup_type\n\n\n\n\n\n\ntoLdap\n: Takes a bool and switches the group between domain local, universal, global, security, or distribution.\n\n\n\n\n\n\nfromLdap\n: Depending on the attribute, does a bitwise conversion to set a specific type as true or false.\n\n\n\n\n\n\ngpo_link\n\n\n\n\n\n\ntoLdap\n: Takes an array of \n\\LdapTools\\Utilities\\GPOLink\n objects to resolve GPOs by name/GUID/DN/LdapObject, and returns a valid string for the gPLink attribute.\n\n\n\n\n\n\nfromLdap\n: Takes a gPLink attribute string, splits it into the distinct GPOs, and returns an array of \n\\LdapTools\\Utilities\\GPOLink\n objects.\n\n\n\n\n\n\nvalue_to_dn\n\n\n\n\n\n\ntoLdap\n: Takes an objects GUID, SID, DN, or name and returns the full distinguished name after validating it exists.\n\n\n\n\n\n\nfromLdap\n: Returns a common name for the object instead of the full distinguished name.\n\n\n\n\n\n\nprimary_group\n\n\n\n\n\n\ntoLdap\n: Takes a group name and converts it to its RID decimal value for the primaryGroupID attribute.\n\n\n\n\n\n\nfromLdap\n: Takes the RID of a group and returns the group's name.\n\n\n\n\n\n\nfunctional_level\n\n\n\n\n\n\ntoLdap\n: This should not be used. You should only read the value from LDAP.\n\n\n\n\n\n\nfromLdap\n: Takes an Active Directory functional level as an int and converts it to a human readable form.\n\n\n\n\n\n\ngpoptions\n\n\n\n\n\n\ntoLdap\n: Takes a bool and converts it to a string int to represent whether inheritance is blocked on an OU. \n\n\n\n\n\n\nfromLdap\n: Takes a gpOptions value and converts it to a bool for whether GPO inheritance is set to be blocked.\n\n\n\n\n\n\nexchange_roles\n\n\n\n\n\n\ntoLdap\n: This should not be used. It currently does not modify the value going back to LDAP.\n\n\n\n\n\n\nfromLdap\n: Takes an integer and and determines what roles it contains and converts that to an array of role names.\n\n\n\n\n\n\nexchange_version\n\n\n\n\n\n\ntoLdap\n: This should not be used. It currently does not modify the value going back to LDAP.\n\n\n\n\n\n\nfromLdap\n: Takes a build string stored in the serialNumber attribute and parses it to a readable Exchange version.\n\n\n\n\n\n\nldap_type\n\n\n\n\n\n\ntoLdap\n: This should not be used. It is currently unsupported.\n\n\n\n\n\n\nfromLdap\n: This returns the LDAP Object Type string represented by the \nLdapTools\\Object\\LdapObjectType\n constants.",
            "title": "Attribute Converters"
        },
        {
            "location": "/reference/Attribute-Converters/#attribute-converters",
            "text": "Attribute converters are responsible for converting data from LDAP to the format you want it as in PHP, and vice-versa.\nSeveral attribute converters are built-in and exist under the  \\LdapTools\\AttributeConverter  namespace. All attribute\nconverters have the methods  toLdap($value)  and  fromLdap($value)  that you can use to convert your data to the correct\nform. Typically this is done automatically from the schema definition, but you can also use them on their own as long as\nthey don't have a dependency on the  LdapConnection  to make the data conversion.  use LdapTools\\Factory\\AttributeConvertFactory;\n\n// will return the string form of an objectGuid binary value.\n$guid = AttributeConverterFactory::get('windows_guid')->fromLdap($value)  The  AttributeConverterInterface  requires a method called  setLdapConnection . This is called during the data hydration\nprocess and the converter may use the connection to make LDAP calls to resolve data as necessary.",
            "title": "Attribute Converters"
        },
        {
            "location": "/reference/Attribute-Converters/#default-attribute-converters",
            "text": "bool    toLdap : Converts a PHP bool to a string of 'TRUE' or 'FALSE'.    fromLdap : Converts a LDAP 'TRUE' or 'FALSE' string into a corresponding PHP bool.    int    toLdap : Converts a PHP int to a string.    fromLdap : Converts a LDAP numeric string to a PHP int.    generalized_time    toLdap : Converts a PHP  \\DateTime  object to a generalized timestamp string.    fromLdap : Converts a LDAP generalized timestamp into a PHP  \\DateTime  object.    password_must_change    toLdap : Converts a PHP bool to either a -1 (false) or 0 (true). This toggles the \"Password Must Change\" property.    fromLdap : Converts a LDAP '0' (true - password must change) or '>0' (false - password doesn't have to change).    windows_generalized_time    toLdap : Converts a PHP  \\DateTime  object to the generalized timestamp format string that Active Directory expects.    fromLdap : Converts an Active Directory generalized timestamp format to a PHP  \\DateTime  object.    windows_guid    toLdap : Converts a string GUID to an escaped hex sequence string.    fromLdap : Converts a binary GUID to its string representation.    windows_sid    toLdap : Converts a string SID to an escaped hex sequence string.    fromLdap : Converts a binary SID to its string representation.    windows_time    toLdap : Converts a PHP  \\DateTime  object into a string representation of Windows time (nanoseconds).    fromLdap : Converts a Windows timestamp into a PHP  \\DateTime  object.    encode_windows_password    toLdap : Encodes a string to its unicodePwd representation, which is a quote encased UTF-16LE encoded value.    fromLdap : This will not do anything since a unicodePwd attribute cannot be queried.    exchange_proxy_address    toLdap : Takes an array of email addresses and formats them properly for the proxyAddresses attribute.    fromLdap : Parses through the proxyAddresses attribute to return only the address portion for a specific address type.    logon_workstations    toLdap : Takes an array of computer names and formats it as a comma-separated list for LDAP.    fromLdap : Formats the comma-separated list from LDAP as an array of computer names.    account_expires    toLdap : Takes either a bool false (never expires) or a  \\DateTime  object for when it should expire.    fromLdap : Will either be false (never expires) or a  \\DateTime  object of when it will expire.    group_type    toLdap : Takes a bool and switches the group between domain local, universal, global, security, or distribution.    fromLdap : Depending on the attribute, does a bitwise conversion to set a specific type as true or false.    gpo_link    toLdap : Takes an array of  \\LdapTools\\Utilities\\GPOLink  objects to resolve GPOs by name/GUID/DN/LdapObject, and returns a valid string for the gPLink attribute.    fromLdap : Takes a gPLink attribute string, splits it into the distinct GPOs, and returns an array of  \\LdapTools\\Utilities\\GPOLink  objects.    value_to_dn    toLdap : Takes an objects GUID, SID, DN, or name and returns the full distinguished name after validating it exists.    fromLdap : Returns a common name for the object instead of the full distinguished name.    primary_group    toLdap : Takes a group name and converts it to its RID decimal value for the primaryGroupID attribute.    fromLdap : Takes the RID of a group and returns the group's name.    functional_level    toLdap : This should not be used. You should only read the value from LDAP.    fromLdap : Takes an Active Directory functional level as an int and converts it to a human readable form.    gpoptions    toLdap : Takes a bool and converts it to a string int to represent whether inheritance is blocked on an OU.     fromLdap : Takes a gpOptions value and converts it to a bool for whether GPO inheritance is set to be blocked.    exchange_roles    toLdap : This should not be used. It currently does not modify the value going back to LDAP.    fromLdap : Takes an integer and and determines what roles it contains and converts that to an array of role names.    exchange_version    toLdap : This should not be used. It currently does not modify the value going back to LDAP.    fromLdap : Takes a build string stored in the serialNumber attribute and parses it to a readable Exchange version.    ldap_type    toLdap : This should not be used. It is currently unsupported.    fromLdap : This returns the LDAP Object Type string represented by the  LdapTools\\Object\\LdapObjectType  constants.",
            "title": "Default Attribute Converters"
        },
        {
            "location": "/reference/Default-Schema-Attributes/",
            "text": "Default Schema Attributes\n\n\nDefault schemas are provided for both Active Directory and OpenLDAP that contain attribute name mappings and converters\nagainst commonly used attributes and object types. Below is a reference for the mappings and their converters that can be\nused when generating queries and returning data from LDAP.\n\n\nActive Directory Schema\n\n\n\n\nUsers\n\n\nGroups\n\n\nComputers\n\n\nContacts\n\n\nContainers\n\n\nOUs\n\n\nPassword Settings Objects\n\n\n\n\nExchange Schema\n\n\n\n\nServers\n\n\nDatabases\n\n\nRecipient Policies\n\n\nActiveSync Policies\n\n\nRBAC Policies\n\n\nTransport Rules\n\n\nDAG\n\n\nOWA\n\n\n\n\nOpenLDAP Schema\n\n\n\n\nUsers\n\n\nGroups\n\n\nOUs\n\n\n\n\nThe Active Directory Schema\n\n\n\n\nAD User Types\n\n\nThese are typical LDAP user objects.\n\n\n\n\nType\n: \nLdapObjectType::USER\n\n\nFilter\n: \n(&(objectClass=user)(objectCategory=person))\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccountExpirationDate\n\n\naccountExpires\n\n\n\\DateTime|false\n\n\nThe date the account expires\n\n\n\n\n\n\nbadPasswordCount\n\n\nbadPwdCount\n\n\nint\n\n\nThe number of bad password attempts\n\n\n\n\n\n\ncity\n\n\nl\n\n\nstring\n\n\nThe city for the user account\n\n\n\n\n\n\ncompany\n\n\ncompany\n\n\nstring\n\n\nThe company for the user account\n\n\n\n\n\n\ncountry\n\n\nc\n\n\nstring\n\n\nThe country for the user account\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the account was created\n\n\n\n\n\n\ndepartment\n\n\ndepartment\n\n\nstring\n\n\nThe department for the user account\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description for the user account\n\n\n\n\n\n\ndisabled\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether or not the account is disabled\n\n\n\n\n\n\ndisplayName\n\n\ndisplayName\n\n\nstring\n\n\nThe display name for the account\n\n\n\n\n\n\ndivision\n\n\ndivision\n\n\nstring\n\n\nThe user's division\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\nThe full distinguished name of the user\n\n\n\n\n\n\nemailAddress\n\n\nmail\n\n\nstring\n\n\nThe user's email address\n\n\n\n\n\n\nemployeeId\n\n\nemployeeId\n\n\nstring\n\n\nThe user's employee ID\n\n\n\n\n\n\nemployeeNumber\n\n\nemployeeNumber\n\n\nint\n\n\nThe user's employee number\n\n\n\n\n\n\nenabled\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether or not the account is enabled\n\n\n\n\n\n\nexchangeAlias\n\n\nmailNickname\n\n\nstring\n\n\nThe user's exchange alias\n\n\n\n\n\n\nexchangeHideFromGAL\n\n\nmsExchHideFromAddressLists\n\n\nbool\n\n\nWhether the user should be hidden from the address list\n\n\n\n\n\n\nexchangeMailboxDatabase\n\n\nhomeMDB\n\n\nstring\n\n\nThe database name where the user's mailbox is located\n\n\n\n\n\n\nexchangeMailboxGuid\n\n\nmsExchMailboxGUID\n\n\nstring\n\n\nThe user's mailbox GUID\n\n\n\n\n\n\nexchangePolicyRBAC\n\n\nmsExchRBACPolicyLink\n\n\nstring\n\n\nThe name of the assigned RBAC policy\n\n\n\n\n\n\nexchangePolicyActiveSync\n\n\nmsExchMobileMailboxPolicyLink\n\n\nstring\n\n\nThe name of the assigned ActiveSync policy\n\n\n\n\n\n\nexchangePolicyRetention\n\n\nmsExchMailboxTemplateLink\n\n\nstring\n\n\nThe name of the assigned retention policy\n\n\n\n\n\n\nexchangeSendOnBehalfOf\n\n\npublicDelegates\n\n\narray\n\n\nAll of the users that can send-on-behalf of this user\n\n\n\n\n\n\nexchangeSmtpAddresses\n\n\nproxyAddresses\n\n\narray\n\n\nAll of the user's assigned SMTP addresses\n\n\n\n\n\n\nexchangeDefaultSmtpAddress\n\n\nproxyAddresses\n\n\nstring\n\n\nThe user's default SMTP address\n\n\n\n\n\n\nfax\n\n\nfacsimileTelephoneNumber\n\n\nstring\n\n\nThe user's fax phone number\n\n\n\n\n\n\nfirstName\n\n\ngivenName\n\n\nstring\n\n\nThe user's first name\n\n\n\n\n\n\ngroups\n\n\nmemberOf\n\n\narray\n\n\nThe group names the user belongs to (not recursive)\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe user's GUID\n\n\n\n\n\n\nhomeDirectory\n\n\nhomeDirectory\n\n\nstring\n\n\nThe user's home directory path (ie. the UNC path)\n\n\n\n\n\n\nhomeDrive\n\n\nhomeDrive\n\n\nstring\n\n\nThe user's home drive letter (ie. \"H:\")\n\n\n\n\n\n\nhomePage\n\n\nwWWHomePage\n\n\nstring\n\n\nThe user's home page as a URL\n\n\n\n\n\n\nhomePhone\n\n\nhomePhone\n\n\nstring\n\n\nThe user's home telephone number\n\n\n\n\n\n\ninitials\n\n\ninitials\n\n\nstring\n\n\nThe initials that represent part of the user's name (ie. middle initial)\n\n\n\n\n\n\nipPhone\n\n\nipPhone\n\n\nstring\n\n\nThe user's IP telephone number\n\n\n\n\n\n\nlastName\n\n\nsn\n\n\nstring\n\n\nThe user's last name\n\n\n\n\n\n\nlocked\n\n\nlockoutTime\n\n\nbool\n\n\nWhether or not the user's account is locked out\n\n\n\n\n\n\nlockedDate\n\n\nlockoutTime\n\n\n\\DateTime|false\n\n\nThe date the user's account was locked (or false if not)\n\n\n\n\n\n\nlogonWorkstations\n\n\nuserWorkstations\n\n\narray\n\n\nThe system names the user is allowed to login to\n\n\n\n\n\n\nmanager\n\n\nmanager\n\n\nstring\n\n\nThe common name of the user's manager\n\n\n\n\n\n\nmiddleName\n\n\nmiddleName\n\n\nstring\n\n\nA name in addition to the user's first/last name (ie. middle name)\n\n\n\n\n\n\nmobilePhone\n\n\nmobile\n\n\nstring\n\n\nThe user's mobile phone number\n\n\n\n\n\n\nmodified\n\n\nwhenChanged\n\n\n\\DateTime\n\n\nThe date when the account was last modified\n\n\n\n\n\n\nnotes\n\n\ninfo\n\n\nstring\n\n\nAny additional information/notes for the user\n\n\n\n\n\n\noffice\n\n\nphysicalDeliveryOfficeName\n\n\nstring\n\n\nThe user's office name\n\n\n\n\n\n\norganization\n\n\no\n\n\nstring\n\n\nThe user's organization name\n\n\n\n\n\n\notherFaxes\n\n\notherFacsimileTelephoneNumber\n\n\narray\n\n\nAdditional fax telephone numbers for the user\n\n\n\n\n\n\notherHomePhones\n\n\notherHomePhone\n\n\narray\n\n\nAdditional home telephone numbers for the user\n\n\n\n\n\n\notherIpPhones\n\n\notherIpPhone\n\n\narray\n\n\nAdditional IP telephone numbers for the user\n\n\n\n\n\n\notherPagers\n\n\notherPager\n\n\narray\n\n\nAdditional pager numbers for the user\n\n\n\n\n\n\notherPhoneNumbers\n\n\notherTelephoneNumber\n\n\narray\n\n\nAdditional telephone numbers for the user\n\n\n\n\n\n\npassword\n\n\nunicodePwd\n\n\nstring\n\n\nThe user's password (can only be created or modified)\n\n\n\n\n\n\npasswordIsReversible\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether the password is reversible\n\n\n\n\n\n\npasswordLastSet\n\n\npwdLastSet\n\n\n\\DateTime\n\n\nThe date the password was last set\n\n\n\n\n\n\npasswordMustChange\n\n\npwdLastSet\n\n\nbool\n\n\nWhether the password must change on next login\n\n\n\n\n\n\npasswordNeverExpires\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether the password is set to never expire\n\n\n\n\n\n\npager\n\n\npager\n\n\nstring\n\n\nThe user's pager number\n\n\n\n\n\n\nphoneNumber\n\n\ntelephoneNumber\n\n\nstring\n\n\nThe user's primary telephone number\n\n\n\n\n\n\npoBox\n\n\npostOfficeBox\n\n\nstring\n\n\nThe user's PO box number\n\n\n\n\n\n\nprimaryGroup\n\n\nprimaryGroupID\n\n\nstring\n\n\nThe user's primary group (typically Domain Users)\n\n\n\n\n\n\nprofilePath\n\n\nprofilePath\n\n\nstring\n\n\nThe user's profile path (ie. \\some\\path)\n\n\n\n\n\n\nscriptPath\n\n\nscriptPath\n\n\nstring\n\n\nThe user's login script (ie. \\server\\scripts\\login.bat)\n\n\n\n\n\n\nservicePrincipalNames\n\n\nservicePrincipalName\n\n\narray\n\n\nAll of the user's SPNs (ie \n['SQLservice\\foo.bar.com:1456']\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe user's SID (security identifier)\n\n\n\n\n\n\nsmartCardRequired\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether or not the user must use a smart card\n\n\n\n\n\n\nstate\n\n\nst\n\n\nstring\n\n\nThe user's state (ie. WI)\n\n\n\n\n\n\nstreetAddress\n\n\nstreetAddress\n\n\nstring\n\n\nThe user's street address\n\n\n\n\n\n\ntitle\n\n\ntitle\n\n\nstring\n\n\nThe user's title (ie. Systems Administrator)\n\n\n\n\n\n\ntrustedForAllDelegation\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether the account is trusted for delegation\n\n\n\n\n\n\ntrustedForAnyAuthDelegation\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether the account is trusted for any auth delegation\n\n\n\n\n\n\nusername\n\n\nsAMAccountName\n\n\nstring\n\n\nThe user's username\n\n\n\n\n\n\nupn\n\n\nuserPrincipalName\n\n\nstring\n\n\nThe user's user principal name (ie. foo@bar.local)\n\n\n\n\n\n\nzipCode\n\n\npostalCode\n\n\nstring\n\n\nThe user's zip code\n\n\n\n\n\n\n\n\nAD Group Types\n\n\nThese are typical LDAP group objects.\n\n\n\n\nType\n: \nLdapObjectType::GROUP\n\n\nFilter\n: \n(objectClass=group)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccountName\n\n\nsAMAccountName\n\n\nstring\n\n\nThe account name of the group\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the group was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the group\n\n\n\n\n\n\ndisplayName\n\n\ndisplayName\n\n\nstring\n\n\nThe display name for the group\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\nThe full distinguished name of the group\n\n\n\n\n\n\nemailAddress\n\n\nmail\n\n\nstring\n\n\nThe group's email address\n\n\n\n\n\n\nexchangeAddressBookFlags\n\n\nmsExchAddressBookFlags\n\n\nint\n\n\n\n\n\n\n\n\nexchangeAlias\n\n\nmailNickname\n\n\nstring\n\n\nThe group's exchange alias\n\n\n\n\n\n\nexchangeHideFromGAL\n\n\nmsExchHideFromAddressLists\n\n\nbool\n\n\nWhether the group should be hidden from the address list\n\n\n\n\n\n\nexchangeInternalOnly\n\n\nmsExchRequireAuthToSendTo\n\n\nbool\n\n\nWhether the group requires authentication to send to it\n\n\n\n\n\n\nexchangeSmtpAddresses\n\n\nproxyAddresses\n\n\narray\n\n\nAll of the group's assigned SMTP addresses\n\n\n\n\n\n\nexchangeDefaultSmtpAddress\n\n\nproxyAddresses\n\n\nstring\n\n\nThe group's default SMTP address\n\n\n\n\n\n\ngroups\n\n\nmemberOf\n\n\narray\n\n\nThe group names the group belongs to (not recursive)\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe group's GUID\n\n\n\n\n\n\nmanagedBy\n\n\nmanagedBy\n\n\nstring\n\n\nThe common name for who the group is managed by\n\n\n\n\n\n\nmembers\n\n\nmember\n\n\narray\n\n\nAll of the members of the group (not recursive)\n\n\n\n\n\n\nmodified\n\n\nwhenChanged\n\n\n\\DateTime\n\n\nThe date when the group was last modified\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the group\n\n\n\n\n\n\nnotes\n\n\ninfo\n\n\nstring\n\n\nAny additional information/notes for the group\n\n\n\n\n\n\nscopeDomainLocal\n\n\ngroupType\n\n\nbool\n\n\nWhether or not the group's scope is domain local\n\n\n\n\n\n\nscopeGlobal\n\n\ngroupType\n\n\nbool\n\n\nWhether or not the group's scope is global\n\n\n\n\n\n\nscopeUniversal\n\n\ngroupType\n\n\nbool\n\n\nWhether or not the group's scope is universal\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe group's SID (security identifier)\n\n\n\n\n\n\ntypeBuiltin\n\n\ngroupType\n\n\nbool\n\n\nWhether or not this is builtin group\n\n\n\n\n\n\ntypeDistribution\n\n\ngroupType\n\n\nbool\n\n\nWhether or not this is a distribution group\n\n\n\n\n\n\ntypeSecurity\n\n\ngroupType\n\n\nbool\n\n\nWhether or not this is a security group\n\n\n\n\n\n\n\n\nAD Computer Types\n\n\nThese are typical LDAP computer objects.\n\n\n\n\nType\n: \nLdapObjectType::COMPUTER\n\n\nFilter\n: \n(objectCategory=computer)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccountName\n\n\nsAMAccountName\n\n\nstring\n\n\nThe account name of the computer\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the computer object was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the computer\n\n\n\n\n\n\ndisabled\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether or not the computer object is disabled\n\n\n\n\n\n\ndisplayName\n\n\ndisplayName\n\n\nstring\n\n\nThe display name for the computer\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\nThe full distinguished name of the computer\n\n\n\n\n\n\ndnsHostName\n\n\ndNSHostName\n\n\nstring\n\n\nThe fully qualified domain name (FQDN) of the computer\n\n\n\n\n\n\nenabled\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether or not the computer object is enabled\n\n\n\n\n\n\ngroups\n\n\nmemberOf\n\n\narray\n\n\nThe group names the computer belongs to (not recursive)\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe computer's GUID\n\n\n\n\n\n\nlocation\n\n\nlocation\n\n\nstring\n\n\nThe location of the computer (such as office name)\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the computer was last modified\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the computer\n\n\n\n\n\n\nnotes\n\n\ninfo\n\n\nstring\n\n\nAny additional information/notes for the computer\n\n\n\n\n\n\nos\n\n\noperatingSystem\n\n\nstring\n\n\nThe operating system name for the computer object\n\n\n\n\n\n\nosServicePack\n\n\noperatingSystemServicePack\n\n\nstring\n\n\nThe name of the operating system service pack\n\n\n\n\n\n\nosVersion\n\n\noperatingSystemVersion\n\n\nstring\n\n\nThe operating system version number (ie. 6.0)\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe computer's SID (Security Identifier)\n\n\n\n\n\n\ntrustedForAllDelegation\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether the computer is trusted for delegation\n\n\n\n\n\n\ntrustedForAnyAuthDelegation\n\n\nuserAccountControl\n\n\nbool\n\n\nWhether the computer is trusted for any auth delegation\n\n\n\n\n\n\n\n\nAD Contact Types\n\n\nThese are typical LDAP contact objects.\n\n\n\n\nType\n: \nLdapObjectType::CONTACT\n\n\nFilter\n: \n(objectCategory=contact)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the contact was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the contact\n\n\n\n\n\n\ndisplayName\n\n\ndisplayName\n\n\nstring\n\n\nThe display name for the contact\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\nThe full distinguished name of the contact\n\n\n\n\n\n\nemailAddress\n\n\nmail\n\n\nstring\n\n\nThe contact's email address\n\n\n\n\n\n\nexchangeAlias\n\n\nmailNickname\n\n\nstring\n\n\nThe contact's exchange alias\n\n\n\n\n\n\nexchangeHideFromGAL\n\n\nmsExchHideFromAddressLists\n\n\nbool\n\n\nWhether the contact should be hidden from the address list\n\n\n\n\n\n\nexchangeSmtpAddresses\n\n\nproxyAddresses\n\n\narray\n\n\nAll of the contact's assigned SMTP addresses\n\n\n\n\n\n\nexchangeDefaultSmtpAddress\n\n\nproxyAddresses\n\n\nstring\n\n\nThe contact's default SMTP address\n\n\n\n\n\n\nfirstName\n\n\ngivenName\n\n\nstring\n\n\nThe contact's first name\n\n\n\n\n\n\ngroups\n\n\nmemberOf\n\n\narray\n\n\nThe group names the contact belongs to (not recursive)\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe contact's GUID\n\n\n\n\n\n\nlastName\n\n\nsn\n\n\nstring\n\n\nThe contact's last name\n\n\n\n\n\n\nmanager\n\n\nmanager\n\n\nstring\n\n\nThe common name of the contact's manager\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the contact was last modified\n\n\n\n\n\n\nnotes\n\n\ninfo\n\n\nstring\n\n\nAny additional information/notes for the contact\n\n\n\n\n\n\nphoneNumber\n\n\ntelephoneNumber\n\n\nstring\n\n\nThe contact's telephone number\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe contact's SID (Security Identifier)\n\n\n\n\n\n\n\n\nAD OU Types\n\n\nThese are typical LDAP OU objects.\n\n\n\n\nType\n: \nLdapObjectType::OU\n\n\nFilter\n: \n(objectCategory=organizationalUnit)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncity\n\n\nl\n\n\nstring\n\n\nThe OU's city name\n\n\n\n\n\n\ncountry\n\n\nc\n\n\nstring\n\n\nThe OU's country name\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nWhen date the OU was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the OU\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\nThe full distinguished name of the OU\n\n\n\n\n\n\ngpoLinks\n\n\ngPLink\n\n\nGPOLink[]\n\n\nAll of the GPOs linked to this OU\n\n\n\n\n\n\ngpoInheritanceBlocked\n\n\ngpOptions\n\n\nbool\n\n\nWhether or not GPO inheritance is blocked for this OU\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe OU's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the OU was last modified\n\n\n\n\n\n\nname\n\n\nou\n\n\nstring\n\n\nThe common name (RDN) for the OU\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe OU's SID (Security Identifier)\n\n\n\n\n\n\nstate\n\n\nst\n\n\nstring\n\n\nThe OU's state name\n\n\n\n\n\n\nstreetAddress\n\n\nstreetAddress\n\n\nstring\n\n\nThe OU's street address\n\n\n\n\n\n\nzipCode\n\n\npostalCode\n\n\nstring\n\n\nThe OU's zip code\n\n\n\n\n\n\n\n\nAD Container Types\n\n\nThese are typical LDAP Container objects.\n\n\n\n\nType\n: \nLdapObjectType::CONTAINER\n\n\nFilter\n: \n(objectCategory=container)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the container was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the container\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\nThe full distinguished name of the container\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe container's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the container was last modified\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) for the container\n\n\n\n\n\n\n\n\nAD Password Settings Objects Types\n\n\nThese are Password Settings Objects, also known as PSOs. They can be used with \nthe type name \nPSO\n.\n\n\n\n\nFilter\n: \n(objectClass=msDS-PasswordSettings)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nappliesTo\n\n\nmsDS-PSOAppliesTo\n\n\narray\n\n\nAll of the group/user names this PSO is applied to\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the PSO was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the PSO\n\n\n\n\n\n\ndn\n\n\ndistinguishedName\n\n\nstring\n\n\nThe full distinguished name of the PSO\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe PSO's GUID\n\n\n\n\n\n\nlockoutDuration\n\n\nmsDS-LockoutDuration\n\n\n\\LdapTools\\Utilities\\ADTimeSpan\n\n\nLockout duration time span\n\n\n\n\n\n\nlockoutObservationWindow\n\n\nmsDS-LockoutObservationWindow\n\n\n\\LdapTools\\Utilities\\ADTimeSpan\n\n\nLockout observation window time span\n\n\n\n\n\n\nlockoutThreshold\n\n\nmsDS-LockoutThreshold\n\n\nint\n\n\nNumber of attempts before the account is locked\n\n\n\n\n\n\nmaximumPasswordAge\n\n\nmsDS-MaximumPasswordAge\n\n\n\\LdapTools\\Utilities\\ADTimeSpan\n\n\nMax password age time span\n\n\n\n\n\n\nminimumPasswordAge\n\n\nmsDS-MinimumPasswordAge\n\n\n\\LdapTools\\Utilities\\ADTimeSpan\n\n\nMin password age time span\n\n\n\n\n\n\nminimumPasswordLength\n\n\nmsDS-MinimumPasswordLength\n\n\nint\n\n\nMin password length\n\n\n\n\n\n\nmodified\n\n\nwhenChanged\n\n\n\\DateTime\n\n\nThe date the PSO was last modified\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) for the PSO\n\n\n\n\n\n\npasswordComplexity\n\n\nmsDS-PasswordComplexityEnabled\n\n\nbool\n\n\nWhether or not password complexity is enabled\n\n\n\n\n\n\npasswordHistoryLength\n\n\nmsDS-PasswordHistoryLength\n\n\nint\n\n\nThe number of previous passwords that cannot be used\n\n\n\n\n\n\npasswordReversibleEncryption\n\n\nmsDS-PasswordReversibleEncryptionEnabled\n\n\nbool\n\n\nWhether the password can be decrypted\n\n\n\n\n\n\nprecedence\n\n\nmsDS-PasswordSettingsPrecedence\n\n\nint\n\n\nThe precedence (lower value == higher rank) of this PSO\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe PSO's SID (Security Identifier)\n\n\n\n\n\n\n\n\nAD Deleted Objects Types\n\n\nThese are deleted objects that reside in the AD Recycle Bin.\n\n\n\n\nType\n: \nLdapObjectType::DELETED\n\n\nFilter\n: \n(&(isDeleted=TRUE)(lastKnownParent=*))\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date when the object was created\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\nThe description of the deleted object\n\n\n\n\n\n\ndn\n\n\ndistinguishedName\n\n\nstring\n\n\nThe full distinguished name of the deleted object\n\n\n\n\n\n\nfirstName\n\n\ngivenName\n\n\nstring\n\n\nThe first name of the deleted object (if any)\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe deleted object's GUID\n\n\n\n\n\n\nisDeleted\n\n\nisDeleted\n\n\nbool\n\n\nWhether the object is deleted\n\n\n\n\n\n\nlastName\n\n\nsn\n\n\nstring\n\n\nThe last name of the deleted object (if any)\n\n\n\n\n\n\nlastKnownLocation\n\n\nlastKnownParent\n\n\nstring\n\n\nThe DN of the last known location (ie. ou=foo,dc=example,dc=com)\n\n\n\n\n\n\nlastKnownName\n\n\nlastKnownRdn\n\n\nstring\n\n\nThe last known name (RDN) for the deleted object\n\n\n\n\n\n\nmodified\n\n\nwhenChanged\n\n\n\\DateTime\n\n\nThe date the deleted object was last modified\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe current name (RDN) of the deleted object\n\n\n\n\n\n\nschemaType\n\n\nobjectClass\n\n\nstring\n\n\nThe LdpaTools schema type of the object (ie. user, group, computer, etc)\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe deleted object's SID (Security Identifier)\n\n\n\n\n\n\nupn\n\n\nuserPrincipalName\n\n\nstring\n\n\nThe user principal name of the deleted object (if any)\n\n\n\n\n\n\n\n\nThe Exchange Schema\n\n\n\n\nExchange Server Types\n\n\nThese are Exchange Servers.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_SERVER\n\n\nFilter\n: \n(&(objectClass=msExchExchangeServer)(serverRole=*))\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the exchange server\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the exchange server object was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe exchange server's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the exchange server was last modified\n\n\n\n\n\n\nroles\n\n\nmsExchCurrentServerRoles\n\n\narray\n\n\nAll of the role names for the exchange server\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe exchange server's SID (Security Identifier)\n\n\n\n\n\n\nversion\n\n\nserialNumber\n\n\nstring\n\n\nThe friendly Exchange version name (ie. Exchange 2013 RTM)\n\n\n\n\n\n\n\n\nExchange Database Types\n\n\nThese are Exchange Databases.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_DATABASE\n\n\nFilter\n: \n(objectClass=msExchMDB)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the exchange database\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the exchange database was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe exchange database's GUID\n\n\n\n\n\n\nisBeingRestored\n\n\nmsexchdatabasebeingrestored\n\n\nbool\n\n\nWhether the database is currently being restored\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the exchange database was last modified\n\n\n\n\n\n\nmountOnStartup\n\n\nmsexchedboffline\n\n\nbool\n\n\nWhether or not the database should be mounted on startup\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe exchange database's SID (Security Identifier)\n\n\n\n\n\n\n\n\nExchange Recipient Policy Types\n\n\nThese are Exchange Recipient policies.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_RECIPIENT_POLICY\n\n\nFilter\n: \n(objectClass=msExchRecipientPolicy)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the recipient policy\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the recipient policy was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe recipient policy's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the recipient policy was last modified\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe recipient policy's SID (Security Identifier\n\n\n\n\n\n\n\n\nExchange ActiveSync Policy Types\n\n\nThese are Exchange ActiveSync policies.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_ACTIVESYNC_POLICY\n\n\nFilter\n: \n(objectClass=msExchMobileMailboxPolicy)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the ActiveSync policy\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the ActiveSync policy was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe ActiveSync policy's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the ActiveSync policy was last modified\n\n\n\n\n\n\nnumberOfPreviousPasswordsDisallowed\n\n\nmsExchMobileDeviceNumberOfPreviousPasswordsDisallowed\n\n\nint\n\n\nPassword history limit\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe ActiveSync policy's SID (Security Identifier)\n\n\n\n\n\n\n\n\nExchange RBAC Policy Type\n\n\nThese are Exchange RBAC policies.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_RBAC_POLICY\n\n\nFilter\n: \n(objectClass=msExchRBACPolicy)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the RBAC policy\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the RBAC policy was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe RBAC policy's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the RBAC policy was last modified\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe RBAC policy's SID (Security Identifier)\n\n\n\n\n\n\n\n\nExchange Transport Rule Types\n\n\nThese are Exchange Transport Rules.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_TRANSPORT_RULE\n\n\nFilter\n: \n(objectClass=msExchTransportRule)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the transport rule\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the transport rule was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe transport rule's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the transport rule was last modified\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe transport rule's SID (Security Identifier)\n\n\n\n\n\n\n\n\nExchange DAG Types\n\n\nThis represents an Exchange DAG.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_DAG\n\n\nFilter\n: \n(objectClass=msExchMDBAvailabilityGroup)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the DAG\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the DAG was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe DAG's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the DAG was last modified\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe DAG's SID (Security Identifier)\n\n\n\n\n\n\n\n\nExchange OWA Types\n\n\nThese are the Exchange OWA instances.\n\n\n\n\nType\n: \nLdapObjectType::EXCHANGE_OWA\n\n\nFilter\n: \n(objectClass=msExchOWAVirtualDirectory)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\nThe common name (RDN) of the OWA object\n\n\n\n\n\n\ncreated\n\n\nwhenCreated\n\n\n\\DateTime\n\n\nThe date the OWA object was created\n\n\n\n\n\n\nguid\n\n\nobjectGuid\n\n\nstring\n\n\nThe OWA's GUID\n\n\n\n\n\n\nmodified\n\n\nwhenModified\n\n\n\\DateTime\n\n\nThe date the OWA object was last modified\n\n\n\n\n\n\nsid\n\n\nobjectSid\n\n\nstring\n\n\nThe OWA's SID (Security Identifier)\n\n\n\n\n\n\nurl\n\n\nmsExchInternalHostname\n\n\nstring\n\n\nThe URL of the OWA instance\n\n\n\n\n\n\n\n\nThe OpenLDAP Schema\n\n\n\n\nOpenLDAP User Types\n\n\nThese are typical LDAP user objects.\n\n\n\n\nType\n: \nLdapObjectType::USER\n\n\nFilter\n: \n(objectClass=inetOrgPerson)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\n\n\n\n\n\n\n\n\ncity\n\n\nl\n\n\nstring\n\n\n\n\n\n\ncompany\n\n\ncompany\n\n\nstring\n\n\n\n\n\n\ncountry\n\n\ncountry\n\n\nstring\n\n\n\n\n\n\ncreated\n\n\ncreateTimestamp\n\n\n\\DateTime\n\n\n\n\n\n\ndepartment\n\n\ndepartment\n\n\nstring\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\n\n\n\n\nemailAddress\n\n\nmail\n\n\nstring\n\n\n\n\n\n\nemployeeNumber\n\n\nemployeeNumber\n\n\nint\n\n\n\n\n\n\nfax\n\n\nfacsimileTelephoneNumber\n\n\nstring\n\n\n\n\n\n\nfirstName\n\n\ngivenName\n\n\nstring\n\n\n\n\n\n\ngroups\n\n\nmemberOf\n\n\narray\n\n\n\n\n\n\nhomeDirectory\n\n\nhomeDirectory\n\n\nstring\n\n\n\n\n\n\nhomePhone\n\n\nhomePhone\n\n\nstring\n\n\n\n\n\n\ninitials\n\n\ninitials\n\n\nstring\n\n\n\n\n\n\nlastName\n\n\nsn\n\n\nstring\n\n\n\n\n\n\nmiddleName\n\n\nmiddleName\n\n\nstring\n\n\n\n\n\n\nmodified\n\n\nmodifyTimestamp\n\n\n\\DateTime\n\n\n\n\n\n\nmobilePhone\n\n\nmobile\n\n\nstring\n\n\n\n\n\n\norganization\n\n\no\n\n\nstring\n\n\n\n\n\n\npassword\n\n\npassword\n\n\nstring\n\n\n\n\n\n\npager\n\n\npager\n\n\nstring\n\n\n\n\n\n\nphoneNumber\n\n\ntelephoneNumber\n\n\nstring\n\n\n\n\n\n\npoBox\n\n\npostOfficeBox\n\n\nstring\n\n\n\n\n\n\nstate\n\n\nst\n\n\nstring\n\n\n\n\n\n\nstreetAddress\n\n\nstreetAddress\n\n\nstring\n\n\n\n\n\n\ntitle\n\n\ntitle\n\n\nstring\n\n\n\n\n\n\nzipCode\n\n\npostalCode\n\n\nstring\n\n\n\n\n\n\n\n\nOpenLDAP Group Types\n\n\nThese are typical LDAP group objects.\n\n\n\n\nType\n: \nLdapObjectType::GROUP\n\n\nFilter\n: \n(objectClass=groupOfUniqueNames)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\n\n\n\n\n\n\n\n\ncreated\n\n\ncreateTimestamp\n\n\n\\DateTime\n\n\n\n\n\n\ndescription\n\n\ndescription\n\n\nstring\n\n\n\n\n\n\ndisplayName\n\n\ndisplayName\n\n\nstring\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\n\n\n\n\nmembers\n\n\nuniqueMembers\n\n\narray\n\n\n\n\n\n\nmodified\n\n\nmodifyTimestamp\n\n\n\\DateTime\n\n\n\n\n\n\nname\n\n\ncn\n\n\nstring\n\n\n\n\n\n\n\n\nOpenLDAP OU Types\n\n\nThese are typical LDAP OU objects.\n\n\n\n\nType\n: \nLdapObjectType::OU\n\n\nFilter\n: \n(objectClass=organizationalUnit)\n\n\n\n\n\n\n\n\n\n\nLdapTools Name\n\n\nLDAP Attribute\n\n\nValue Type\n\n\n\n\n\n\n\n\n\n\ncreated\n\n\ncreateTimestamp\n\n\n\\DateTime\n\n\n\n\n\n\ndn\n\n\ndn\n\n\nstring\n\n\n\n\n\n\nmodified\n\n\nmodifyTimestamp\n\n\n\\DateTime\n\n\n\n\n\n\nname\n\n\nou\n\n\nstring",
            "title": "Default Schema Attributes"
        },
        {
            "location": "/reference/Default-Schema-Attributes/#default-schema-attributes",
            "text": "Default schemas are provided for both Active Directory and OpenLDAP that contain attribute name mappings and converters\nagainst commonly used attributes and object types. Below is a reference for the mappings and their converters that can be\nused when generating queries and returning data from LDAP.  Active Directory Schema   Users  Groups  Computers  Contacts  Containers  OUs  Password Settings Objects   Exchange Schema   Servers  Databases  Recipient Policies  ActiveSync Policies  RBAC Policies  Transport Rules  DAG  OWA   OpenLDAP Schema   Users  Groups  OUs   The Active Directory Schema   AD User Types  These are typical LDAP user objects.   Type :  LdapObjectType::USER  Filter :  (&(objectClass=user)(objectCategory=person))      LdapTools Name  LDAP Attribute  Value Type  Description      accountExpirationDate  accountExpires  \\DateTime|false  The date the account expires    badPasswordCount  badPwdCount  int  The number of bad password attempts    city  l  string  The city for the user account    company  company  string  The company for the user account    country  c  string  The country for the user account    created  whenCreated  \\DateTime  The date the account was created    department  department  string  The department for the user account    description  description  string  The description for the user account    disabled  userAccountControl  bool  Whether or not the account is disabled    displayName  displayName  string  The display name for the account    division  division  string  The user's division    dn  dn  string  The full distinguished name of the user    emailAddress  mail  string  The user's email address    employeeId  employeeId  string  The user's employee ID    employeeNumber  employeeNumber  int  The user's employee number    enabled  userAccountControl  bool  Whether or not the account is enabled    exchangeAlias  mailNickname  string  The user's exchange alias    exchangeHideFromGAL  msExchHideFromAddressLists  bool  Whether the user should be hidden from the address list    exchangeMailboxDatabase  homeMDB  string  The database name where the user's mailbox is located    exchangeMailboxGuid  msExchMailboxGUID  string  The user's mailbox GUID    exchangePolicyRBAC  msExchRBACPolicyLink  string  The name of the assigned RBAC policy    exchangePolicyActiveSync  msExchMobileMailboxPolicyLink  string  The name of the assigned ActiveSync policy    exchangePolicyRetention  msExchMailboxTemplateLink  string  The name of the assigned retention policy    exchangeSendOnBehalfOf  publicDelegates  array  All of the users that can send-on-behalf of this user    exchangeSmtpAddresses  proxyAddresses  array  All of the user's assigned SMTP addresses    exchangeDefaultSmtpAddress  proxyAddresses  string  The user's default SMTP address    fax  facsimileTelephoneNumber  string  The user's fax phone number    firstName  givenName  string  The user's first name    groups  memberOf  array  The group names the user belongs to (not recursive)    guid  objectGuid  string  The user's GUID    homeDirectory  homeDirectory  string  The user's home directory path (ie. the UNC path)    homeDrive  homeDrive  string  The user's home drive letter (ie. \"H:\")    homePage  wWWHomePage  string  The user's home page as a URL    homePhone  homePhone  string  The user's home telephone number    initials  initials  string  The initials that represent part of the user's name (ie. middle initial)    ipPhone  ipPhone  string  The user's IP telephone number    lastName  sn  string  The user's last name    locked  lockoutTime  bool  Whether or not the user's account is locked out    lockedDate  lockoutTime  \\DateTime|false  The date the user's account was locked (or false if not)    logonWorkstations  userWorkstations  array  The system names the user is allowed to login to    manager  manager  string  The common name of the user's manager    middleName  middleName  string  A name in addition to the user's first/last name (ie. middle name)    mobilePhone  mobile  string  The user's mobile phone number    modified  whenChanged  \\DateTime  The date when the account was last modified    notes  info  string  Any additional information/notes for the user    office  physicalDeliveryOfficeName  string  The user's office name    organization  o  string  The user's organization name    otherFaxes  otherFacsimileTelephoneNumber  array  Additional fax telephone numbers for the user    otherHomePhones  otherHomePhone  array  Additional home telephone numbers for the user    otherIpPhones  otherIpPhone  array  Additional IP telephone numbers for the user    otherPagers  otherPager  array  Additional pager numbers for the user    otherPhoneNumbers  otherTelephoneNumber  array  Additional telephone numbers for the user    password  unicodePwd  string  The user's password (can only be created or modified)    passwordIsReversible  userAccountControl  bool  Whether the password is reversible    passwordLastSet  pwdLastSet  \\DateTime  The date the password was last set    passwordMustChange  pwdLastSet  bool  Whether the password must change on next login    passwordNeverExpires  userAccountControl  bool  Whether the password is set to never expire    pager  pager  string  The user's pager number    phoneNumber  telephoneNumber  string  The user's primary telephone number    poBox  postOfficeBox  string  The user's PO box number    primaryGroup  primaryGroupID  string  The user's primary group (typically Domain Users)    profilePath  profilePath  string  The user's profile path (ie. \\some\\path)    scriptPath  scriptPath  string  The user's login script (ie. \\server\\scripts\\login.bat)    servicePrincipalNames  servicePrincipalName  array  All of the user's SPNs (ie  ['SQLservice\\foo.bar.com:1456']    sid  objectSid  string  The user's SID (security identifier)    smartCardRequired  userAccountControl  bool  Whether or not the user must use a smart card    state  st  string  The user's state (ie. WI)    streetAddress  streetAddress  string  The user's street address    title  title  string  The user's title (ie. Systems Administrator)    trustedForAllDelegation  userAccountControl  bool  Whether the account is trusted for delegation    trustedForAnyAuthDelegation  userAccountControl  bool  Whether the account is trusted for any auth delegation    username  sAMAccountName  string  The user's username    upn  userPrincipalName  string  The user's user principal name (ie. foo@bar.local)    zipCode  postalCode  string  The user's zip code     AD Group Types  These are typical LDAP group objects.   Type :  LdapObjectType::GROUP  Filter :  (objectClass=group)      LdapTools Name  LDAP Attribute  Value Type  Description      accountName  sAMAccountName  string  The account name of the group    created  whenCreated  \\DateTime  The date the group was created    description  description  string  The description of the group    displayName  displayName  string  The display name for the group    dn  dn  string  The full distinguished name of the group    emailAddress  mail  string  The group's email address    exchangeAddressBookFlags  msExchAddressBookFlags  int     exchangeAlias  mailNickname  string  The group's exchange alias    exchangeHideFromGAL  msExchHideFromAddressLists  bool  Whether the group should be hidden from the address list    exchangeInternalOnly  msExchRequireAuthToSendTo  bool  Whether the group requires authentication to send to it    exchangeSmtpAddresses  proxyAddresses  array  All of the group's assigned SMTP addresses    exchangeDefaultSmtpAddress  proxyAddresses  string  The group's default SMTP address    groups  memberOf  array  The group names the group belongs to (not recursive)    guid  objectGuid  string  The group's GUID    managedBy  managedBy  string  The common name for who the group is managed by    members  member  array  All of the members of the group (not recursive)    modified  whenChanged  \\DateTime  The date when the group was last modified    name  cn  string  The common name (RDN) of the group    notes  info  string  Any additional information/notes for the group    scopeDomainLocal  groupType  bool  Whether or not the group's scope is domain local    scopeGlobal  groupType  bool  Whether or not the group's scope is global    scopeUniversal  groupType  bool  Whether or not the group's scope is universal    sid  objectSid  string  The group's SID (security identifier)    typeBuiltin  groupType  bool  Whether or not this is builtin group    typeDistribution  groupType  bool  Whether or not this is a distribution group    typeSecurity  groupType  bool  Whether or not this is a security group     AD Computer Types  These are typical LDAP computer objects.   Type :  LdapObjectType::COMPUTER  Filter :  (objectCategory=computer)      LdapTools Name  LDAP Attribute  Value Type  Description      accountName  sAMAccountName  string  The account name of the computer    created  whenCreated  \\DateTime  The date the computer object was created    description  description  string  The description of the computer    disabled  userAccountControl  bool  Whether or not the computer object is disabled    displayName  displayName  string  The display name for the computer    dn  dn  string  The full distinguished name of the computer    dnsHostName  dNSHostName  string  The fully qualified domain name (FQDN) of the computer    enabled  userAccountControl  bool  Whether or not the computer object is enabled    groups  memberOf  array  The group names the computer belongs to (not recursive)    guid  objectGuid  string  The computer's GUID    location  location  string  The location of the computer (such as office name)    modified  whenModified  \\DateTime  The date the computer was last modified    name  cn  string  The common name (RDN) of the computer    notes  info  string  Any additional information/notes for the computer    os  operatingSystem  string  The operating system name for the computer object    osServicePack  operatingSystemServicePack  string  The name of the operating system service pack    osVersion  operatingSystemVersion  string  The operating system version number (ie. 6.0)    sid  objectSid  string  The computer's SID (Security Identifier)    trustedForAllDelegation  userAccountControl  bool  Whether the computer is trusted for delegation    trustedForAnyAuthDelegation  userAccountControl  bool  Whether the computer is trusted for any auth delegation     AD Contact Types  These are typical LDAP contact objects.   Type :  LdapObjectType::CONTACT  Filter :  (objectCategory=contact)      LdapTools Name  LDAP Attribute  Value Type  Description      created  whenCreated  \\DateTime  The date the contact was created    description  description  string  The description of the contact    displayName  displayName  string  The display name for the contact    dn  dn  string  The full distinguished name of the contact    emailAddress  mail  string  The contact's email address    exchangeAlias  mailNickname  string  The contact's exchange alias    exchangeHideFromGAL  msExchHideFromAddressLists  bool  Whether the contact should be hidden from the address list    exchangeSmtpAddresses  proxyAddresses  array  All of the contact's assigned SMTP addresses    exchangeDefaultSmtpAddress  proxyAddresses  string  The contact's default SMTP address    firstName  givenName  string  The contact's first name    groups  memberOf  array  The group names the contact belongs to (not recursive)    guid  objectGuid  string  The contact's GUID    lastName  sn  string  The contact's last name    manager  manager  string  The common name of the contact's manager    modified  whenModified  \\DateTime  The date the contact was last modified    notes  info  string  Any additional information/notes for the contact    phoneNumber  telephoneNumber  string  The contact's telephone number    sid  objectSid  string  The contact's SID (Security Identifier)     AD OU Types  These are typical LDAP OU objects.   Type :  LdapObjectType::OU  Filter :  (objectCategory=organizationalUnit)      LdapTools Name  LDAP Attribute  Value Type  Description      city  l  string  The OU's city name    country  c  string  The OU's country name    created  whenCreated  \\DateTime  When date the OU was created    description  description  string  The description of the OU    dn  dn  string  The full distinguished name of the OU    gpoLinks  gPLink  GPOLink[]  All of the GPOs linked to this OU    gpoInheritanceBlocked  gpOptions  bool  Whether or not GPO inheritance is blocked for this OU    guid  objectGuid  string  The OU's GUID    modified  whenModified  \\DateTime  The date the OU was last modified    name  ou  string  The common name (RDN) for the OU    sid  objectSid  string  The OU's SID (Security Identifier)    state  st  string  The OU's state name    streetAddress  streetAddress  string  The OU's street address    zipCode  postalCode  string  The OU's zip code     AD Container Types  These are typical LDAP Container objects.   Type :  LdapObjectType::CONTAINER  Filter :  (objectCategory=container)      LdapTools Name  LDAP Attribute  Value Type  Description      created  whenCreated  \\DateTime  The date the container was created    description  description  string  The description of the container    dn  dn  string  The full distinguished name of the container    guid  objectGuid  string  The container's GUID    modified  whenModified  \\DateTime  The date the container was last modified    name  cn  string  The common name (RDN) for the container     AD Password Settings Objects Types  These are Password Settings Objects, also known as PSOs. They can be used with \nthe type name  PSO .   Filter :  (objectClass=msDS-PasswordSettings)      LdapTools Name  LDAP Attribute  Value Type  Description      appliesTo  msDS-PSOAppliesTo  array  All of the group/user names this PSO is applied to    created  whenCreated  \\DateTime  The date the PSO was created    description  description  string  The description of the PSO    dn  distinguishedName  string  The full distinguished name of the PSO    guid  objectGuid  string  The PSO's GUID    lockoutDuration  msDS-LockoutDuration  \\LdapTools\\Utilities\\ADTimeSpan  Lockout duration time span    lockoutObservationWindow  msDS-LockoutObservationWindow  \\LdapTools\\Utilities\\ADTimeSpan  Lockout observation window time span    lockoutThreshold  msDS-LockoutThreshold  int  Number of attempts before the account is locked    maximumPasswordAge  msDS-MaximumPasswordAge  \\LdapTools\\Utilities\\ADTimeSpan  Max password age time span    minimumPasswordAge  msDS-MinimumPasswordAge  \\LdapTools\\Utilities\\ADTimeSpan  Min password age time span    minimumPasswordLength  msDS-MinimumPasswordLength  int  Min password length    modified  whenChanged  \\DateTime  The date the PSO was last modified    name  cn  string  The common name (RDN) for the PSO    passwordComplexity  msDS-PasswordComplexityEnabled  bool  Whether or not password complexity is enabled    passwordHistoryLength  msDS-PasswordHistoryLength  int  The number of previous passwords that cannot be used    passwordReversibleEncryption  msDS-PasswordReversibleEncryptionEnabled  bool  Whether the password can be decrypted    precedence  msDS-PasswordSettingsPrecedence  int  The precedence (lower value == higher rank) of this PSO    sid  objectSid  string  The PSO's SID (Security Identifier)     AD Deleted Objects Types  These are deleted objects that reside in the AD Recycle Bin.   Type :  LdapObjectType::DELETED  Filter :  (&(isDeleted=TRUE)(lastKnownParent=*))      LdapTools Name  LDAP Attribute  Value Type  Description      created  whenCreated  \\DateTime  The date when the object was created    description  description  string  The description of the deleted object    dn  distinguishedName  string  The full distinguished name of the deleted object    firstName  givenName  string  The first name of the deleted object (if any)    guid  objectGuid  string  The deleted object's GUID    isDeleted  isDeleted  bool  Whether the object is deleted    lastName  sn  string  The last name of the deleted object (if any)    lastKnownLocation  lastKnownParent  string  The DN of the last known location (ie. ou=foo,dc=example,dc=com)    lastKnownName  lastKnownRdn  string  The last known name (RDN) for the deleted object    modified  whenChanged  \\DateTime  The date the deleted object was last modified    name  cn  string  The current name (RDN) of the deleted object    schemaType  objectClass  string  The LdpaTools schema type of the object (ie. user, group, computer, etc)    sid  objectSid  string  The deleted object's SID (Security Identifier)    upn  userPrincipalName  string  The user principal name of the deleted object (if any)     The Exchange Schema   Exchange Server Types  These are Exchange Servers.   Type :  LdapObjectType::EXCHANGE_SERVER  Filter :  (&(objectClass=msExchExchangeServer)(serverRole=*))      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the exchange server    created  whenCreated  \\DateTime  The date the exchange server object was created    guid  objectGuid  string  The exchange server's GUID    modified  whenModified  \\DateTime  The date the exchange server was last modified    roles  msExchCurrentServerRoles  array  All of the role names for the exchange server    sid  objectSid  string  The exchange server's SID (Security Identifier)    version  serialNumber  string  The friendly Exchange version name (ie. Exchange 2013 RTM)     Exchange Database Types  These are Exchange Databases.   Type :  LdapObjectType::EXCHANGE_DATABASE  Filter :  (objectClass=msExchMDB)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the exchange database    created  whenCreated  \\DateTime  The date the exchange database was created    guid  objectGuid  string  The exchange database's GUID    isBeingRestored  msexchdatabasebeingrestored  bool  Whether the database is currently being restored    modified  whenModified  \\DateTime  The date the exchange database was last modified    mountOnStartup  msexchedboffline  bool  Whether or not the database should be mounted on startup    sid  objectSid  string  The exchange database's SID (Security Identifier)     Exchange Recipient Policy Types  These are Exchange Recipient policies.   Type :  LdapObjectType::EXCHANGE_RECIPIENT_POLICY  Filter :  (objectClass=msExchRecipientPolicy)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the recipient policy    created  whenCreated  \\DateTime  The date the recipient policy was created    guid  objectGuid  string  The recipient policy's GUID    modified  whenModified  \\DateTime  The date the recipient policy was last modified    sid  objectSid  string  The recipient policy's SID (Security Identifier     Exchange ActiveSync Policy Types  These are Exchange ActiveSync policies.   Type :  LdapObjectType::EXCHANGE_ACTIVESYNC_POLICY  Filter :  (objectClass=msExchMobileMailboxPolicy)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the ActiveSync policy    created  whenCreated  \\DateTime  The date the ActiveSync policy was created    guid  objectGuid  string  The ActiveSync policy's GUID    modified  whenModified  \\DateTime  The date the ActiveSync policy was last modified    numberOfPreviousPasswordsDisallowed  msExchMobileDeviceNumberOfPreviousPasswordsDisallowed  int  Password history limit    sid  objectSid  string  The ActiveSync policy's SID (Security Identifier)     Exchange RBAC Policy Type  These are Exchange RBAC policies.   Type :  LdapObjectType::EXCHANGE_RBAC_POLICY  Filter :  (objectClass=msExchRBACPolicy)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the RBAC policy    created  whenCreated  \\DateTime  The date the RBAC policy was created    guid  objectGuid  string  The RBAC policy's GUID    modified  whenModified  \\DateTime  The date the RBAC policy was last modified    sid  objectSid  string  The RBAC policy's SID (Security Identifier)     Exchange Transport Rule Types  These are Exchange Transport Rules.   Type :  LdapObjectType::EXCHANGE_TRANSPORT_RULE  Filter :  (objectClass=msExchTransportRule)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the transport rule    created  whenCreated  \\DateTime  The date the transport rule was created    guid  objectGuid  string  The transport rule's GUID    modified  whenModified  \\DateTime  The date the transport rule was last modified    sid  objectSid  string  The transport rule's SID (Security Identifier)     Exchange DAG Types  This represents an Exchange DAG.   Type :  LdapObjectType::EXCHANGE_DAG  Filter :  (objectClass=msExchMDBAvailabilityGroup)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the DAG    created  whenCreated  \\DateTime  The date the DAG was created    guid  objectGuid  string  The DAG's GUID    modified  whenModified  \\DateTime  The date the DAG was last modified    sid  objectSid  string  The DAG's SID (Security Identifier)     Exchange OWA Types  These are the Exchange OWA instances.   Type :  LdapObjectType::EXCHANGE_OWA  Filter :  (objectClass=msExchOWAVirtualDirectory)      LdapTools Name  LDAP Attribute  Value Type  Description      name  cn  string  The common name (RDN) of the OWA object    created  whenCreated  \\DateTime  The date the OWA object was created    guid  objectGuid  string  The OWA's GUID    modified  whenModified  \\DateTime  The date the OWA object was last modified    sid  objectSid  string  The OWA's SID (Security Identifier)    url  msExchInternalHostname  string  The URL of the OWA instance     The OpenLDAP Schema   OpenLDAP User Types  These are typical LDAP user objects.   Type :  LdapObjectType::USER  Filter :  (objectClass=inetOrgPerson)      LdapTools Name  LDAP Attribute  Value Type      city  l  string    company  company  string    country  country  string    created  createTimestamp  \\DateTime    department  department  string    description  description  string    dn  dn  string    emailAddress  mail  string    employeeNumber  employeeNumber  int    fax  facsimileTelephoneNumber  string    firstName  givenName  string    groups  memberOf  array    homeDirectory  homeDirectory  string    homePhone  homePhone  string    initials  initials  string    lastName  sn  string    middleName  middleName  string    modified  modifyTimestamp  \\DateTime    mobilePhone  mobile  string    organization  o  string    password  password  string    pager  pager  string    phoneNumber  telephoneNumber  string    poBox  postOfficeBox  string    state  st  string    streetAddress  streetAddress  string    title  title  string    zipCode  postalCode  string     OpenLDAP Group Types  These are typical LDAP group objects.   Type :  LdapObjectType::GROUP  Filter :  (objectClass=groupOfUniqueNames)      LdapTools Name  LDAP Attribute  Value Type      created  createTimestamp  \\DateTime    description  description  string    displayName  displayName  string    dn  dn  string    members  uniqueMembers  array    modified  modifyTimestamp  \\DateTime    name  cn  string     OpenLDAP OU Types  These are typical LDAP OU objects.   Type :  LdapObjectType::OU  Filter :  (objectClass=organizationalUnit)      LdapTools Name  LDAP Attribute  Value Type      created  createTimestamp  \\DateTime    dn  dn  string    modified  modifyTimestamp  \\DateTime    name  ou  string",
            "title": "Default Schema Attributes"
        },
        {
            "location": "/reference/Events/",
            "text": "Events\n\n\n\n\n\n\nAdding Event Listeners\n\n\nAdding Event Subscribers\n\n\nEvent Names\n\n\nThe LDAP Object Creation Event\n\n\nThe LDAP Object Deletion and Modification Events\n\n\nThe LDAP Object Restore Event\n\n\nThe LDAP Object Schema Event\n\n\nThe LDAP Authentication Event\n\n\nThe LDAP Operation Event\n\n\nUsing a Custom Event Dispatcher\n\n\n\n\nThere are many events you can hook into to extend, and take action on, many common tasks (LDAP deletion, creation, modification, etc).\nThis is done by using a event dispatcher system (the \nsymfony/event-dispatcher\n by default).\n\n\nAdding Event Listeners\n\n\n\n\nTo take action on a specific event you can add a listener that will fire when an event is triggered:\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectEvent;\n\n// Using the LdapManager instance add an event that will get fired before modification of a LDAP object.\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_MODIFY, function(LdapObjectEvent $event) {\n    if ($event->getLdapObject()->hasFirstName('Chad')) {\n        $event->getLdapObject()->setFirstName('foo');\n    }\n});\n\n\n\n\nAdding Event Subscribers\n\n\n\n\nYou can also add an event subscriber to respond to events. This allows you to encapsulate your listeners within the \ncontext of a single class. All event subscribers must implement \nLdapTools\\Event\\EventSubscriberInterface\n, which needs\na single method called \ngetSubscribedEvents()\n that should return an associated array containing keys of an event\nname and values that correspond to the method in the class they should call.\n\n\nFor example, first define a class for your subscriber:\n\n\nuse LdapTools\\Event\\EventSubscriberInterface;\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectEvent;\nuse LdapTools\\Object\\LdapObjectType;\n\nclass UserSubscriber implements EventSubscriberInterface\n{\n    public static function getSubscribedEvents()\n    {\n        return [\n            Event::LDAP_OBJECT_BEFORE_DELETE => 'beforeDelete',\n            Event::LDAP_OBJECT_BEFORE_MODIFY => 'beforeModify',\n        ];\n    }\n\n    public function beforeDelete(LdapObjectEvent $event)\n    {\n        $ldapObject = $event->getLdapObject();\n\n        if ($ldapObject->getType() == LdapObjectType::USER) {\n            // Do some custom stuff before deletion...\n        }\n    }\n\n    public function beforeModify(LdapObjectEvent $event)\n    {\n        $ldapObject = $event->getLdapObject();\n\n        if ($ldapObject->getType() == LdapObjectType::USER) {\n            // Do some custom stuff before modification...\n        }\n    }\n}\n\n\n\n\nThen add that subscriber to the event dispatcher in LdapTools:\n\n\n// Using the LdapManager instance add the event subscriber you created above.\n$ldap->getEventDispatcher()->addSubscriber(new UserSubscriber());\n\n\n\n\nThe Event Names\n\n\n\n\nAll of the event names are defined as constants in the \nLdapTools\\Event\\Event\n class. You can use those constants to\nadd events by name easier. Below is a table listing of the events and when they are triggered. Please note: The Constants\nare located in \nLdapTools\\Event\\Event\n and the \"Event Used\" is the event class passed to the listener. The event classes\nare located in the \nLdapTools\\Event\n namespace.\n\n\n\n\n\n\n\n\nEvent Name\n\n\nConstant\n\n\nEvent Used\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nldap.object.before_modify\n\n\nLDAP_OBJECT_BEFORE_MODIFY\n\n\nLdapObjectEvent\n\n\nTriggered before an object is modified in LDAP. Only triggered when using the \npersist()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.after_modify\n\n\nLDAP_OBJECT_AFTER_MODIFY\n\n\nLdapObjectEvent\n\n\nTriggered after an object is modified in LDAP. Only triggered when using the \npersist()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.before_delete\n\n\nLDAP_OBJECT_BEFORE_DELETE\n\n\nLdapObjectEvent\n\n\nTriggered before an object is deleted from LDAP. Only triggered when using the \ndelete()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.after_delete\n\n\nLDAP_OBJECT_AFTER_DELETE\n\n\nLdapObjectEvent\n\n\nTriggered after an object is deleted from LDAP. Only triggered when using the \ndelete()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.before_create\n\n\nLDAP_OBJECT_BEFORE_CREATE\n\n\nLdapObjectCreationEvent\n\n\nTriggered before an object is created in LDAP. Only triggered when using the \ncreateLdapObject()\n methods of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.after_create\n\n\nLDAP_OBJECT_AFTER_CREATE\n\n\nLdapObjectCreationEvent\n\n\nTriggered after an object is created in LDAP. Only triggered when using the \ncreateLdapObject()\n methods of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.before_move\n\n\nLDAP_OBJECT_BEFORE_MOVE\n\n\nLdapObjectMoveEvent\n\n\nTriggered before an object is moved in LDAP. Only triggered when using the \nmove()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.after_move\n\n\nLDAP_OBJECT_AFTER_MOVE\n\n\nLdapObjectMoveEvent\n\n\nTriggered after an object is moved in LDAP. Only triggered when using the \nmove()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.before_restore\n\n\nLDAP_OBJECT_BEFORE_RESTORE\n\n\nLdapObjectRestoreEvent\n\n\nTriggered before an object is restored in LDAP. Only triggered when using the \nrestore()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.object.after_restore\n\n\nLDAP_OBJECT_AFTER_RESTORE\n\n\nLdapObjectRestoreEvent\n\n\nTriggered after an object is restored in LDAP. Only triggered when using the \nrestore()\n method of the \nLdapManager\n.\n\n\n\n\n\n\nldap.schema.load\n\n\nLDAP_SCHEMA_LOAD\n\n\nLdapObjectSchemaEvent\n\n\nTriggered when a LDAP object type schema is parsed, loaded, and before it gets cached. This allows you to modify the schema without creating your own file.\n\n\n\n\n\n\nldap.authentication.before\n\n\nLDAP_AUTHENTICATION_BEFORE\n\n\nLdapAuthenticationEvent\n\n\nTriggered before an LDAP authentication operation. Allows you to get the operation details before it is sent.\n\n\n\n\n\n\nldap.authentication.after\n\n\nLDAP_AUTHENTICATION_AFTER\n\n\nLdapAuthenticationEvent\n\n\nTriggered after an LDAP authentication operation. Allows you to get the result and any error messages/codes.\n\n\n\n\n\n\nldap.operation.execute.before\n\n\nLDAP_OPERATION_EXECUTE_BEFORE\n\n\nLdapOperationEvent\n\n\nTriggered before any LDAP operation is executed. Allows getting the operation and connection prior to execution.\n\n\n\n\n\n\nldap.operation.execute.after\n\n\nLDAP_OPERATION_EXECUTE_AFTER\n\n\nLdapOperationEvent\n\n\nTriggered after any LDAP operation is executed. Allows getting the operation and connection after execution.\n\n\n\n\n\n\n\n\nThe LDAP Object Creation Event\n\n\n\n\nThe LDAP object creation events functions slightly different than the rest. The event object has setters for the \nLDAP_OBJECT_BEFORE_CREATE\n\nevent so you can modify the container/attributes/DN before they are sent to LDAP. For example:\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectCreationEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_CREATE, function(LdapObjectCreationEvent $event) {\n    $attributes = $event->getData();\n    $container = $event->getContainer();\n    $dn = $event->getDn();\n\n    if (!isset($attributes['title'])) {\n        $attributes['title'] = \"Pizza Maker\";\n        $event->setAttributes($attributes);\n    }\n\n    // Can also explicitly set the DN or container here too...\n    // $event->setDn($dn);\n    // $event->setContainer($container)\n});\n\n\n\n\nThe LDAP Object Move Event\n\n\n\n\nThe LDAP object move event has setters for \nLDAP_OBJECT_BEFORE_MOVE\n so you can modify the container/OU before the \nobject is actually moved. You can also use the event's \ngetContainer()\n method to check where the move was destined for.\nFor example:\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectMoveEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_MOVE, function(LdapObjectMoveEvent $event) {\n    $user = $event->getLdapObject();\n    $container = $event->getContainer(); // Check where the move is going to put them if you want\n\n    // Check the user object and change the location that the move will place them\n    if ($user->firstName == 'Joe') {\n        $event->setContainer('ou=disabled,dc=example,dc=com');\n    }\n});\n\n\n\n\nThe LDAP Object Deletion and Modification Events\n\n\n\n\nBoth the deletion and modification events let you retrieve the LDAP object being processed and add your own custom logic:\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectEvent;\n\n// Check some stuff before the changes are actually saved to LDAP...\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_MODIFY, function(LdapObjectEvent $event) {\n    $user = $event->getLdapObject();\n    // ...\n});\n\n\n\n\nThe same \ngetLdapObject()\n method used above is valid for deletion events as well.\n\n\nThe LDAP Object Restore Event\n\n\n\n\nThe LDAP object restore event has setters for \nLDAP_OBJECT_BEFORE_RESTORE\n so you can modify the container/OU before the \nobject is actually restored. You can also use the event's \ngetContainer()\n method to check where the restored object is\nset to go. However, it may be null if no location was explicitly defined. You can also use the \ngetLdapObject()\n method\nof the event to check the LDAP object for a \nlastKnownLocation\n value. For example:\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectRestoreEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_RESTORE, function(LdapObjectRestoreEvent $event) {\n    $ldapObject = $event->getLdapObject();\n    $container = $event->getContainer();\n\n    if (!$container && $ldapObject->has('lastKnownLocation')) {\n        echo \"Location: \".$ldapObject->get('lastKnownLocation');\n        // Do some other stuff...\n    }\n});\n\n\n\n\nThe LDAP Object Schema Event\n\n\n\n\nWhen you hook into the LDAP Object Schema event you are given the ability to directly modify whatever schema object\nis being loaded before it is actually used. Using this you can directly modify many settings without creating your\nown schema file: attribute mappings, default attributes to select, default container for objects on creation, etc:\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectSchemaEvent;\nuse LdapTools\\Object\\LdapObjectType;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_SCHEMA_LOAD, function(LdapObjectSchemaEvent $event) {\n    $schema = $event->getLdapObjectSchema();\n\n    // Only modify the 'user' schema type, ignore the others for this listener...\n    if ($schema->getObjectType() !== LdapObjectType::USER) {\n        return;\n    }\n\n    // Have your own custom LDAP Object Repository class? Set it using the full class name.\n    $schema->setRepository('\\Acme\\Demo\\UserRepository');\n\n    // Want to get some additional default attributes selected on queries?\n    $select = $schema->getAttributesToSelect();\n    $select[] = 'upn';\n    $select[] = 'groups';\n    $schema->setAttributesToSelect($select);\n\n    // Set these users to always go to a default OU when you create them...\n    $schema->setDefaultContainer(\"OU=Employees,DC=example,DC=local\");\n});\n\n\n\n\nThe LDAP Authentication Event\n\n\n\n\nThe LDAP authentication event allows you to retrieve the operation details using \ngetOperation()\n. You can also retrieve\nthe LDAP response to the authentication operation using the \ngetResponse()\n method. That will only return a response in \nthe \nldap.authentication.after\n event.\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapAuthenticationEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_AUTHENTICATION_BEFORE, function(LdapAuthenticationEvent $event) {\n    $operation = $event->getOperation();\n\n    // The setters for both the username/password can be called as well to modify the operation...\n    echo $operation->getUsername(); // The username to be authenticated.\n    echo $operation->getPassword(); // The password for the username. \n});\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_AUTHENTICATION_AFTER, function(LdapAuthenticationEvent $event) {\n    $operation = $event->getOperation();\n    $response = $event->getResponse();\n\n    if (!$response->isAuthenticated()) {\n        echo \"User '\".$operation->getUsername().\"' failed to login:\".$response->getErrorMessage();\n    }\n});\n\n\n\n\nThe LDAP Operation Event\n\n\n\n\nThe LDAP operation event lets you get the operation object with \ngetOperation()\n and the LDAP connection object by\ncalling \ngetConnection\n. This allows you to take custom action against any LDAP operation before and after it is \nexecuted (add, delete, modify, query, etc). You can also modify parts of the operation object before it is actually \nexecuted.\n\n\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapOperationEvent;\nuse LdapTools\\Operation\\DeleteOperation;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OPERATION_EXECUTE_BEFORE, function(LdapOperationEvent $event) {\n    $operation = $event->getOperation();\n    $connection = $event->getConnection();\n\n    if ($operation instanceof DeleteOperation) {\n        // ...\n    }\n});\n\n\n\n\nUsing a Custom/Specific Event Dispatcher\n\n\n\n\nTo use a specific Event Dispatcher (which must implement \n\\LdapTools\\Event\\EventDispatcherInterface\n) you must set it in\nthe configuration before constructing the LdapManager class:\n\n\nuse LdapTools\\Event\\SymfonyEventDispatcher;\nuse LdapTools\\LdapManager;\nuse LdapTools\\Configuration;\n\n# Load your overall config\n$config = new Configuration();\n\n# ... add/set domain configuration, load from YML, etc...\n\n# Add the event dispatcher to the config\n$dispatcher = new SymfonyEventDispatcher();\n$config->setEventDispatcher($dispatcher);\n\n$ldap = new LdapManager($config);\n\n\n\n\nIf one is not explicitly defined it will instantiate a default event dispatcher (\n\\LdapTools\\Event\\SymfonyEventDispatcher\n).",
            "title": "Events"
        },
        {
            "location": "/reference/Events/#events",
            "text": "Adding Event Listeners  Adding Event Subscribers  Event Names  The LDAP Object Creation Event  The LDAP Object Deletion and Modification Events  The LDAP Object Restore Event  The LDAP Object Schema Event  The LDAP Authentication Event  The LDAP Operation Event  Using a Custom Event Dispatcher   There are many events you can hook into to extend, and take action on, many common tasks (LDAP deletion, creation, modification, etc).\nThis is done by using a event dispatcher system (the  symfony/event-dispatcher  by default).",
            "title": "Events"
        },
        {
            "location": "/reference/Events/#adding-event-listeners",
            "text": "To take action on a specific event you can add a listener that will fire when an event is triggered:  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectEvent;\n\n// Using the LdapManager instance add an event that will get fired before modification of a LDAP object.\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_MODIFY, function(LdapObjectEvent $event) {\n    if ($event->getLdapObject()->hasFirstName('Chad')) {\n        $event->getLdapObject()->setFirstName('foo');\n    }\n});",
            "title": "Adding Event Listeners"
        },
        {
            "location": "/reference/Events/#adding-event-subscribers",
            "text": "You can also add an event subscriber to respond to events. This allows you to encapsulate your listeners within the \ncontext of a single class. All event subscribers must implement  LdapTools\\Event\\EventSubscriberInterface , which needs\na single method called  getSubscribedEvents()  that should return an associated array containing keys of an event\nname and values that correspond to the method in the class they should call.  For example, first define a class for your subscriber:  use LdapTools\\Event\\EventSubscriberInterface;\nuse LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectEvent;\nuse LdapTools\\Object\\LdapObjectType;\n\nclass UserSubscriber implements EventSubscriberInterface\n{\n    public static function getSubscribedEvents()\n    {\n        return [\n            Event::LDAP_OBJECT_BEFORE_DELETE => 'beforeDelete',\n            Event::LDAP_OBJECT_BEFORE_MODIFY => 'beforeModify',\n        ];\n    }\n\n    public function beforeDelete(LdapObjectEvent $event)\n    {\n        $ldapObject = $event->getLdapObject();\n\n        if ($ldapObject->getType() == LdapObjectType::USER) {\n            // Do some custom stuff before deletion...\n        }\n    }\n\n    public function beforeModify(LdapObjectEvent $event)\n    {\n        $ldapObject = $event->getLdapObject();\n\n        if ($ldapObject->getType() == LdapObjectType::USER) {\n            // Do some custom stuff before modification...\n        }\n    }\n}  Then add that subscriber to the event dispatcher in LdapTools:  // Using the LdapManager instance add the event subscriber you created above.\n$ldap->getEventDispatcher()->addSubscriber(new UserSubscriber());",
            "title": "Adding Event Subscribers"
        },
        {
            "location": "/reference/Events/#the-event-names",
            "text": "All of the event names are defined as constants in the  LdapTools\\Event\\Event  class. You can use those constants to\nadd events by name easier. Below is a table listing of the events and when they are triggered. Please note: The Constants\nare located in  LdapTools\\Event\\Event  and the \"Event Used\" is the event class passed to the listener. The event classes\nare located in the  LdapTools\\Event  namespace.     Event Name  Constant  Event Used  Description      ldap.object.before_modify  LDAP_OBJECT_BEFORE_MODIFY  LdapObjectEvent  Triggered before an object is modified in LDAP. Only triggered when using the  persist()  method of the  LdapManager .    ldap.object.after_modify  LDAP_OBJECT_AFTER_MODIFY  LdapObjectEvent  Triggered after an object is modified in LDAP. Only triggered when using the  persist()  method of the  LdapManager .    ldap.object.before_delete  LDAP_OBJECT_BEFORE_DELETE  LdapObjectEvent  Triggered before an object is deleted from LDAP. Only triggered when using the  delete()  method of the  LdapManager .    ldap.object.after_delete  LDAP_OBJECT_AFTER_DELETE  LdapObjectEvent  Triggered after an object is deleted from LDAP. Only triggered when using the  delete()  method of the  LdapManager .    ldap.object.before_create  LDAP_OBJECT_BEFORE_CREATE  LdapObjectCreationEvent  Triggered before an object is created in LDAP. Only triggered when using the  createLdapObject()  methods of the  LdapManager .    ldap.object.after_create  LDAP_OBJECT_AFTER_CREATE  LdapObjectCreationEvent  Triggered after an object is created in LDAP. Only triggered when using the  createLdapObject()  methods of the  LdapManager .    ldap.object.before_move  LDAP_OBJECT_BEFORE_MOVE  LdapObjectMoveEvent  Triggered before an object is moved in LDAP. Only triggered when using the  move()  method of the  LdapManager .    ldap.object.after_move  LDAP_OBJECT_AFTER_MOVE  LdapObjectMoveEvent  Triggered after an object is moved in LDAP. Only triggered when using the  move()  method of the  LdapManager .    ldap.object.before_restore  LDAP_OBJECT_BEFORE_RESTORE  LdapObjectRestoreEvent  Triggered before an object is restored in LDAP. Only triggered when using the  restore()  method of the  LdapManager .    ldap.object.after_restore  LDAP_OBJECT_AFTER_RESTORE  LdapObjectRestoreEvent  Triggered after an object is restored in LDAP. Only triggered when using the  restore()  method of the  LdapManager .    ldap.schema.load  LDAP_SCHEMA_LOAD  LdapObjectSchemaEvent  Triggered when a LDAP object type schema is parsed, loaded, and before it gets cached. This allows you to modify the schema without creating your own file.    ldap.authentication.before  LDAP_AUTHENTICATION_BEFORE  LdapAuthenticationEvent  Triggered before an LDAP authentication operation. Allows you to get the operation details before it is sent.    ldap.authentication.after  LDAP_AUTHENTICATION_AFTER  LdapAuthenticationEvent  Triggered after an LDAP authentication operation. Allows you to get the result and any error messages/codes.    ldap.operation.execute.before  LDAP_OPERATION_EXECUTE_BEFORE  LdapOperationEvent  Triggered before any LDAP operation is executed. Allows getting the operation and connection prior to execution.    ldap.operation.execute.after  LDAP_OPERATION_EXECUTE_AFTER  LdapOperationEvent  Triggered after any LDAP operation is executed. Allows getting the operation and connection after execution.",
            "title": "The Event Names"
        },
        {
            "location": "/reference/Events/#the-ldap-object-creation-event",
            "text": "The LDAP object creation events functions slightly different than the rest. The event object has setters for the  LDAP_OBJECT_BEFORE_CREATE \nevent so you can modify the container/attributes/DN before they are sent to LDAP. For example:  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectCreationEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_CREATE, function(LdapObjectCreationEvent $event) {\n    $attributes = $event->getData();\n    $container = $event->getContainer();\n    $dn = $event->getDn();\n\n    if (!isset($attributes['title'])) {\n        $attributes['title'] = \"Pizza Maker\";\n        $event->setAttributes($attributes);\n    }\n\n    // Can also explicitly set the DN or container here too...\n    // $event->setDn($dn);\n    // $event->setContainer($container)\n});",
            "title": "The LDAP Object Creation Event"
        },
        {
            "location": "/reference/Events/#the-ldap-object-move-event",
            "text": "The LDAP object move event has setters for  LDAP_OBJECT_BEFORE_MOVE  so you can modify the container/OU before the \nobject is actually moved. You can also use the event's  getContainer()  method to check where the move was destined for.\nFor example:  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectMoveEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_MOVE, function(LdapObjectMoveEvent $event) {\n    $user = $event->getLdapObject();\n    $container = $event->getContainer(); // Check where the move is going to put them if you want\n\n    // Check the user object and change the location that the move will place them\n    if ($user->firstName == 'Joe') {\n        $event->setContainer('ou=disabled,dc=example,dc=com');\n    }\n});",
            "title": "The LDAP Object Move Event"
        },
        {
            "location": "/reference/Events/#the-ldap-object-deletion-and-modification-events",
            "text": "Both the deletion and modification events let you retrieve the LDAP object being processed and add your own custom logic:  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectEvent;\n\n// Check some stuff before the changes are actually saved to LDAP...\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_MODIFY, function(LdapObjectEvent $event) {\n    $user = $event->getLdapObject();\n    // ...\n});  The same  getLdapObject()  method used above is valid for deletion events as well.",
            "title": "The LDAP Object Deletion and Modification Events"
        },
        {
            "location": "/reference/Events/#the-ldap-object-restore-event",
            "text": "The LDAP object restore event has setters for  LDAP_OBJECT_BEFORE_RESTORE  so you can modify the container/OU before the \nobject is actually restored. You can also use the event's  getContainer()  method to check where the restored object is\nset to go. However, it may be null if no location was explicitly defined. You can also use the  getLdapObject()  method\nof the event to check the LDAP object for a  lastKnownLocation  value. For example:  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectRestoreEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OBJECT_BEFORE_RESTORE, function(LdapObjectRestoreEvent $event) {\n    $ldapObject = $event->getLdapObject();\n    $container = $event->getContainer();\n\n    if (!$container && $ldapObject->has('lastKnownLocation')) {\n        echo \"Location: \".$ldapObject->get('lastKnownLocation');\n        // Do some other stuff...\n    }\n});",
            "title": "The LDAP Object Restore Event"
        },
        {
            "location": "/reference/Events/#the-ldap-object-schema-event",
            "text": "When you hook into the LDAP Object Schema event you are given the ability to directly modify whatever schema object\nis being loaded before it is actually used. Using this you can directly modify many settings without creating your\nown schema file: attribute mappings, default attributes to select, default container for objects on creation, etc:  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapObjectSchemaEvent;\nuse LdapTools\\Object\\LdapObjectType;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_SCHEMA_LOAD, function(LdapObjectSchemaEvent $event) {\n    $schema = $event->getLdapObjectSchema();\n\n    // Only modify the 'user' schema type, ignore the others for this listener...\n    if ($schema->getObjectType() !== LdapObjectType::USER) {\n        return;\n    }\n\n    // Have your own custom LDAP Object Repository class? Set it using the full class name.\n    $schema->setRepository('\\Acme\\Demo\\UserRepository');\n\n    // Want to get some additional default attributes selected on queries?\n    $select = $schema->getAttributesToSelect();\n    $select[] = 'upn';\n    $select[] = 'groups';\n    $schema->setAttributesToSelect($select);\n\n    // Set these users to always go to a default OU when you create them...\n    $schema->setDefaultContainer(\"OU=Employees,DC=example,DC=local\");\n});",
            "title": "The LDAP Object Schema Event"
        },
        {
            "location": "/reference/Events/#the-ldap-authentication-event",
            "text": "The LDAP authentication event allows you to retrieve the operation details using  getOperation() . You can also retrieve\nthe LDAP response to the authentication operation using the  getResponse()  method. That will only return a response in \nthe  ldap.authentication.after  event.  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapAuthenticationEvent;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_AUTHENTICATION_BEFORE, function(LdapAuthenticationEvent $event) {\n    $operation = $event->getOperation();\n\n    // The setters for both the username/password can be called as well to modify the operation...\n    echo $operation->getUsername(); // The username to be authenticated.\n    echo $operation->getPassword(); // The password for the username. \n});\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_AUTHENTICATION_AFTER, function(LdapAuthenticationEvent $event) {\n    $operation = $event->getOperation();\n    $response = $event->getResponse();\n\n    if (!$response->isAuthenticated()) {\n        echo \"User '\".$operation->getUsername().\"' failed to login:\".$response->getErrorMessage();\n    }\n});",
            "title": "The LDAP Authentication Event"
        },
        {
            "location": "/reference/Events/#the-ldap-operation-event",
            "text": "The LDAP operation event lets you get the operation object with  getOperation()  and the LDAP connection object by\ncalling  getConnection . This allows you to take custom action against any LDAP operation before and after it is \nexecuted (add, delete, modify, query, etc). You can also modify parts of the operation object before it is actually \nexecuted.  use LdapTools\\Event\\Event;\nuse LdapTools\\Event\\LdapOperationEvent;\nuse LdapTools\\Operation\\DeleteOperation;\n\n$ldap->getEventDispatcher()->addListener(Event::LDAP_OPERATION_EXECUTE_BEFORE, function(LdapOperationEvent $event) {\n    $operation = $event->getOperation();\n    $connection = $event->getConnection();\n\n    if ($operation instanceof DeleteOperation) {\n        // ...\n    }\n});",
            "title": "The LDAP Operation Event"
        },
        {
            "location": "/reference/Events/#using-a-customspecific-event-dispatcher",
            "text": "To use a specific Event Dispatcher (which must implement  \\LdapTools\\Event\\EventDispatcherInterface ) you must set it in\nthe configuration before constructing the LdapManager class:  use LdapTools\\Event\\SymfonyEventDispatcher;\nuse LdapTools\\LdapManager;\nuse LdapTools\\Configuration;\n\n# Load your overall config\n$config = new Configuration();\n\n# ... add/set domain configuration, load from YML, etc...\n\n# Add the event dispatcher to the config\n$dispatcher = new SymfonyEventDispatcher();\n$config->setEventDispatcher($dispatcher);\n\n$ldap = new LdapManager($config);  If one is not explicitly defined it will instantiate a default event dispatcher ( \\LdapTools\\Event\\SymfonyEventDispatcher ).",
            "title": "Using a Custom/Specific Event Dispatcher"
        },
        {
            "location": "/reference/Logging/",
            "text": "Logging\n\n\n\n\nLogging is available for the following LDAP operations performed by the connection class: add, modify, delete, move, and\nrename. To enable logging you must pass a logger to the \nsetLogger($logger)\n method of the main \n\\LdapTools\\Configuration\n\nclass. The only requirement for the class is that it implements \n\\LdapTools\\Log\\LdapLoggerInterface\n.\n\n\nEnabling Logging for the LdapManager\n\n\n\n\nTo enable logging for all connections in the LdapManager you can pass a class implementing \n\\LdapTools\\Log\\LdapLoggerInterface\n\nas the third argument to the constructor. There are two classes that implement this interface that come with LdapTools.\nThe simplest implementation is a logger that outputs log information to standard output using echo statements. The other\nis a class that lets you chain several loggers into one.\n\n\nuse LdapTools\\Log\\EchoLdapLogger;\nuse LdapTools\\Log\\LoggerChain;\nuse LdapTools\\LdapManager;\nuse LdapTools\\Configuration;\n\n# Load your overall config\n$config = new Configuration();\n\n# ... add/set domain configuration, load from YML, etc...\n\n# Adds a simple echo logger to the config\n$logger = new EchoLdapLogger();\n$config->setLogger($logger);\n\n$ldap = new LdapManager($config);\n\n# Add a logger chain so several loggers can be used at once\n$logger = new LoggerChain();\n\n# Add some loggers to the chain...\n$logger->addLogger(new EchoLdapLogger());\n$logger->addLogger(new EchoLdapLogger());\n$config->setLogger($logger);\n\n# You will now see duplicated echo statements as the result of both loggers.\n# Not a very useful example, but demonstrates the capability for several logging mechanisms.\n$ldap = new LdapManager($config);\n\n\n\n\nThe LdapLoggerInterface and the LogOperation\n\n\nTo do your own logging you can extend the LdapLoggerInterface. This class has two method requirements: \nstart()\n and \nend()\n.\nThe start method is called before the operation is executed by LDAP and the end method is called immediately afterwards.\nBoth methods are passed an instance of the \n\\LdapTools\\Log\\LogOperation\n class. This contains all of the useful information\nabout what operation just executed.",
            "title": "Logging"
        },
        {
            "location": "/reference/Logging/#logging",
            "text": "Logging is available for the following LDAP operations performed by the connection class: add, modify, delete, move, and\nrename. To enable logging you must pass a logger to the  setLogger($logger)  method of the main  \\LdapTools\\Configuration \nclass. The only requirement for the class is that it implements  \\LdapTools\\Log\\LdapLoggerInterface .",
            "title": "Logging"
        },
        {
            "location": "/reference/Logging/#enabling-logging-for-the-ldapmanager",
            "text": "To enable logging for all connections in the LdapManager you can pass a class implementing  \\LdapTools\\Log\\LdapLoggerInterface \nas the third argument to the constructor. There are two classes that implement this interface that come with LdapTools.\nThe simplest implementation is a logger that outputs log information to standard output using echo statements. The other\nis a class that lets you chain several loggers into one.  use LdapTools\\Log\\EchoLdapLogger;\nuse LdapTools\\Log\\LoggerChain;\nuse LdapTools\\LdapManager;\nuse LdapTools\\Configuration;\n\n# Load your overall config\n$config = new Configuration();\n\n# ... add/set domain configuration, load from YML, etc...\n\n# Adds a simple echo logger to the config\n$logger = new EchoLdapLogger();\n$config->setLogger($logger);\n\n$ldap = new LdapManager($config);\n\n# Add a logger chain so several loggers can be used at once\n$logger = new LoggerChain();\n\n# Add some loggers to the chain...\n$logger->addLogger(new EchoLdapLogger());\n$logger->addLogger(new EchoLdapLogger());\n$config->setLogger($logger);\n\n# You will now see duplicated echo statements as the result of both loggers.\n# Not a very useful example, but demonstrates the capability for several logging mechanisms.\n$ldap = new LdapManager($config);",
            "title": "Enabling Logging for the LdapManager"
        },
        {
            "location": "/reference/Logging/#the-ldaploggerinterface-and-the-logoperation",
            "text": "To do your own logging you can extend the LdapLoggerInterface. This class has two method requirements:  start()  and  end() .\nThe start method is called before the operation is executed by LDAP and the end method is called immediately afterwards.\nBoth methods are passed an instance of the  \\LdapTools\\Log\\LogOperation  class. This contains all of the useful information\nabout what operation just executed.",
            "title": "The LdapLoggerInterface and the LogOperation"
        },
        {
            "location": "/reference/Main-Configuration/",
            "text": "Main Configuration\n\n\n\n\n\n\nManual Configuration\n\n\nYAML Configuration\n\n\nMain Configuration Options\n\n\nDomain Configuration Options\n\n\n\n\nYou can either choose to configure your settings via a file (YAML) or directly using the methods on the \nConfiguration\n \nand \nDomainConfiguration\n classes. Once you have an instance of the configuration, you can pass it to the \nLdapManager\n\nclass.\n\n\nManual Configuration\n\n\n\n\nuse LdapTools\\Configuration;\nuse LdapTools\\DomainConfiguration;\nuse LdapTools\\LdapManager;\n\n// A new configuration object contains the most common default settings.\n$config = new Configuration();\n\n// A domain configuration object. Requires a domain name, servers, username, and password. \n$domain = (new DomainConfiguration('mydomain.com'))\n   ->setBaseDn('dc=mydomain,dc=com')\n   ->setServers(['dc01'])\n   ->setUsername('username')\n   ->setPassword('password');\n$altDomain = (new DomainConfiguration('foo.bar'))\n   ->setBaseDn('dc=foo,dc=bar')\n   ->setServers(['foo'])\n   ->setUsername('username')\n   ->setPassword('password')\n   ->setLazyBind(true)\n   ->setLdapType('openldap');\n$config->addDomain($domain, $altDomain);\n// Defaults to the first domain added. You can change this if you want.\n$config->setDefaultDomain('foo.bar');\n\n// The LdapManager provides an easy point of access to some different classes.\n$ldap = new LdapManager($config);\n\n\n\n\nYAML Configuration\n\n\n\n\nThe easy way to configure everything is by using a single YAML configuration file. See the \nexample configuration\n\nfor a detailed overview. The YAML file is split into a \ngeneral\n section and a \ndomains\n section. \n\n\ngeneral:\n...\ndomains:\n    domain_one:\n    ...\n    domain_two:\n    ...\n\n\n\n\nOnce you have a YAML configuration file defined, you can configure the class very easily:\n\n\nuse LdapTools\\Configuration;\nuse LdapTools\\LdapManager;\n\n$config = (new Configuration())->load('/path/to/ldap/config.yml');\n$ldap = new LdapManager($config);\n\n\n\n\nThe below reference describes each possible configuration directive.\n\n\nGeneral Section\n\n\n\n\ndefault_domain\n\n\nIf you have added more than one domain configuration, set this to the domain name (ie. \nexample.com\n) you would like to \nbe the default context when using the \nLdapManager\n class.\n\n\nDefault\n: If more than one domain is present, the first domain added is the default domain.\n\n\n\n\nschema_format\n\n\nThe format that the schema file is in. Only \nyml\n is available at present.\n\n\nDefault\n: \nyml\n\n\n\n\nschema_folder\n\n\nThis is where the LDAP object schema definition files are stored.\n\n\nDefault\n: The \nresources/schema\n folder in the libraries root directory.\n\n\n\n\ncache_type\n\n\nThe default caching mechanism to use when parsing schema files. Options are \nstash\n, \ndoctrine\n, or \nnone\n. When \nstash\n\n or \ndoctrine\n is used it will take the parsed LDAP schema objects and cache them to disk. It will then use the cache \ninstead of re-parsing the schema each time. \n\n\nThe \nstash\n type will auto-refresh the cache if it detects that the schema file has been modified since it was last\ncached. it will re-parse it and cache it again. This behavior can be changed by using the \ncache_options\n\ndescribed below and setting \ncache_auto_refresh: false\n.\n\n\nTo manually clear the cache so it rebuilds you can call the \nclear()\n method on the cache from the \nLdapManager\n class.\n\n\n// Clears all contents of the cache.\n$ldapManager->getCache()->clear();\n\n\n\n\nTo use the \nstash\n type you must install \nStash\n.\nTo use the \ndoctrine\n type you must install \nDoctrine Cache\n.\n\n\nDefault:\n \nnone\n\n\n\n\ncache_options\n\n\nAn array of options that will be passed to the cache type when it is instantiated.\n\n\nFor the \ndoctrine\n and \nstash\n types you can pass a few options that control how they work:\n\n\ncache_options:\n    # Make it so the cache must be manually cleared for it to update. Stash auto-refreshes by default.\n    # The doctrine type does not support auto-refresh so this option will not affect it.\n    cache_auto_refresh: false\n    # The full path to the location where the cache contents should be kept. If not set it defaults to the systems temp\n    # directory.\n    cache_folder: /tmp/www\n    # The subdirectory/location name in the cache directory to store the cache. Defaults to 'ldaptools'. \n    cache_prefix: ldaptools\n\n\n\n\nDefaults\n: No options are passed by default.\n\n\n\n\nattribute_converters\n\n\nAn array of converter to class name mappings that will be registered in the \nLdapManager\n for use in the schemas.\n\n\ngeneral:\n    attribute_converters:\n        # This class must extend \\LdapTools\\AttributeConverter\\AttributeConverterInterface !\n        my_converter: '\\My\\Converter\\Class'\n\n\n\n\nDefaults\n: No additional attribute converters are registered by default.\n\n\n\n\nDomain Section\n\n\n\n\ndomain_name \n(REQUIRED)\n\n\nThe FQDN of the domain (ie. \nexample.com\n).\n\n\n\n\nusername \n(REQUIRED)\n\n\nThe username to use when binding to LDAP. When using Active Directory, the username can be in any of these formats:\n\n\n\n\nA typical username in UPN form (ie. \nuser@domain.com\n).\n\n\nA string GUID of an account (ie. \n8227ab9b-b307-45eb-a50c-6f6cb3946318\n)\n\n\nA string SID of an account (ie. \nS-1-5-21-1004336348-1177238915-682003330-512\n)\n\n\nThe full distinguished name of an account.\n\n\n\n\nIf none of those forms are detected, then by default it will force the username into UPN form based off of the domain\nname. However, if the LDAP type is \nopenldap\n, then it will just pass the unmodified username along. This behavior can \nbe modified using the \nbind_format\n option.\n\n\n\n\npassword \n(REQUIRED)\n\n\nThe password to use when binding to LDAP.\n\n\n\n\nbase_dn\n\n\nThe base DN for searches (ie. The default naming context: \ndc=example,dc=com\n). If this is empty then the RootDSE will\nbe queried for the \ndefaultNamingContext\n value. It is recommended that you define this manually for better performance.\n\n\n\n\nservers\n\n\nAn array of LDAP servers (ie. \n[ 'dc01' ]\n). When more than one server name is used it will attempt each one until it\nsuccessfully connects. If no servers are given then it will attempt to lookup the LDAP servers for the domain by\nquerying DNS. It is recommended that you define this manually for faster and more predictable results.\n\n\n\n\nbind_format\n\n\nDefines how the username will be passed to LDAP on a bind/authentication attempt. This is a string that accepts 2\nparameters: \n%username%\n and \n%domainname%\n. By default, the AD bind format is \n%username%@%domainname%\n. With OpenLDAP\nit is simply \n%username%\n. However, you could set it to an DN path, such as: \nCN=%username%,OU=Users,DC=example,DC=com\n\n\n\n\nserver_selection\n\n\nWhen more than one server is listed for a domain, choose which one is selected for the connection. The possible choices \nare \norder\n (tried in the order they appear) or \nrandom\n. \n\n\nDefault\n: \norder\n\n\n\n\nuse_paging\n\n\nWhether or not the connection should try to page results by default.\n\n\nDefault\n: \ntrue\n\n\n\n\npage_size\n\n\nThe default page size to use for paging operations.\n\n\nDefault\n: \n1000\n\n\n\n\nport\n\n\nThe default port number to connect to LDAP on.\n\n\nDefault\n: \n389\n\n\n\n\nuse_ssl\n\n\nWhether or not to talk to LDAP over SSL. The default is \nfalse\n. Typically you want to use the \nuse_tls\n directive (in\nthe case of Active Directory). Setting this to \ntrue\n also changes the port to \n636\n.\n\n\nDefault\n: \nfalse\n\n\n\n\nuse_tls\n\n\nWhether or not to initiate TLS when connecting to LDAP. This is required for certain LDAP operations (such as password \nchanges in Active Directory). When using this directive you will often have to configure your \nldap.conf\n file and add\nthe \nTLS_REQCERT never\n line. The \nldap.conf\n file is in the following default locations:\n\n\n\n\nWindows: \nC:\\OpenLDAP\\sysconf\\ldap.conf\n (If this directory structure does not exist, then create it...and the file)\n\n\nLinux: \n/etc/ldap/ldap.conf\n\n\n\n\nHowever, be warned that using \nTLS_REQCERT never\n can be a bit of a security risk as it ignores invalid certificates.\nConsider copying your domain CA cert to \n/etc/ssl/certs\n then reference it in your \nldap.conf\n with the \nTLS_CACERT /etc/ssl/certs/ca.pem\n\noption combined with \nTLS_REQCERT hard\n.\n\n\nFor more information on obtaining/using your LDAP SSL certificates, see \nthis cookbook doc\n.\n\n\nDefault\n: \nfalse\n\n\n\n\nldap_type\n\n\nThe LDAP type for this domain. Choices are \nad\n or \nopenldap\n.\n\n\nDefault\n: \nad\n\n\n\n\nlazy_bind\n\n\nIf set to \ntrue\n, then the connection will not automatically connect and bind when first created.\n\n\nDefault\n: \nfalse\n\n\n\n\nschema_name\n\n\nThe schema name to use for this domain. This typically refers to the name of the schema file to use within the path \ndefined by the \nschema_folder\n directive in the general section. \n\n\nDefault\n: The same value set for \nldap_type\n.\n\n\n\n\nencoding\n\n\nThe encoding to use for this domain. Usernames, passwords, and any values not explicitly assigned to an Attribute\nConverter will be encoded with this encoding choice.\n\n\nDefault\n: UTF-8\n\n\n\n\nldap_options\n\n\nThe \nLDAP_OPT_*\n constants and values to use when connecting to LDAP. This is expected to be an array:\n\n\ndomains:\n    example:\n        ldap_options:\n            ldap_opt_protocol_version: 3\n            ldap_opt_referrals: 0\n\n\n\n\nDefault\n: \n[LDAP_OPT_PROTOCOL_VERSION => 3, LDAP_OPT_REFERRALS => 0]\n\n\n\n\nidle_reconnect\n\n\nThe elapsed time (in seconds) when an idle connection will attempt to reconnect to LDAP. A value of 0 means never. This\nis useful for long running processes where an LDAP connection is left open.\n\n\nYou should set this value sightly below the max idle time for your LDAP server. For Active Directory, idle connections \ntimeout after 15 minutes by default. For OpenLDAP, idle connections never timeout by default. You should check your\nLDAP server settings before changing this value.\n\n\ndomains:\n    example:\n        idle_reconnect: 0\n\n\n\n\nDefault\n: \n600\n (10 minutes)\n\n\n\n\nconnect_timeout\n\n\nThe elapsed time (in seconds) to attempt the initial connection to the LDAP server. If a connection cannot be established\nwithin this time the server will be considered unreachable/down.\n\n\ndomains:\n    example:\n        connect_timeout: 5\n\n\n\n\nDefault\n: \n1",
            "title": "Main Configuration"
        },
        {
            "location": "/reference/Main-Configuration/#main-configuration",
            "text": "Manual Configuration  YAML Configuration  Main Configuration Options  Domain Configuration Options   You can either choose to configure your settings via a file (YAML) or directly using the methods on the  Configuration  \nand  DomainConfiguration  classes. Once you have an instance of the configuration, you can pass it to the  LdapManager \nclass.",
            "title": "Main Configuration"
        },
        {
            "location": "/reference/Main-Configuration/#manual-configuration",
            "text": "use LdapTools\\Configuration;\nuse LdapTools\\DomainConfiguration;\nuse LdapTools\\LdapManager;\n\n// A new configuration object contains the most common default settings.\n$config = new Configuration();\n\n// A domain configuration object. Requires a domain name, servers, username, and password. \n$domain = (new DomainConfiguration('mydomain.com'))\n   ->setBaseDn('dc=mydomain,dc=com')\n   ->setServers(['dc01'])\n   ->setUsername('username')\n   ->setPassword('password');\n$altDomain = (new DomainConfiguration('foo.bar'))\n   ->setBaseDn('dc=foo,dc=bar')\n   ->setServers(['foo'])\n   ->setUsername('username')\n   ->setPassword('password')\n   ->setLazyBind(true)\n   ->setLdapType('openldap');\n$config->addDomain($domain, $altDomain);\n// Defaults to the first domain added. You can change this if you want.\n$config->setDefaultDomain('foo.bar');\n\n// The LdapManager provides an easy point of access to some different classes.\n$ldap = new LdapManager($config);",
            "title": "Manual Configuration"
        },
        {
            "location": "/reference/Main-Configuration/#yaml-configuration",
            "text": "The easy way to configure everything is by using a single YAML configuration file. See the  example configuration \nfor a detailed overview. The YAML file is split into a  general  section and a  domains  section.   general:\n...\ndomains:\n    domain_one:\n    ...\n    domain_two:\n    ...  Once you have a YAML configuration file defined, you can configure the class very easily:  use LdapTools\\Configuration;\nuse LdapTools\\LdapManager;\n\n$config = (new Configuration())->load('/path/to/ldap/config.yml');\n$ldap = new LdapManager($config);  The below reference describes each possible configuration directive.  General Section   default_domain  If you have added more than one domain configuration, set this to the domain name (ie.  example.com ) you would like to \nbe the default context when using the  LdapManager  class.  Default : If more than one domain is present, the first domain added is the default domain.   schema_format  The format that the schema file is in. Only  yml  is available at present.  Default :  yml   schema_folder  This is where the LDAP object schema definition files are stored.  Default : The  resources/schema  folder in the libraries root directory.   cache_type  The default caching mechanism to use when parsing schema files. Options are  stash ,  doctrine , or  none . When  stash \n or  doctrine  is used it will take the parsed LDAP schema objects and cache them to disk. It will then use the cache \ninstead of re-parsing the schema each time.   The  stash  type will auto-refresh the cache if it detects that the schema file has been modified since it was last\ncached. it will re-parse it and cache it again. This behavior can be changed by using the  cache_options \ndescribed below and setting  cache_auto_refresh: false .  To manually clear the cache so it rebuilds you can call the  clear()  method on the cache from the  LdapManager  class.  // Clears all contents of the cache.\n$ldapManager->getCache()->clear();  To use the  stash  type you must install  Stash .\nTo use the  doctrine  type you must install  Doctrine Cache .  Default:   none   cache_options  An array of options that will be passed to the cache type when it is instantiated.  For the  doctrine  and  stash  types you can pass a few options that control how they work:  cache_options:\n    # Make it so the cache must be manually cleared for it to update. Stash auto-refreshes by default.\n    # The doctrine type does not support auto-refresh so this option will not affect it.\n    cache_auto_refresh: false\n    # The full path to the location where the cache contents should be kept. If not set it defaults to the systems temp\n    # directory.\n    cache_folder: /tmp/www\n    # The subdirectory/location name in the cache directory to store the cache. Defaults to 'ldaptools'. \n    cache_prefix: ldaptools  Defaults : No options are passed by default.   attribute_converters  An array of converter to class name mappings that will be registered in the  LdapManager  for use in the schemas.  general:\n    attribute_converters:\n        # This class must extend \\LdapTools\\AttributeConverter\\AttributeConverterInterface !\n        my_converter: '\\My\\Converter\\Class'  Defaults : No additional attribute converters are registered by default.   Domain Section   domain_name  (REQUIRED)  The FQDN of the domain (ie.  example.com ).   username  (REQUIRED)  The username to use when binding to LDAP. When using Active Directory, the username can be in any of these formats:   A typical username in UPN form (ie.  user@domain.com ).  A string GUID of an account (ie.  8227ab9b-b307-45eb-a50c-6f6cb3946318 )  A string SID of an account (ie.  S-1-5-21-1004336348-1177238915-682003330-512 )  The full distinguished name of an account.   If none of those forms are detected, then by default it will force the username into UPN form based off of the domain\nname. However, if the LDAP type is  openldap , then it will just pass the unmodified username along. This behavior can \nbe modified using the  bind_format  option.   password  (REQUIRED)  The password to use when binding to LDAP.   base_dn  The base DN for searches (ie. The default naming context:  dc=example,dc=com ). If this is empty then the RootDSE will\nbe queried for the  defaultNamingContext  value. It is recommended that you define this manually for better performance.   servers  An array of LDAP servers (ie.  [ 'dc01' ] ). When more than one server name is used it will attempt each one until it\nsuccessfully connects. If no servers are given then it will attempt to lookup the LDAP servers for the domain by\nquerying DNS. It is recommended that you define this manually for faster and more predictable results.   bind_format  Defines how the username will be passed to LDAP on a bind/authentication attempt. This is a string that accepts 2\nparameters:  %username%  and  %domainname% . By default, the AD bind format is  %username%@%domainname% . With OpenLDAP\nit is simply  %username% . However, you could set it to an DN path, such as:  CN=%username%,OU=Users,DC=example,DC=com   server_selection  When more than one server is listed for a domain, choose which one is selected for the connection. The possible choices \nare  order  (tried in the order they appear) or  random .   Default :  order   use_paging  Whether or not the connection should try to page results by default.  Default :  true   page_size  The default page size to use for paging operations.  Default :  1000   port  The default port number to connect to LDAP on.  Default :  389   use_ssl  Whether or not to talk to LDAP over SSL. The default is  false . Typically you want to use the  use_tls  directive (in\nthe case of Active Directory). Setting this to  true  also changes the port to  636 .  Default :  false   use_tls  Whether or not to initiate TLS when connecting to LDAP. This is required for certain LDAP operations (such as password \nchanges in Active Directory). When using this directive you will often have to configure your  ldap.conf  file and add\nthe  TLS_REQCERT never  line. The  ldap.conf  file is in the following default locations:   Windows:  C:\\OpenLDAP\\sysconf\\ldap.conf  (If this directory structure does not exist, then create it...and the file)  Linux:  /etc/ldap/ldap.conf   However, be warned that using  TLS_REQCERT never  can be a bit of a security risk as it ignores invalid certificates.\nConsider copying your domain CA cert to  /etc/ssl/certs  then reference it in your  ldap.conf  with the  TLS_CACERT /etc/ssl/certs/ca.pem \noption combined with  TLS_REQCERT hard .  For more information on obtaining/using your LDAP SSL certificates, see  this cookbook doc .  Default :  false   ldap_type  The LDAP type for this domain. Choices are  ad  or  openldap .  Default :  ad   lazy_bind  If set to  true , then the connection will not automatically connect and bind when first created.  Default :  false   schema_name  The schema name to use for this domain. This typically refers to the name of the schema file to use within the path \ndefined by the  schema_folder  directive in the general section.   Default : The same value set for  ldap_type .   encoding  The encoding to use for this domain. Usernames, passwords, and any values not explicitly assigned to an Attribute\nConverter will be encoded with this encoding choice.  Default : UTF-8   ldap_options  The  LDAP_OPT_*  constants and values to use when connecting to LDAP. This is expected to be an array:  domains:\n    example:\n        ldap_options:\n            ldap_opt_protocol_version: 3\n            ldap_opt_referrals: 0  Default :  [LDAP_OPT_PROTOCOL_VERSION => 3, LDAP_OPT_REFERRALS => 0]   idle_reconnect  The elapsed time (in seconds) when an idle connection will attempt to reconnect to LDAP. A value of 0 means never. This\nis useful for long running processes where an LDAP connection is left open.  You should set this value sightly below the max idle time for your LDAP server. For Active Directory, idle connections \ntimeout after 15 minutes by default. For OpenLDAP, idle connections never timeout by default. You should check your\nLDAP server settings before changing this value.  domains:\n    example:\n        idle_reconnect: 0  Default :  600  (10 minutes)   connect_timeout  The elapsed time (in seconds) to attempt the initial connection to the LDAP server. If a connection cannot be established\nwithin this time the server will be considered unreachable/down.  domains:\n    example:\n        connect_timeout: 5  Default :  1",
            "title": "YAML Configuration"
        },
        {
            "location": "/reference/Schema-Configuration/",
            "text": "Schema Configuration\n\n\n\n\n\n\nSchema File Structure\n\n\nGeneral Schema File Options\n\n\nSchema Object Type Options\n\n\n\n\nLdapTools uses a schema definition to describe various LDAP objects in your directory service. This allows you to easily\ncreate and modify any part of the schema to suit your needs. Default schema definitions are included in the \n\nresources/schema\n directory in the root of this library. Both OpenLDAP and Active Directory have default schema files.\n\n\nThe schema definition allows you to abstract the LDAP schema so you can refer to objects by whatever name and attribute\nnames that you want within this class. It also allows you to assign attribute converters to LDAP attributes so you can \nconvert the data in LDAP to the way you want it to be displayed in PHP, and vice-versa.\n\n\nThe following serves as a reference for the structure of a schema and the possible configuration directives.\n\n\nSchema File Structure (YAML)\n\n\nThe schema YAML file is structured as follows:\n\n\n# This name must always be defined\nobjects:\n    # This name can be whatever you want, but must be unique for this section of the YAML.\n    user_object:\n        # ... Schema object directives are defined here\n    # Another schema object definition\n    group_object:\n        # ... More object directives are defined here\n\n\n\n\nSchema Configuration Options\n\n\n\n\nobjects \n(Required)\n\n\nUnderneath the \nobjects\n is where you define all your schema object definitions. This option must be defined.\n\n\nextends_default\n\n\n\n\nBy using this option you can specify the name of one of the default schemas to extend. Any options contained within that\nschema will be merged into your schema. To add additional options to existing schema types the keys underneath \"objects\"\nmust match between the default schema and your own!\n\n\n# Extends the default 'ad' schema included within the 'resources/schema' directory.\nextends_default: ad\nobjects:\n    # This 'user' key must exist in the default schema for it to merge, otherwise it will be considered a new object type.\n    user:\n        # Sets a custom repository definition for the user object, in addition to everything else in the default schema.\n        repository: '\\My\\Custom\\Repository'\n\n\n\n\ninclude\n\n\n\n\nBy using this option you can specify additional schema files to include within the current schema file. This way you can\nlogically separate your schema files and include them as needed. Note that the schema needs to exist within the folder\npath you defined for your schema in the configuration.\n\n\n# Includes a schema named 'custom'. This needs to exist within the schema folder you defined in your config settings.\ninclude: custom\nobjects:\n    # Include any additional schema object definitions ...\n\n\n\n\ninclude_default\n\n\n\n\nBy using this option you can specify additional schema files to include within the current schema file that exist within\nthe default schema folder. The only valid schema names for this are those that are included within this libraries default\nschema folder.\n\n\ninclude_default: exchange\nobjects:\n    # Include any additional schema object definitions ...\n\n\n\n\nSchema Object Configuration Options\n\n\n\n\ntype \n(Required)\n\n\nThe name for the type is how you will refer to this LDAP schema object within the class. This is a required field. \nDefault LDAP object types that the class has defined are: \nuser\n, \ngroup\n, \ncomputer\n, \ncontact\n.\n\n\n\n\nfilter\n\n\nThis is an instance of \n\\LdapTools\\Query\\Operator\\BaseOperator\n. This operator is used to construct the filter used to\nquery LDAP for the object type. You can omit the \nclass\n and \ncategory\n directives and only define a filter. If you\nalso define a \nclass\n and \ncategory\n they are added to this filter when the schema object is built.\n\n\nA simple filter example. This would select all objects with an objectClass equal to user that start with the name Admin.\n\n\n    filter:\n        eq: [ objectClass, user ]\n        starts_with: [ name, Admin ]\n\n\n\n\nA more complex example. All objects with an objectClass of user and an objectCategory person, and of those only objects\nwith an email address present whose department name begins with IT.\n\n\n    filter:\n        - and:\n            - eq: [ objectClass, user ]\n            - eq: [ objectCategory, person ]\n        - and:\n            - present: emailAddress\n            - starts_with: [ department, IT ]\n\n\n\n\nThis allows you to construct a query as complex as you need in an array representation. All of the methods used to\nconstruct the filter above (\nand\n, \neq\n, \npresent\n, \nstarts_with\n) are methods of the filter shortcuts from the\nLdapQueryBuilder class. The only difference being that instead of camel-case the method names should be formatted with\nunderscores.\n\n\nFor a complete list of methods available see the \nfilter shortcuts documentation\n.\n\n\n\n\nclass\n\n\nThis is the \nobjectClass\n value for the LDAP object you're defining. It can be any valid LDAP objectClass value (\nuser\n,\n\ninetOrgPerson\n, \ngroup\n, etc) and will be used in the creation of LDAP query filters when using this type. This can be\neither a single string, or an array with multiple class names.\n\n\n\n\ncategory\n\n\nThis is the \nobjectCategory\n value for the LDAP object you're defining. It can be any valid LDAP\nobjectCategory value (\nperson\n, \ncomputer\n, \ncontact\n, etc) and will be used in the creation of LDAP query filters \n(along with the \nclass\n definition above) when using this type.\n\n\n\n\nattributes\n\n\nThese should be \nkey: value\n pairs. Where the \nkey\n is the name you would like the refer to the LDAP attribute by \nwithin the class, and the \nvalue\n is the name of the attribute in LDAP (ie. \nfirstName: givenName\n).\n\n\n\n\nconverters\n\n\nThese should defined as keys with the converters name with an array of attribute name values:\n\n\n    windows_generalized_time:\n        - 'created'\n        - 'modified'\n\n\n\n\nThe attribute names can either be the schema defined attribute name, or the actual LDAP attribute name. For a \ncomplete listing of possible built-in attribute converters, see this \nreference doc\n.\n\n\n\n\nconverter_options\n\n\nThese should defined as keys with the converters name with an array of options that will be passed to the converter:\n\n\n    converter_options:\n        user_account_control:\n            defaultValue: '512'\n            uacMap:\n                disabled: '2'\n                passwordNeverExpires: '65536'\n                smartCardRequired: '262144'\n                trustedForDelegation: '262144'\n                passwordIsReversible: '128'\n\n\n\n\nThis results in an array with the keys \ndefaultValue\n and \nuacMap\n (and their respective arrays) being passed to the\nconverter. These options are accessible from within the attribute converter by using \n$this->options\n.\n\n\n\n\nattributes_to_select\n\n\nAn array of attributes that will be selected by default on LDAP queries when using this type.\n\n\n    attributes_to_select:\n        - 'firstName'\n        - 'lastName'\n        - 'guid'\n\n\n\n\n\n\nmultivalued_attributes\n\n\nAn array of attributes that are expected to be multivalued. Setting this for an attribute will force it to always return\nan array value regardless of the number of values it has. This allows for more predictable results.\n\n\n    multivalued_attributes:\n        - 'otherHomePhone'\n        - 'otherIpPhone'\n\n\n\n\n\n\nrepository\n\n\nThe full class name (ie \n\\MyNamespace\\MyClasses\\CustomRepository\n) to use as the default repository when calling\n \ngetRepository('object_type')\n on the \nLdapManager\n class. The class must extend \n\\LdapTools\\Object\\LdapObjectRepository\n.\n\n\n\n\ndefault_values\n\n\nAn array of attributes with what their default value should be set to whe creating this object using the \n\nLdapObjectCreator\n. These values also accept parameter values encased within \n%\n symbols that can resolve to other \nattribute values.\n\n\n    default_values:\n        firstName: \"%username%\"\n        displayName: \"%lastName%, %firstName%\"\n        description: \"%displayName%: Located in %city%\"\n        city: \"Utah\"\n\n\n\n\n\n\nrequired_attributes\n\n\nAn array of attributes that are required when creating this object type. If these are not present, an exception will be\nthrown. This will only happen if they are not specified on creation and not contained within the \ndefault_values\n list.\n\n\n    required_attributes:\n        - 'username'\n        - 'password'\n        - 'firstName'\n        - 'lastName'\n\n\n\n\n\n\ndefault_container\n\n\nThis should be a string in DN format that represents the OU/container where new objects for this LDAP type should be\nplaced by default when created.\n\n\n    default_container: 'OU=Accounting,OU=Employees,DC=example,DC=local'\n\n\n\n\n\n\nbase_dn\n\n\nThis should be a string in DN format that represents the OU/container where the base of a LDAP query for this LDAP type\nshould start. It also accepts parameter names for the defaultNamingContext and the configurationNamingContext.\n\n\n    # All LDAP objects under this path will be queried for the type.\n    base_dn: 'OU=OU=Employees,DC=example,DC=local'\n\n\n\n\n\n\ncontrols\n\n\nThese are arrays of LDAP controls that should be used when performing operations/queries with this schema type. Each\ncontrol should be an array with the OID, and optionally the criticality and value:\n\n\n    # The OID must come first, followed by whether the control is critical, and then an optional value.\n    # If you omit the criticality then it defaults to false.\n    controls:\n        - [ 1.2.840.113556.1.4.417, true ]  \n\n\n\n\n\n\npaging\n\n\nThis is a boolean value for whether or not paging should be used when querying for this object type. Certain controls\nrequire that paging is not used. If this is not defined then it will default to whatever you set in your domain config or\nthe Query Builder instance.\n\n\n    # Disable paging for queries using this schema type.\n    paging: false\n\n\n\n\n\n\nscope\n\n\nThis is a string value that determines the scope of the query performed when searching for this type. Possible values\nare \nsubtree\n (this is a recursive search), \nonelevel\n (this is a list search, only items located directly underneath \nthe \nbase_dn\n are found), and \nbase\n (this is a one-level search, only the object represented by the \nbase_dn\n is found).\n\n\n    # Only look for items directly underneath the base_dn.\n    scope: onelevel\n\n\n\n\n\n\nextends\n\n\nBy using this option you can explicitly state to make a object type extend another object and inherit everything it\nalready has defined. This value can either be a string, meaning that the object to extend already exists within the\ncurrent schema, or it can be an array. The array must be like \n[ schema, object ]\n, where \nschema\n is the name of a \nseparate schema file within the same schema folder and \nobject\n is the name of a defined object type within that schema. \n\n\nobjects:\n    user:\n        # A bunch of stuff defined...\n    custom_user:\n        # Tells it to 'extend' the user type defined above and inherit its properties.\n        extends: user\n        # Make sure the define a different type!\n        type: custom_user\n    another_user:\n        # Tells it to look in the schema file called 'custom' for the object type 'user' and extend that.\n        extends: [ custom, user ]\n        type: another_user\n\n\n\n\n\n\nextends_default\n\n\nBy using this option you can tell the schema to extend a specific object type from a default schema, either \nad\n or \n\nopenldap\n. This helps you to avoid repetition when configuring your own schema yet still customize it to your needs.\nThis value must be an array that contains the default schema name and object type to extend.\n\n\nobjects:\n    special_user:\n        # Extends the default AD user type.\n        extends_default: [ ad, user ]\n        type: special_user\n        # Put these accounts in a specific OU\n        default_container: 'ou=special accounts,dc=example,dc=local'\n        # Add an additional attribute to select.\n        attributes_to_select:\n            - 'title'",
            "title": "Schema Configuration"
        },
        {
            "location": "/reference/Schema-Configuration/#schema-configuration",
            "text": "Schema File Structure  General Schema File Options  Schema Object Type Options   LdapTools uses a schema definition to describe various LDAP objects in your directory service. This allows you to easily\ncreate and modify any part of the schema to suit your needs. Default schema definitions are included in the  resources/schema  directory in the root of this library. Both OpenLDAP and Active Directory have default schema files.  The schema definition allows you to abstract the LDAP schema so you can refer to objects by whatever name and attribute\nnames that you want within this class. It also allows you to assign attribute converters to LDAP attributes so you can \nconvert the data in LDAP to the way you want it to be displayed in PHP, and vice-versa.  The following serves as a reference for the structure of a schema and the possible configuration directives.",
            "title": "Schema Configuration"
        },
        {
            "location": "/reference/Schema-Configuration/#schema-file-structure-yaml",
            "text": "The schema YAML file is structured as follows:  # This name must always be defined\nobjects:\n    # This name can be whatever you want, but must be unique for this section of the YAML.\n    user_object:\n        # ... Schema object directives are defined here\n    # Another schema object definition\n    group_object:\n        # ... More object directives are defined here  Schema Configuration Options   objects  (Required)  Underneath the  objects  is where you define all your schema object definitions. This option must be defined.  extends_default   By using this option you can specify the name of one of the default schemas to extend. Any options contained within that\nschema will be merged into your schema. To add additional options to existing schema types the keys underneath \"objects\"\nmust match between the default schema and your own!  # Extends the default 'ad' schema included within the 'resources/schema' directory.\nextends_default: ad\nobjects:\n    # This 'user' key must exist in the default schema for it to merge, otherwise it will be considered a new object type.\n    user:\n        # Sets a custom repository definition for the user object, in addition to everything else in the default schema.\n        repository: '\\My\\Custom\\Repository'  include   By using this option you can specify additional schema files to include within the current schema file. This way you can\nlogically separate your schema files and include them as needed. Note that the schema needs to exist within the folder\npath you defined for your schema in the configuration.  # Includes a schema named 'custom'. This needs to exist within the schema folder you defined in your config settings.\ninclude: custom\nobjects:\n    # Include any additional schema object definitions ...  include_default   By using this option you can specify additional schema files to include within the current schema file that exist within\nthe default schema folder. The only valid schema names for this are those that are included within this libraries default\nschema folder.  include_default: exchange\nobjects:\n    # Include any additional schema object definitions ...  Schema Object Configuration Options   type  (Required)  The name for the type is how you will refer to this LDAP schema object within the class. This is a required field. \nDefault LDAP object types that the class has defined are:  user ,  group ,  computer ,  contact .   filter  This is an instance of  \\LdapTools\\Query\\Operator\\BaseOperator . This operator is used to construct the filter used to\nquery LDAP for the object type. You can omit the  class  and  category  directives and only define a filter. If you\nalso define a  class  and  category  they are added to this filter when the schema object is built.  A simple filter example. This would select all objects with an objectClass equal to user that start with the name Admin.      filter:\n        eq: [ objectClass, user ]\n        starts_with: [ name, Admin ]  A more complex example. All objects with an objectClass of user and an objectCategory person, and of those only objects\nwith an email address present whose department name begins with IT.      filter:\n        - and:\n            - eq: [ objectClass, user ]\n            - eq: [ objectCategory, person ]\n        - and:\n            - present: emailAddress\n            - starts_with: [ department, IT ]  This allows you to construct a query as complex as you need in an array representation. All of the methods used to\nconstruct the filter above ( and ,  eq ,  present ,  starts_with ) are methods of the filter shortcuts from the\nLdapQueryBuilder class. The only difference being that instead of camel-case the method names should be formatted with\nunderscores.  For a complete list of methods available see the  filter shortcuts documentation .   class  This is the  objectClass  value for the LDAP object you're defining. It can be any valid LDAP objectClass value ( user , inetOrgPerson ,  group , etc) and will be used in the creation of LDAP query filters when using this type. This can be\neither a single string, or an array with multiple class names.   category  This is the  objectCategory  value for the LDAP object you're defining. It can be any valid LDAP\nobjectCategory value ( person ,  computer ,  contact , etc) and will be used in the creation of LDAP query filters \n(along with the  class  definition above) when using this type.   attributes  These should be  key: value  pairs. Where the  key  is the name you would like the refer to the LDAP attribute by \nwithin the class, and the  value  is the name of the attribute in LDAP (ie.  firstName: givenName ).   converters  These should defined as keys with the converters name with an array of attribute name values:      windows_generalized_time:\n        - 'created'\n        - 'modified'  The attribute names can either be the schema defined attribute name, or the actual LDAP attribute name. For a \ncomplete listing of possible built-in attribute converters, see this  reference doc .   converter_options  These should defined as keys with the converters name with an array of options that will be passed to the converter:      converter_options:\n        user_account_control:\n            defaultValue: '512'\n            uacMap:\n                disabled: '2'\n                passwordNeverExpires: '65536'\n                smartCardRequired: '262144'\n                trustedForDelegation: '262144'\n                passwordIsReversible: '128'  This results in an array with the keys  defaultValue  and  uacMap  (and their respective arrays) being passed to the\nconverter. These options are accessible from within the attribute converter by using  $this->options .   attributes_to_select  An array of attributes that will be selected by default on LDAP queries when using this type.      attributes_to_select:\n        - 'firstName'\n        - 'lastName'\n        - 'guid'   multivalued_attributes  An array of attributes that are expected to be multivalued. Setting this for an attribute will force it to always return\nan array value regardless of the number of values it has. This allows for more predictable results.      multivalued_attributes:\n        - 'otherHomePhone'\n        - 'otherIpPhone'   repository  The full class name (ie  \\MyNamespace\\MyClasses\\CustomRepository ) to use as the default repository when calling\n  getRepository('object_type')  on the  LdapManager  class. The class must extend  \\LdapTools\\Object\\LdapObjectRepository .   default_values  An array of attributes with what their default value should be set to whe creating this object using the  LdapObjectCreator . These values also accept parameter values encased within  %  symbols that can resolve to other \nattribute values.      default_values:\n        firstName: \"%username%\"\n        displayName: \"%lastName%, %firstName%\"\n        description: \"%displayName%: Located in %city%\"\n        city: \"Utah\"   required_attributes  An array of attributes that are required when creating this object type. If these are not present, an exception will be\nthrown. This will only happen if they are not specified on creation and not contained within the  default_values  list.      required_attributes:\n        - 'username'\n        - 'password'\n        - 'firstName'\n        - 'lastName'   default_container  This should be a string in DN format that represents the OU/container where new objects for this LDAP type should be\nplaced by default when created.      default_container: 'OU=Accounting,OU=Employees,DC=example,DC=local'   base_dn  This should be a string in DN format that represents the OU/container where the base of a LDAP query for this LDAP type\nshould start. It also accepts parameter names for the defaultNamingContext and the configurationNamingContext.      # All LDAP objects under this path will be queried for the type.\n    base_dn: 'OU=OU=Employees,DC=example,DC=local'   controls  These are arrays of LDAP controls that should be used when performing operations/queries with this schema type. Each\ncontrol should be an array with the OID, and optionally the criticality and value:      # The OID must come first, followed by whether the control is critical, and then an optional value.\n    # If you omit the criticality then it defaults to false.\n    controls:\n        - [ 1.2.840.113556.1.4.417, true ]     paging  This is a boolean value for whether or not paging should be used when querying for this object type. Certain controls\nrequire that paging is not used. If this is not defined then it will default to whatever you set in your domain config or\nthe Query Builder instance.      # Disable paging for queries using this schema type.\n    paging: false   scope  This is a string value that determines the scope of the query performed when searching for this type. Possible values\nare  subtree  (this is a recursive search),  onelevel  (this is a list search, only items located directly underneath \nthe  base_dn  are found), and  base  (this is a one-level search, only the object represented by the  base_dn  is found).      # Only look for items directly underneath the base_dn.\n    scope: onelevel   extends  By using this option you can explicitly state to make a object type extend another object and inherit everything it\nalready has defined. This value can either be a string, meaning that the object to extend already exists within the\ncurrent schema, or it can be an array. The array must be like  [ schema, object ] , where  schema  is the name of a \nseparate schema file within the same schema folder and  object  is the name of a defined object type within that schema.   objects:\n    user:\n        # A bunch of stuff defined...\n    custom_user:\n        # Tells it to 'extend' the user type defined above and inherit its properties.\n        extends: user\n        # Make sure the define a different type!\n        type: custom_user\n    another_user:\n        # Tells it to look in the schema file called 'custom' for the object type 'user' and extend that.\n        extends: [ custom, user ]\n        type: another_user   extends_default  By using this option you can tell the schema to extend a specific object type from a default schema, either  ad  or  openldap . This helps you to avoid repetition when configuring your own schema yet still customize it to your needs.\nThis value must be an array that contains the default schema name and object type to extend.  objects:\n    special_user:\n        # Extends the default AD user type.\n        extends_default: [ ad, user ]\n        type: special_user\n        # Put these accounts in a specific OU\n        default_container: 'ou=special accounts,dc=example,dc=local'\n        # Add an additional attribute to select.\n        attributes_to_select:\n            - 'title'",
            "title": "Schema File Structure (YAML)"
        }
    ]
}